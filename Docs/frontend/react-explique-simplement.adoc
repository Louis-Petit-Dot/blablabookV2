= React ExpliquÃ© Simplement - Pour les Humains
:toc:
:toc-title: Table des matiÃ¨res
:sectnums:

== Introduction

Ce document explique comment fonctionne ton application React **sans jargon technique**, avec des mots simples et des exemples concrets.

== Le Grand Tableau : Comment Tout Fonctionne

Imagine ton application comme une **maison** :

- **index.html** = La porte d'entrÃ©e
- **main.tsx** = Le hall d'entrÃ©e qui accueille les visiteurs
- **App.tsx** = Le plan de la maison qui dit "le salon est Ã  gauche, la cuisine Ã  droite"
- **Les pages** = Les piÃ¨ces de la maison (salon, cuisine, chambre)
- **Les composants** = Les meubles dans chaque piÃ¨ce (table, chaise, lampe)
- **Les styles (SCSS)** = La dÃ©coration et les couleurs
- **api.ts** = Le tÃ©lÃ©phone qui permet de parler au backend

---

== 1. Vite : L'Outil Magique qui AccÃ©lÃ¨re Tout

=== C'est quoi Vite ?

**Vite**, c'est comme un **assistant super rapide** qui :
- DÃ©marre ton application en 1 seconde (au lieu de 30 secondes)
- Recharge automatiquement la page quand tu modifies ton code
- PrÃ©pare ton application pour la mise en ligne

=== Pourquoi c'est magique ?

Avant, quand tu modifiais ton code, il fallait :
1. Sauvegarder
2. Attendre 10 secondes
3. Recharger la page manuellement
4. Recommencer depuis le dÃ©but (perdre ton Ã©tat)

Avec Vite :
1. Tu sauvegardes
2. **POUF** â†’ Changement instantanÃ© dans le navigateur
3. Tout reste comme avant (pas besoin de tout recommencer)

**Exemple concret** :

Tu es en train de remplir un formulaire pour tester. Tu remarques un bug dans le bouton.

- **Sans Vite** : Tu corriges le bug, tu recharges la page, tu dois RE-remplir tout le formulaire
- **Avec Vite** : Tu corriges le bug, le bouton se met Ã  jour MAIS le formulaire reste rempli !

=== Le fichier vite.config.ts

C'est comme les **rÃ©glages de Vite**. Tu lui dis :

[source,typescript]
----
{
    port: 3001,  // "Lance le serveur sur le port 3001"

    proxy: {     // "Quand je demande /api, va chercher sur localhost:3000"
        '/api': 'http://localhost:3000'
    },

    alias: {     // "Quand j'Ã©cris @, Ã§a veut dire src/"
        '@': '/src'
    }
}
----

**Le proxy expliquÃ© simplement** :

Imagine que tu es dans un restaurant (frontend). Tu demandes au serveur (Vite) un plat.
Le serveur va en cuisine (backend sur port 3000) chercher ton plat et te le rapporte.

Tu n'as jamais Ã  aller en cuisine toi-mÃªme â†’ Pas de problÃ¨me CORS !

---

== 2. React : Les Briques de Lego

=== Le principe de base

React, c'est comme des **briques de Lego** :
- Tu crÃ©es des petites briques (composants)
- Tu les assembles pour faire des structures plus grandes
- Tu peux rÃ©utiliser les mÃªmes briques partout

=== Un composant, c'est quoi ?

**Un composant = une fonction qui retourne du HTML**

[source,typescript]
----
function Bonjour() {
  return <h1>Bonjour le monde !</h1>
}
----

C'est tout ! Tu as crÃ©Ã© un composant.

**Utilisation** :

[source,typescript]
----
function App() {
  return (
    <div>
      <Bonjour />
      <Bonjour />
      <Bonjour />
    </div>
  )
}
----

RÃ©sultat : 3 fois "Bonjour le monde !"

=== Les Props : Passer des Infos

Les **props**, c'est comme les **arguments d'une fonction**.

**Analogie** : Imagine un moule Ã  gÃ¢teau

[source,typescript]
----
function Gateau({ parfum, couleur }) {
  return (
    <div>
      <p>GÃ¢teau au {parfum}</p>
      <p style={{ color: couleur }}>Avec un glaÃ§age {couleur}</p>
    </div>
  )
}

// Utilisation
<Gateau parfum="chocolat" couleur="marron" />
<Gateau parfum="fraise" couleur="rose" />
----

**Le moule est le mÃªme, mais tu changes les ingrÃ©dients** â†’ Tu obtiens des gÃ¢teaux diffÃ©rents !

=== Le State : La MÃ©moire du Composant

Le **state**, c'est la **mÃ©moire** d'un composant.

**Exemple simple** : Un compteur

[source,typescript]
----
function Compteur() {
  const [nombre, setNombre] = useState(0)
  //      â†‘ valeur actuelle
  //              â†‘ fonction pour changer la valeur
  //                            â†‘ valeur de dÃ©part

  return (
    <div>
      <p>Compteur : {nombre}</p>
      <button onClick={() => setNombre(nombre + 1)}>
        +1
      </button>
    </div>
  )
}
----

**Ce qui se passe** :

1. Au dÃ©but, `nombre = 0`
2. Tu cliques sur le bouton
3. `setNombre(nombre + 1)` â†’ `nombre = 1`
4. React **redessine** automatiquement le composant avec la nouvelle valeur
5. Tu vois "Compteur : 1"

**RÃ¨gle d'or** : Pour changer une valeur, TOUJOURS utiliser le `set...`

âŒ `nombre = nombre + 1` (ne marche PAS)
âœ… `setNombre(nombre + 1)` (OK !)

=== useEffect : Faire des Choses au Bon Moment

`useEffect`, c'est pour dire Ã  React : **"Fais Ã§a quand..."**

**Exemple 1** : "Quand le composant s'affiche"

[source,typescript]
----
useEffect(() => {
  console.log("Je suis affichÃ© !")
}, [])  // Les [] vides = "Une seule fois au dÃ©but"
----

**Exemple 2** : "Quand 'recherche' change"

[source,typescript]
----
const [recherche, setRecherche] = useState("")

useEffect(() => {
  console.log("Tu as cherchÃ© :", recherche)
}, [recherche])  // Se dÃ©clenche quand 'recherche' change
----

**Analogie de la vie rÃ©elle** :

`useEffect` c'est comme un **rÃ©veil programmable**

- `useEffect(() => {...}, [])` â†’ RÃ©veil qui sonne UNE fois au rÃ©veil
- `useEffect(() => {...}, [x])` â†’ RÃ©veil qui sonne chaque fois que X change
- `useEffect(() => {...})` â†’ RÃ©veil qui sonne TOUT LE TEMPS (Ã©viter !)

---

== 3. React Router : Le GPS de l'Application

=== Le principe

**React Router**, c'est le **GPS** de ton application.

Tu tapes une adresse (URL) â†’ Il t'emmÃ¨ne Ã  la bonne page.

=== Comment Ã§a marche

**1. Le garage (BrowserRouter)** dans `main.tsx`

[source,typescript]
----
<BrowserRouter>
  <App />
</BrowserRouter>
----

Ã‡a dit : "Cette application peut naviguer entre diffÃ©rentes pages"

**2. Le plan des routes (Routes)** dans `App.tsx`

[source,typescript]
----
<Routes>
  <Route path="/" element={<Accueil />} />
  <Route path="/profil" element={<Profil />} />
  <Route path="/messages" element={<Messages />} />
</Routes>
----

**Traduction en franÃ§ais** :

- Si l'URL est `/` â†’ Affiche le composant `Accueil`
- Si l'URL est `/profil` â†’ Affiche le composant `Profil`
- Si l'URL est `/messages` â†’ Affiche le composant `Messages`

=== Navigation

**Avec des liens (comme un menu)** :

[source,typescript]
----
import { Link } from 'react-router-dom'

<Link to="/">Accueil</Link>
<Link to="/profil">Mon Profil</Link>
----

Quand tu cliques â†’ L'URL change â†’ React Router affiche la bonne page

**Avec du code (navigation automatique)** :

[source,typescript]
----
import { useNavigate } from 'react-router-dom'

function Connexion() {
  const navigate = useNavigate()

  const seConnecter = () => {
    // ... connexion rÃ©ussie ...
    navigate('/dashboard')  // Redirige vers le dashboard
  }

  return <button onClick={seConnecter}>Se connecter</button>
}
----

=== Les paramÃ¨tres dans l'URL

Tu peux mettre des **variables** dans l'URL, comme des espaces rÃ©servÃ©s :

[source,typescript]
----
// DÃ©finition
<Route path="/users/:id" element={<ProfilUtilisateur />} />

// Dans le composant
function ProfilUtilisateur() {
  const { id } = useParams()  // RÃ©cupÃ¨re l'ID de l'URL

  return <p>Profil de l'utilisateur numÃ©ro {id}</p>
}
----

**Exemples** :
- URL : `/users/123` â†’ `id = "123"`
- URL : `/users/456` â†’ `id = "456"`

**Analogie** : C'est comme une adresse postale

- `/users/:id` â†’ "Rue des utilisateurs, numÃ©ro ?"
- `/users/123` â†’ "Rue des utilisateurs, numÃ©ro 123"

---

== 4. L'Architecture : Comment Ranger Ses Affaires

=== La structure des dossiers

Imagine que tu ranges ta maison :

[source,text]
----
src/
â”œâ”€â”€ main.tsx              # La porte d'entrÃ©e
â”œâ”€â”€ App.tsx               # Le plan de la maison
â”‚
â”œâ”€â”€ pages/                # Les piÃ¨ces de ta maison
â”‚   â”œâ”€â”€ Accueil.tsx      #   â†’ Le salon
â”‚   â”œâ”€â”€ Profil.tsx       #   â†’ La chambre
â”‚   â””â”€â”€ Messages.tsx     #   â†’ Le bureau
â”‚
â”œâ”€â”€ components/           # Les meubles rÃ©utilisables
â”‚   â”œâ”€â”€ Bouton.tsx       #   â†’ Une chaise (tu peux en mettre partout)
â”‚   â”œâ”€â”€ Carte.tsx        #   â†’ Une table
â”‚   â””â”€â”€ Header.tsx       #   â†’ Un lustre au plafond
â”‚
â”œâ”€â”€ lib/                  # Les outils
â”‚   â””â”€â”€ api.ts           #   â†’ Le tÃ©lÃ©phone pour appeler l'extÃ©rieur
â”‚
â””â”€â”€ styles/               # La dÃ©coration
    â””â”€â”€ index.scss       #   â†’ Les couleurs et le style
----

=== Pages vs Composants

**Pages** = Les **piÃ¨ces** de ta maison
- Une page par URL
- Contient plusieurs composants
- C'est le "chef d'orchestre"

**Composants** = Les **meubles**
- Petits, rÃ©utilisables
- Peuvent aller dans n'importe quelle page
- Font une seule chose, mais bien

**Exemple concret** :

[source,typescript]
----
// PAGE : pages/Accueil.tsx
function Accueil() {
  return (
    <div>
      <Header />           {/* Composant */}
      <Bienvenue />        {/* Composant */}
      <ListeArticles />    {/* Composant */}
      <Footer />           {/* Composant */}
    </div>
  )
}

// COMPOSANT : components/Bienvenue.tsx
function Bienvenue() {
  return <h1>Bienvenue sur BlaBlaBook !</h1>
}
----

---

== 5. Comment les Composants Communiquent

=== 1. Du parent vers l'enfant : Les Props

**Le parent donne des infos Ã  l'enfant**

[source,typescript]
----
// Parent
function Parent() {
  return <Enfant nom="Alice" age={10} />
}

// Enfant
function Enfant({ nom, age }) {
  return <p>{nom} a {age} ans</p>
}
----

**Analogie** : Un parent donne de l'argent de poche Ã  son enfant

=== 2. De l'enfant vers le parent : Les Callbacks

**L'enfant appelle une fonction que le parent lui a donnÃ©e**

[source,typescript]
----
// Parent
function Parent() {
  const direBonjour = (prenom) => {
    alert(`Bonjour ${prenom} !`)
  }

  return <Enfant onDireBonjour={direBonjour} />
}

// Enfant
function Enfant({ onDireBonjour }) {
  return (
    <button onClick={() => onDireBonjour("Alice")}>
      Clique-moi
    </button>
  )
}
----

**Analogie** : L'enfant sonne une clochette, le parent entend et rÃ©agit

=== 3. Entre frÃ¨res et sÅ“urs : Remonter au parent

Les composants "frÃ¨res" ne peuvent PAS se parler directement.
Il faut **remonter au parent commun**.

[source,typescript]
----
function Parent() {
  const [message, setMessage] = useState("")

  return (
    <div>
      <Frere1 onEnvoyer={setMessage} />
      <Frere2 message={message} />
    </div>
  )
}

function Frere1({ onEnvoyer }) {
  return (
    <button onClick={() => onEnvoyer("Coucou !")}>
      Envoyer un message
    </button>
  )
}

function Frere2({ message }) {
  return <p>Message reÃ§u : {message}</p>
}
----

**Ce qui se passe** :
1. FrÃ¨re 1 clique â†’ Appelle `onEnvoyer("Coucou !")`
2. Le parent reÃ§oit â†’ Met Ã  jour `message`
3. Le parent redonne `message` Ã  FrÃ¨re 2
4. FrÃ¨re 2 affiche le message

=== 4. Communication globale : Zustand

Parfois, tu as besoin de **partager des infos partout** (utilisateur connectÃ©, thÃ¨me, langue...).

Au lieu de faire passer les props de parent en parent en parent... tu utilises un **store global**.

[source,typescript]
----
// stores/authStore.ts
import { create } from 'zustand'

const useAuthStore = create((set) => ({
  user: null,
  connexion: (user) => set({ user }),
  deconnexion: () => set({ user: null })
}))

// N'importe oÃ¹ dans l'application
function Header() {
  const user = useAuthStore(state => state.user)
  const deconnexion = useAuthStore(state => state.deconnexion)

  return (
    <div>
      <p>Bonjour {user?.nom}</p>
      <button onClick={deconnexion}>DÃ©connexion</button>
    </div>
  )
}
----

**Analogie** : C'est comme un **tableau d'affichage** dans une Ã©cole
- N'importe qui peut lire ce qui est Ã©crit
- N'importe qui peut Ã©crire dessus
- Tout le monde voit les mÃªmes informations

---

== 6. Les Appels API : Parler au Backend

=== Le fichier api.ts : Ton TÃ©lÃ©phone

Le fichier `api.ts`, c'est ton **tÃ©lÃ©phone configurÃ©** pour appeler le backend.

[source,typescript]
----
import axios from 'axios'

const api = axios.create({
  baseURL: 'http://localhost:3000',  // NumÃ©ro du backend
  timeout: 10000,                     // Raccroche aprÃ¨s 10 secondes
  withCredentials: true               // Envoie les cookies
})
----

**withCredentials** : C'est comme si tu donnais ton **badge d'identitÃ©** Ã  chaque appel.

=== Faire un appel

[source,typescript]
----
function ListeUtilisateurs() {
  const [users, setUsers] = useState([])

  useEffect(() => {
    // Appel API au chargement du composant
    api.get('/api/users')
      .then(response => {
        setUsers(response.data)  // Sauvegarde les utilisateurs
      })
      .catch(error => {
        console.error("Erreur :", error)
      })
  }, [])

  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  )
}
----

**Ã‰tapes** :
1. Le composant s'affiche
2. `useEffect` se dÃ©clenche
3. Appel Ã  `api.get('/api/users')`
4. Le backend rÃ©pond avec une liste d'utilisateurs
5. `setUsers(...)` sauvegarde les utilisateurs
6. React redessine le composant avec les donnÃ©es

**Analogie de l'appel API** :

1. Tu passes un coup de fil (GET /api/users)
2. La personne dÃ©croche et te parle (le backend rÃ©pond)
3. Tu notes ce qu'elle te dit (setUsers)
4. Tu utilises ces notes pour afficher des choses

=== Les diffÃ©rents types d'appels

[source,typescript]
----
// RÃ‰CUPÃ‰RER des donnÃ©es (GET)
api.get('/api/users')

// CRÃ‰ER quelque chose (POST)
api.post('/api/users', { nom: 'Alice', age: 25 })

// MODIFIER quelque chose (PUT)
api.put('/api/users/123', { nom: 'Alice Dupont' })

// SUPPRIMER quelque chose (DELETE)
api.delete('/api/users/123')
----

**Analogie restaurant** :

- **GET** : "Montre-moi la carte"
- **POST** : "Je voudrais commander un steak"
- **PUT** : "En fait, change mon steak en poulet"
- **DELETE** : "Annule ma commande"

---

== 7. Les Styles : Rendre Tout Joli

=== SCSS : Le CSS AmÃ©liorÃ©

**SCSS**, c'est comme CSS mais avec des **super-pouvoirs** :
- Tu peux imbriquer (mettre des rÃ¨gles dans d'autres)
- Tu peux crÃ©er des variables
- Tu peux faire des calculs

=== Variables SCSS

[source,scss]
----
// _variables.scss
$couleur-primaire: #6366f1;
$espace: 1rem;

// Utilisation
.bouton {
  background: $couleur-primaire;
  padding: $espace;
}
----

**Avantage** : Tu changes la couleur **une seule fois** et Ã§a se met Ã  jour partout !

=== Imbrication

[source,scss]
----
.carte {
  padding: 1rem;
  border: 1px solid gray;

  .titre {
    font-size: 1.5rem;
    color: blue;
  }

  .description {
    color: gray;
  }
}
----

**Ã‰quivalent CSS** :

[source,css]
----
.carte {
  padding: 1rem;
  border: 1px solid gray;
}

.carte .titre {
  font-size: 1.5rem;
  color: blue;
}

.carte .description {
  color: gray;
}
----

C'est plus **lisible** et **organisÃ©** !

=== Utilisation dans les composants

[source,typescript]
----
// MonComposant.tsx
import './MonComposant.scss'

function MonComposant() {
  return (
    <div className="mon-composant">
      <h1 className="titre">Titre</h1>
    </div>
  )
}
----

---

== 8. Le Cycle de Vie Complet : Un Exemple Concret

Imaginons que tu crÃ©es une page pour afficher une liste de livres.

=== 1. Tu crÃ©es la page

[source,typescript]
----
// pages/Livres.tsx
function Livres() {
  const [livres, setLivres] = useState([])
  const [chargement, setChargement] = useState(true)

  useEffect(() => {
    // Au chargement de la page
    api.get('/api/livres')
      .then(response => {
        setLivres(response.data)
        setChargement(false)
      })
  }, [])

  if (chargement) {
    return <p>Chargement...</p>
  }

  return (
    <div>
      <h1>Mes livres</h1>
      {livres.map(livre => (
        <CarteLivre key={livre.id} livre={livre} />
      ))}
    </div>
  )
}
----

=== 2. Tu crÃ©es un composant rÃ©utilisable

[source,typescript]
----
// components/CarteLivre.tsx
function CarteLivre({ livre }) {
  return (
    <div className="carte-livre">
      <h2>{livre.titre}</h2>
      <p>Par {livre.auteur}</p>
      <p>{livre.prix} â‚¬</p>
    </div>
  )
}
----

=== 3. Tu ajoutes la route

[source,typescript]
----
// App.tsx
<Routes>
  <Route path="/" element={<Accueil />} />
  <Route path="/livres" element={<Livres />} />
</Routes>
----

=== 4. Tu styles

[source,scss]
----
// CarteLivre.scss
.carte-livre {
  padding: 1rem;
  border: 1px solid #ddd;
  border-radius: 8px;
  margin-bottom: 1rem;

  h2 {
    color: #333;
    font-size: 1.2rem;
  }

  p {
    color: #666;
  }
}
----

=== Ce qui se passe quand l'utilisateur visite /livres

[source,text]
----
1. L'utilisateur tape /livres dans l'URL
2. React Router voit que /livres â†’ Composant Livres
3. Le composant Livres s'affiche
4. useState crÃ©e deux variables : livres=[] et chargement=true
5. useEffect se dÃ©clenche
6. Appel API Ã  /api/livres
7. Pendant ce temps, on affiche "Chargement..."
8. Le backend rÃ©pond avec les livres
9. setLivres met Ã  jour avec les donnÃ©es
10. setChargement met chargement Ã  false
11. React redessine le composant
12. On affiche la liste des livres avec CarteLivre
----

---

== 9. Les PiÃ¨ges Courants (et Comment les Ã‰viter)

=== PiÃ¨ge 1 : Modifier le state directement

âŒ **MAL** :
[source,typescript]
----
const [count, setCount] = useState(0)
count = count + 1  // NE MARCHE PAS
----

âœ… **BIEN** :
[source,typescript]
----
const [count, setCount] = useState(0)
setCount(count + 1)  // OK !
----

=== PiÃ¨ge 2 : Oublier les dÃ©pendances dans useEffect

âŒ **MAL** :
[source,typescript]
----
useEffect(() => {
  console.log(count)
}, [])  // count peut changer, mais useEffect ne se relance pas
----

âœ… **BIEN** :
[source,typescript]
----
useEffect(() => {
  console.log(count)
}, [count])  // Se relance quand count change
----

=== PiÃ¨ge 3 : Oublier la key dans les listes

âŒ **MAL** :
[source,typescript]
----
{users.map(user => (
  <div>{user.name}</div>
))}
----

âœ… **BIEN** :
[source,typescript]
----
{users.map(user => (
  <div key={user.id}>{user.name}</div>
))}
----

**Pourquoi ?** React a besoin d'un identifiant unique pour savoir quel Ã©lÃ©ment a changÃ©.

=== PiÃ¨ge 4 : Ne pas gÃ©rer les erreurs d'API

âŒ **MAL** :
[source,typescript]
----
api.get('/api/users')
  .then(response => setUsers(response.data))
// Pas de .catch â†’ Si erreur, l'app plante
----

âœ… **BIEN** :
[source,typescript]
----
api.get('/api/users')
  .then(response => setUsers(response.data))
  .catch(error => {
    console.error(error)
    alert("Erreur de chargement")
  })
----

---

== 10. RÃ©capitulatif avec des Analogies

|===
|Concept |Analogie de la vie rÃ©elle

|**React**
|Jeu de Lego : tu assembles des briques

|**Composant**
|Une brique de Lego

|**Props**
|Les infos que tu donnes Ã  une brique (couleur, taille)

|**State**
|La mÃ©moire d'une brique (elle se souvient de trucs)

|**useEffect**
|Un rÃ©veil programmable qui se dÃ©clenche au bon moment

|**React Router**
|Un GPS qui t'emmÃ¨ne Ã  la bonne page

|**Vite**
|Un assistant ultra-rapide qui recharge ton app instantanÃ©ment

|**api.ts**
|Un tÃ©lÃ©phone pour appeler le backend

|**SCSS**
|La dÃ©co et les couleurs de ta maison

|**Zustand**
|Un tableau d'affichage visible par tous
|===

---

== 11. Questions FrÃ©quentes (en FranÃ§ais Simple)

=== "Pourquoi on utilise const pour les composants ?"

Pas obligÃ© ! Tu peux Ã©crire :
[source,typescript]
----
function MonComposant() { ... }
// ou
const MonComposant = () => { ... }
----

Les deux marchent. C'est juste une question de style.

=== "C'est quoi le ! Ã  la fin de getElementById ?"

[source,typescript]
----
document.getElementById('root')!
----

Le `!` dit Ã  TypeScript : **"Fais-moi confiance, cet Ã©lÃ©ment existe"**

Sans le `!`, TypeScript dit : "HÃ©, et si l'Ã©lÃ©ment n'existe pas ?"

=== "Pourquoi map() et pas une boucle for ?"

[source,typescript]
----
{users.map(user => <div>{user.name}</div>)}
----

En React, tu ne peux pas utiliser `for` directement dans le JSX.
`map()` transforme un tableau en un autre tableau (ici, un tableau de composants).

=== "C'est quoi les {} dans le JSX ?"

Les `{}` disent : **"Ici, je mets du JavaScript"**

[source,typescript]
----
<p>Bonjour</p>              // Texte normal
<p>{nom}</p>                // Variable JavaScript
<p>{2 + 2}</p>              // Calcul JavaScript
<p>{user ? 'Oui' : 'Non'}</p>  // Condition JavaScript
----

=== "useState vs variables normales ?"

**Variable normale** :
[source,typescript]
----
let count = 0
count = count + 1
// React ne sait pas que Ã§a a changÃ© â†’ Pas de re-render
----

**useState** :
[source,typescript]
----
const [count, setCount] = useState(0)
setCount(count + 1)
// React SAIT que Ã§a a changÃ© â†’ Re-render automatique
----

**RÃ¨gle** : Si tu veux que React redessine quand Ã§a change â†’ `useState`

---

== 12. Pour Aller Plus Loin

=== Prochaines Ã©tapes

Maintenant que tu comprends les bases :

1. **Pratique** : CrÃ©e des petits composants simples
2. **ExpÃ©rimente** : Modifie ton code et vois ce qui se passe
3. **Regarde** : Ouvre les React DevTools dans ton navigateur
4. **Lis** : Le code des autres pour voir comment ils font

=== Ressources recommandÃ©es

- **React Docs officielle** (en anglais mais avec des exemples visuels)
- **Console du navigateur** : Ton meilleur ami pour dÃ©bugger
- **React DevTools** : Extension Chrome/Firefox pour voir tes composants

---

== Conclusion

**L'essentiel Ã  retenir** :

1. **React = Lego** : Tu assembles des composants
2. **Props** : Pour passer des infos aux enfants
3. **State** : Pour se souvenir de choses
4. **useEffect** : Pour faire des choses au bon moment
5. **React Router** : Pour la navigation
6. **api.ts** : Pour parler au backend
7. **Vite** : Pour que ce soit rapide

**Et surtout** : N'aie pas peur de casser des trucs ! C'est comme Ã§a qu'on apprend.

Tu peux toujours revenir en arriÃ¨re avec Git ðŸ˜‰
