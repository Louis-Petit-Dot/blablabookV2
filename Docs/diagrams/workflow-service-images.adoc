= Workflow Service Images - BlaBlaBook V2
:toc:
:toc-title: Sommaire
:sectnums:
:icons: font
:version: 2.0
:date: {docdate}

// Navigation inter-documents
link:../README.adoc[üìö Documentation Hub] |
link:../architecture/service-images.adoc[üèóÔ∏è Service Images Architecture] |
link:../database/BBBV2.sql[üóÑÔ∏è Database Schema]

---

== Vue d'ensemble

Ce document pr√©sente les workflows d√©taill√©s du service images de BlaBlaBook V2, couvrant la gestion hybride **Cloudinary + OpenLibrary** avec optimisation √©co-responsable.

== Workflow 1 : Upload Avatar Utilisateur

[source,mermaid]
----
sequenceDiagram
    participant U as User
    participant F as Frontend
    participant API as Deno/Hono API
    participant C as Cloudinary
    participant DB as PostgreSQL

    U->>F: S√©lectionne image avatar
    F->>F: Validation c√¥t√© client (taille, format)
    F->>API: POST /api/upload/avatar + FormData
    API->>API: Validation serveur
    API->>C: Upload image + transformations
    C-->>API: URL + metadata
    API->>DB: UPDATE users SET avatar_url = cloudinary_url
    API-->>F: Success + avatar_url
    F-->>U: Affichage nouvel avatar
----

**Points cl√©s :**
* ‚úÖ Upload imm√©diat vers Cloudinary (pas temporaire)
* ‚úÖ Transformations automatiques (resize, format WebP)
* ‚úÖ URL Cloudinary stock√©e en DB
* ‚úÖ CDN global imm√©diatement disponible

== Workflow 2A : Ajout Livre Temporaire (OpenLibrary)

[source,mermaid]
----
sequenceDiagram
    participant U as User
    participant F as Frontend
    participant API as Deno/Hono API
    participant OL as OpenLibrary API
    participant DB as PostgreSQL

    U->>F: Recherche livre par ISBN/titre
    F->>API: GET /api/books/search?isbn=xxx
    API->>OL: GET /api/books?bibkeys=ISBN:xxx
    OL-->>API: Book metadata + cover_id
    API->>API: Construct OpenLibrary cover URL (taille L)
    API->>DB: INSERT book (is_temporary=true, image=openlibrary_url)
    API-->>F: Book data + openlibrary_cover_url
    F->>F: Affichage avec CSS resize (500px ‚Üí 256px)
    F-->>U: Livre affich√© avec couverture OpenLibrary
----

**URLs g√©n√©r√©es :**
```typescript
const coverUrl = `https://covers.openlibrary.org/b/id/${cover_id}-L.jpg`
// Exemple: https://covers.openlibrary.org/b/id/8552835-L.jpg
```

== Workflow 2B : Confirmation Livre (Migration vers Cloudinary)

[source,mermaid]
----
sequenceDiagram
    participant U as User
    participant F as Frontend
    participant API as Deno/Hono API
    participant OL as OpenLibrary
    participant C as Cloudinary
    participant DB as PostgreSQL

    U->>F: Confirme ajout livre (bouton "Ajouter")
    F->>API: POST /api/books/:id/confirm
    API->>DB: SELECT book WHERE is_temporary=true
    API->>OL: Fetch image depuis openlibrary_url
    API->>C: Upload image vers Cloudinary
    C-->>API: cloudinary_url optimis√©
    API->>DB: UPDATE book SET is_temporary=false, image=cloudinary_url
    API-->>F: Success + new cloudinary_url
    F->>F: Update src image (OpenLibrary ‚Üí Cloudinary)
    F-->>U: Image optimis√©e via CDN
----

**Optimisations Cloudinary appliqu√©es :**
```typescript
// Transformations automatiques lors de l'upload
cloudinary.uploader.upload(openlibrary_url, {
  folder: "blablabookv2/covers",
  format: "webp",
  quality: "auto",
  transformation: [
    { width: 500, height: 500, crop: "fill" }
  ]
})
```

== Workflow 3 : Cleanup Livres Temporaires (Cron Job)

[source,mermaid]
----
sequenceDiagram
    participant CRON as Cron Job
    participant API as Cleanup Service
    participant DB as PostgreSQL

    CRON->>API: Trigger cleanup (daily 2AM)
    API->>DB: SELECT books WHERE is_temporary=true AND created_at < NOW() - INTERVAL '72 hours'
    DB-->>API: Liste livres expir√©s

    loop Pour chaque livre expir√©
        API->>DB: DELETE book WHERE id = expired_book_id
        Note over API: Pas de nettoyage Cloudinary n√©cessaire<br/>(jamais upload√©)
    end

    API->>API: Log cleanup statistics
----

**Avantage √©co-responsable :** Pas de pollution Cloudinary car pas d'upload pour les temporaires !

== Workflow 4 : Affichage Images Multi-Sources

[source,mermaid]
----
flowchart TD
    A[Client demande image] --> B{Type de livre ?}
    B -->|is_temporary = true| C[Image OpenLibrary]
    B -->|is_temporary = false| D[Image Cloudinary CDN]

    C --> E[CSS Resize<br/>500px ‚Üí 256px]
    D --> E

    E --> F[Affichage uniforme]

    G[Responsive Design] --> H{Taille √©cran ?}
    H -->|Mobile| I[128px]
    H -->|Tablet| J[256px]
    H -->|Desktop| K[400px]

    I --> L[CSS: object-fit: cover]
    J --> L
    K --> L
----

== Workflow 5 : Gestion Erreurs et Fallbacks

[source,mermaid]
----
sequenceDiagram
    participant F as Frontend
    participant API as API
    participant OL as OpenLibrary
    participant C as Cloudinary

    F->>API: Demande image livre

    alt Image Cloudinary (livre confirm√©)
        API-->>F: cloudinary_url
        F->>C: GET image
        alt Cloudinary disponible
            C-->>F: Image optimis√©e
        else Cloudinary en panne
            F->>F: Fallback placeholder
        end
    else Image OpenLibrary (livre temporaire)
        API-->>F: openlibrary_url
        F->>OL: GET image
        alt OpenLibrary disponible
            OL-->>F: Image originale
        else OpenLibrary en panne
            F->>F: Fallback placeholder
        end
    end

    F->>F: CSS resize + object-fit
    F-->>User: Affichage final
----

**Images de fallback :**
```css
.book-cover {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  position: relative;
}

.book-cover::after {
  content: "üìö";
  font-size: 4rem;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
```

== Workflow 6 : Monitoring et M√©triques

[source,mermaid]
----
graph TB
    A[Service Images] --> B[M√©triques Cloudinary]
    A --> C[M√©triques OpenLibrary]
    A --> D[M√©triques Base de Donn√©es]

    B --> B1[Cr√©dits utilis√©s/25]
    B --> B2[Bande passante]
    B --> B3[Transformations]
    B --> B4[Temps de r√©ponse CDN]

    C --> C1[Taux de succ√®s API]
    C --> C2[Images manquantes]
    C --> C3[Temps de r√©ponse]

    D --> D1[Livres temporaires actifs]
    D --> D2[Livres confirm√©s]
    D --> D3[Nettoyages effectu√©s]

    B1 --> E[Dashboard Monitoring]
    B2 --> E
    B3 --> E
    C1 --> E
    D1 --> E
----

== Cas d'Usage Sp√©ciaux

=== Migration en masse (si n√©cessaire)

Si besoin de migrer tous les livres temporaires vers Cloudinary :

[source,typescript]
----
// Script de migration
async function migrateTemporaryBooks() {
  const temporaryBooks = await db.books.findMany({
    where: { is_temporary: true }
  })

  for (const book of temporaryBooks) {
    try {
      // Upload vers Cloudinary
      const result = await cloudinary.uploader.upload(book.image, {
        folder: "blablabookv2/covers"
      })

      // Update DB
      await db.books.update({
        where: { id: book.id },
        data: {
          is_temporary: false,
          image: result.secure_url
        }
      })

    } catch (error) {
      console.error(`Migration failed for book ${book.id}:`, error)
    }
  }
}
----

=== Pr√©-chargement intelligent

Pour am√©liorer l'UX, pr√©-charger les couvertures populaires :

[source,typescript]
----
// Service de pr√©-chargement
async function preloadPopularCovers() {
  const popularBooks = await db.books.findMany({
    where: {
      is_temporary: false,
      // Crit√®res de popularit√© : notes, ajouts r√©cents, etc.
    },
    take: 100
  })

  // Warm up du cache Cloudinary
  popularBooks.forEach(book => {
    // Fetch silencieux pour mise en cache CDN
    fetch(book.image).catch(() => {})
  })
}
----

== Configuration Environnement

=== Variables requises

[source,env]
----
# Cloudinary
CLOUDINARY_CLOUD_NAME=blablabookv2
CLOUDINARY_API_KEY=123456789012345
CLOUDINARY_API_SECRET=AbCdEfGhIjKlMnOpQrStUvWxYz

# OpenLibrary (pas d'auth requise)
OPENLIBRARY_BASE_URL=https://openlibrary.org
OPENLIBRARY_COVERS_URL=https://covers.openlibrary.org

# Upload limits
MAX_AVATAR_SIZE=5MB
ALLOWED_FORMATS=jpeg,jpg,png,webp
----

=== S√©curit√©

[source,typescript]
----
// Validation upload avatar
const uploadValidation = {
  maxSize: 5 * 1024 * 1024, // 5MB
  allowedFormats: ['jpeg', 'jpg', 'png', 'webp'],
  maxDimensions: { width: 2000, height: 2000 }
}

// Rate limiting
const rateLimiter = {
  upload: '5 requests per minute per IP',
  search: '100 requests per minute per IP'
}
----

---

*Document g√©n√©r√© le {date}*

*BlaBlaBook V2 - Service Images Hybride*