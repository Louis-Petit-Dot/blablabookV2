= Diagrammes de SÃ©quence - BlaBlaBook V2 / Sequence Diagrams - BlaBlaBook V2
:toc: left
:toclevels: 3
:sectanchors:
:icons: font
:version: 2.0
:date: {docdate}

// Navigation inter-documents
link:../../README.adoc[ğŸ“š Documentation Hub] |
link:../../project/CONCEPTION-BLABLABOOKV2.adoc[ğŸ—ï¸ Architecture] |
link:../../cdc/technical-architecture.adoc[ğŸ”§ Technical] |
link:../../cdc/api-specifications.adoc[ğŸ›£ï¸ API]

// Navigation langues
<<section-fr,ğŸ‡«ğŸ‡· Version FranÃ§aise>> | <<section-en,ğŸ‡¬ğŸ‡§ğŸ‡ºğŸ‡¸ English Version>>

---

**NOTE IMPORTANTE :** Ces diagrammes sont synchronisÃ©s avec le code backend actuel (Deno 2.0, Hono, Drizzle ORM, PostgreSQL).

[[section-fr]]
== ğŸ‡«ğŸ‡· Diagrammes de SÃ©quence

<<section-en,ğŸ‡¬ğŸ‡§ğŸ‡ºğŸ‡¸ Switch to English>> | ğŸ‡«ğŸ‡· *FranÃ§ais*

=== Rechercher un livre (Hybride : DB + OpenLibrary API)

```mermaid
sequenceDiagram
    participant Utilisateur
    participant Frontend
    participant Backend
    participant BaseDeDonnees
    participant OpenLibrary_API

    Utilisateur->>Frontend: rechercher "science fiction"
    Frontend->>Backend: GET /api/books/search?q=science fiction
    note over Backend: Token JWT optionnel (connectÃ© ou visiteur)

    alt Utilisateur connectÃ©
        Backend->>Backend: Extraire utilisateur du JWT (middleware auth)
        Backend->>BaseDeDonnees: RÃ©cupÃ©rer rÃ´les/permissions (avec cache)
    else Visiteur (non connectÃ©)
        Backend->>Backend: Utilisateur anonyme (accÃ¨s lecture seul)
    end

    %% Phase 1: Recherche dans notre DB
    Backend->>BaseDeDonnees: SELECT * FROM BOOK WHERE title ILIKE '%science fiction%'
    BaseDeDonnees-->>Backend: Livres correspondants avec mÃ©tadonnÃ©es

    alt RÃ©sultats suffisants dans DB (â‰¥ 10 livres)
        Backend->>Backend: Trier par pertinence
        Backend-->>Frontend: RÃ©sultats BDD locale
        Frontend-->>Utilisateur: Afficher livres avec couvertures Cloudinary
    else RÃ©sultats insuffisants (< 10 livres)
        %% Phase 2: ComplÃ©ment avec OpenLibrary API
        Backend->>OpenLibrary_API: GET /search.json?q=science fiction&fields=key,title,author_name,cover_i,isbn,subject
        OpenLibrary_API-->>Backend: RÃ©sultats API (mÃ©tadonnÃ©es brutes)
        note over Backend: Payload rÃ©duit ~70% via limitation champs

        %% Pas de systÃ¨me is_temporary dans version actuelle
        Backend->>Backend: Fusionner rÃ©sultats DB + API
        Backend-->>Frontend: RÃ©sultats hybrides
        Frontend-->>Utilisateur: Livres mixtes (BDD + API)
    end

    note over Frontend: Pas de distinction "CommunautÃ©" vs "Externe" dans version actuelle
```

**DiffÃ©rences avec design initial :**
- âŒ Pas de systÃ¨me `is_temporary` pour import temporaire
- âŒ Pas de nettoyage automatique aprÃ¨s 72h
- âœ… Limitation champs API pour optimisation payload
- âœ… Cache trending books 1h (cacheService)

=== Connexion avec JWT

```mermaid
sequenceDiagram
    participant Utilisateur
    participant Frontend
    participant Backend
    participant DenoKV
    participant BaseDeDonnees

    Utilisateur->>Frontend: saisir identifiants (email, mot de passe)
    Frontend->>Backend: POST /api/users/login {email, password}

    %% Middleware authLockout vÃ©rifie blocage
    Backend->>DenoKV: VÃ©rifier tentatives Ã©chec (authLockout)
    DenoKV-->>Backend: Compte non bloquÃ©

    Backend->>BaseDeDonnees: SELECT * FROM USER WHERE email = ? AND deleted_at IS NULL
    BaseDeDonnees-->>Backend: Utilisateur trouvÃ© (ou non)
    Backend->>Backend: VÃ©rifier mot de passe (bcrypt, pas Argon2)

    alt Identifiants valides
        Backend->>DenoKV: RÃ©initialiser tentatives Ã©chec
        Backend->>BaseDeDonnees: UPDATE USER SET last_login = NOW()
        Backend->>BaseDeDonnees: SELECT rÃ´les via USER_ROLE
        Backend->>BaseDeDonnees: SELECT permissions via ROLE_PERMISSION
        BaseDeDonnees-->>Backend: DonnÃ©es RBAC

        Backend->>Backend: GÃ©nÃ©rer token JWT (un seul, pas refresh)
        Backend->>Backend: DÃ©finir httpOnly cookie
        Backend-->>Frontend: 200 OK + {token, user, roles, permissions} + httpOnly cookie

        Frontend->>Frontend: Stocker user/roles/permissions (pas token)
        Frontend-->>Utilisateur: Rediriger vers dashboard
    else Identifiants invalides
        Backend->>DenoKV: IncrÃ©menter tentatives Ã©chec
        alt 5 tentatives atteintes
            Backend->>DenoKV: Bloquer compte 15 min (lockedUntil)
            Backend-->>Frontend: 429 Too Many Requests
            Frontend-->>Utilisateur: "Account locked. Try again in X minutes"
        else Moins de 5 tentatives
            Backend-->>Frontend: 401 Unauthorized "Invalid email or password"
            Frontend-->>Utilisateur: Message erreur flou (sÃ©curitÃ©)
        end
    end
```

**DiffÃ©rences avec design initial :**
- âŒ Pas de refresh token (un seul JWT)
- âŒ Hash bcrypt, pas Argon2
- âœ… httpOnly cookie pour token (protection XSS)
- âœ… Lockout 15 min aprÃ¨s 5 tentatives (Deno KV)
- âœ… Code HTTP 429 pour lockout
- âœ… Cache rÃ´les/permissions (cacheService)

=== Inscription avec assignation rÃ´le USER

```mermaid
sequenceDiagram
    participant Utilisateur
    participant Frontend
    participant Backend
    participant BaseDeDonnees

    Utilisateur->>Frontend: remplir formulaire (firstname, lastname, username, email, password, passwordConfirm)
    Frontend->>Backend: POST /api/users/register {firstname, lastname, username, email, password, passwordConfirm}

    %% Validation Zod
    Backend->>Backend: Valider donnÃ©es (middleware Zod)
    note over Backend: 8 caractÃ¨res min, 1 maj, 1 min, 1 chiffre, 1 spÃ©cial (@$!%*?&) REQUIS

    Backend->>BaseDeDonnees: SELECT * FROM USER WHERE email = ? OR username = ?
    BaseDeDonnees-->>Backend: VÃ©rification unicitÃ©

    alt Email dÃ©jÃ  utilisÃ©
        Backend-->>Frontend: 409 Conflict "A user with this email already exists"
        Frontend-->>Utilisateur: Rediriger vers connexion
    else Username dÃ©jÃ  pris
        Backend-->>Frontend: 409 Conflict "A user with this username already exists"
        Frontend-->>Utilisateur: Message erreur + suggestions
    else Nouvel utilisateur valide
        Backend->>Backend: Hasher mot de passe (bcrypt)
        Backend->>BaseDeDonnees: BEGIN TRANSACTION

        Backend->>BaseDeDonnees: INSERT INTO USER (firstname, lastname, username, email, password)
        BaseDeDonnees-->>Backend: Utilisateur crÃ©Ã© avec UUID

        Backend->>BaseDeDonnees: SELECT id_role FROM ROLE WHERE role_name = 'USER'
        Backend->>BaseDeDonnees: INSERT INTO USER_ROLE (id_user, id_role)
        note over BaseDeDonnees: RÃ´le USER assignÃ© automatiquement

        Backend->>BaseDeDonnees: COMMIT TRANSACTION

        Backend->>BaseDeDonnees: SELECT rÃ´les et permissions
        Backend->>Backend: GÃ©nÃ©rer token JWT + httpOnly cookie
        Backend-->>Frontend: 201 Created + {token, user, roles, permissions}

        Frontend-->>Utilisateur: Connexion automatique + redirection dashboard
    end
```

**DiffÃ©rences avec design initial :**
- âŒ **PAS** de crÃ©ation automatique bibliothÃ¨que (non implÃ©mentÃ©)
- âœ… RÃ´le USER assignÃ© automatiquement
- âœ… Validation Zod stricte (caractÃ¨re spÃ©cial REQUIS)
- âœ… Connexion automatique aprÃ¨s inscription
- âœ… Username accepte tirets `-` en plus underscore

=== Affichage des dÃ©tails d'un livre

```mermaid
sequenceDiagram
    participant Utilisateur
    participant Frontend
    participant Backend
    participant OpenLibrary_API
    participant BaseDeDonnees

    Utilisateur->>Frontend: Voir dÃ©tails livre (id_book UUID)
    Frontend->>Backend: GET /api/books/{id_book}

    note over Backend: Token JWT optionnel (public/connectÃ©)

    Backend->>BaseDeDonnees: SELECT * FROM BOOK WHERE id_book = ?

    alt Livre trouvÃ© localement
        Backend->>BaseDeDonnees: SELECT auteurs (BOOK_AUTHOR + AUTHOR)
        Backend->>BaseDeDonnees: SELECT genres (BOOK_GENRE + GENRE)
        Backend->>BaseDeDonnees: SELECT avis publics (REVIEW WHERE is_public = true)
        Backend->>BaseDeDonnees: SELECT notes (RATE)
        BaseDeDonnees-->>Backend: DonnÃ©es livre complÃ¨tes

        Backend->>Backend: Calculer moyenne notes
        Backend-->>Frontend: Livre + auteurs + genres + avis + stats

    else Livre non trouvÃ© localement
        Backend-->>Frontend: 404 Not Found "Book not found"
        note over Frontend: Pas de crÃ©ation automatique depuis API\nDans version actuelle
    end

    Frontend-->>Utilisateur: Afficher dÃ©tails livre avec couverture Cloudinary
```

**DiffÃ©rences avec design initial :**
- âŒ Pas de systÃ¨me `is_temporary`
- âŒ Pas de crÃ©ation automatique livre depuis API lors consultation
- âœ… id_book UUID, pas book_code
- âœ… Couvertures servies depuis Cloudinary (WebP optimisÃ©)

=== Ajout d'un livre Ã  la bibliothÃ¨que

```mermaid
sequenceDiagram
    participant Utilisateur
    participant Frontend
    participant Backend
    participant OpenLibrary_API
    participant Cloudinary
    participant BaseDeDonnees

    Utilisateur->>Frontend: Clic "Ajouter Ã  ma bibliothÃ¨que" (depuis recherche OpenLibrary)
    Frontend->>Backend: POST /api/books/openlibrary {openLibraryData: {key, title, author_name, isbn, cover_i, subject}}

    note over Backend: Token JWT requis (middleware auth)
    Backend->>Backend: Extraire utilisateur du JWT

    %% VÃ©rification existence livre
    Backend->>BaseDeDonnees: SELECT * FROM BOOK WHERE openlibrary_key = ? OR isbn = ?

    alt Livre existe dÃ©jÃ 
        BaseDeDonnees-->>Backend: Livre trouvÃ©
        Backend->>Backend: Retourner {book, isNew: false}

    else Livre nouveau
        Backend->>BaseDeDonnees: BEGIN TRANSACTION

        Backend->>BaseDeDonnees: INSERT INTO BOOK (title, isbn, openlibrary_key, publication_year)
        BaseDeDonnees-->>Backend: Livre crÃ©Ã© avec id_book UUID

        %% Upload couverture Cloudinary
        Backend->>OpenLibrary_API: Trouver meilleure couverture franÃ§aise (languageService)
        OpenLibrary_API-->>Backend: cover_id optimal
        Backend->>Cloudinary: Upload URL OpenLibrary â†’ WebP auto:best
        Cloudinary-->>Backend: URL HTTPS Cloudinary
        Backend->>BaseDeDonnees: UPDATE BOOK SET image = ?

        %% CrÃ©er auteurs
        loop Pour chaque auteur
            Backend->>BaseDeDonnees: SELECT * FROM AUTHOR WHERE author_name = ?
            alt Auteur existe
                BaseDeDonnees-->>Backend: id_author existant
            else Nouvel auteur
                Backend->>BaseDeDonnees: INSERT INTO AUTHOR (author_name)
                BaseDeDonnees-->>Backend: id_author nouveau
            end
            Backend->>BaseDeDonnees: INSERT INTO BOOK_AUTHOR (id_book, id_author)
        end

        %% Mapper et crÃ©er genres
        Backend->>Backend: Mapper sujets OpenLibrary â†’ genres (genreMapping)
        note over Backend: 25 catÃ©gories, 160+ variantes, fallback "Divers"
        loop Pour chaque genre mappÃ©
            Backend->>BaseDeDonnees: SELECT * FROM GENRE WHERE genre_name = ?
            alt Genre existe
                BaseDeDonnees-->>Backend: id_genre existant
            else Nouveau genre
                Backend->>BaseDeDonnees: INSERT INTO GENRE (genre_name)
                BaseDeDonnees-->>Backend: id_genre nouveau
            end
            Backend->>BaseDeDonnees: INSERT INTO BOOK_GENRE (id_book, id_genre)
        end

        Backend->>BaseDeDonnees: COMMIT TRANSACTION
        Backend->>Backend: Retourner {book, isNew: true}
    end

    %% Ajout Ã  bibliothÃ¨que utilisateur
    Backend->>BaseDeDonnees: SELECT id_library FROM LIBRARY WHERE id_user = ?
    BaseDeDonnees-->>Backend: id_library utilisateur

    Backend->>BaseDeDonnees: SELECT * FROM BOOK_LIBRARY WHERE id_book = ? AND id_library = ?
    alt DÃ©jÃ  dans bibliothÃ¨que
        Backend-->>Frontend: 409 Conflict "Livre dÃ©jÃ  dans votre bibliothÃ¨que"
    else Pas encore dans bibliothÃ¨que
        Backend->>BaseDeDonnees: INSERT INTO BOOK_LIBRARY (id_book, id_library)
        BaseDeDonnees-->>Backend: Relation crÃ©Ã©e
        Backend-->>Frontend: 201 Created + {book}
    end

    Frontend-->>Utilisateur: Confirmation ajout + proposition ajout Ã  liste
```

**DiffÃ©rences avec design initial :**
- âŒ Pas de champ `is_temporary` sur BOOK
- âœ… VÃ©rification double existence (openlibrary_key + isbn)
- âœ… Upload Cloudinary avec optimisation WebP
- âœ… SÃ©lection couverture franÃ§aise automatique (languageService)
- âœ… Mapping genres intelligent (genreMapping utility)
- âœ… Livre permanent dÃ¨s crÃ©ation

=== Suppression d'un livre de la bibliothÃ¨que

```mermaid
sequenceDiagram
    participant Utilisateur
    participant Frontend
    participant Backend
    participant BaseDeDonnees

    Utilisateur->>Frontend: Supprimer livre de la bibliothÃ¨que
    Frontend->>Backend: DELETE /api/libraries/{id_library}/books/{id_book}

    note over Backend: Token JWT requis
    Backend->>Backend: Extraire utilisateur du JWT

    Backend->>BaseDeDonnees: SELECT * FROM LIBRARY WHERE id_library = ? AND id_user = ? AND deleted_at IS NULL
    BaseDeDonnees-->>Backend: VÃ©rifier propriÃ©tÃ© bibliothÃ¨que

    Backend->>BaseDeDonnees: DELETE FROM BOOK_LIBRARY WHERE id_book = ? AND id_library = ?
    BaseDeDonnees-->>Backend: Relation supprimÃ©e

    Backend-->>Frontend: 200 OK "Book removed from library successfully"
    Frontend-->>Utilisateur: Mettre Ã  jour vue bibliothÃ¨que
```

**DiffÃ©rences avec design initial :**
- âœ… id_library et id_book UUID (pas book_code)
- âœ… VÃ©rification soft delete (deleted_at IS NULL)
- âœ… Pas de permission LIBRARY_DELETE spÃ©cifique (propriÃ©tÃ© suffit)

=== CrÃ©er une Liste de Lecture

```mermaid
sequenceDiagram
    participant Utilisateur
    participant Frontend
    participant Backend
    participant BaseDeDonnees

    Utilisateur->>Frontend: Clic "CrÃ©er nouvelle liste de lecture"
    Utilisateur->>Frontend: Remplir formulaire (list_name, description, is_public)
    Frontend->>Backend: POST /api/reading-lists {list_name, description, id_library, is_public}

    note over Backend: Token JWT requis
    Backend->>Backend: Extraire utilisateur du JWT

    %% Validation propriÃ©tÃ© bibliothÃ¨que
    Backend->>BaseDeDonnees: SELECT * FROM LIBRARY WHERE id_library = ? AND id_user = ? AND deleted_at IS NULL
    BaseDeDonnees-->>Backend: BibliothÃ¨que utilisateur validÃ©e

    %% VÃ©rification unicitÃ© nom dans bibliothÃ¨que
    Backend->>BaseDeDonnees: SELECT * FROM READING_LIST WHERE id_user = ? AND id_library = ? AND list_name = ? AND deleted_at IS NULL

    alt Nom dÃ©jÃ  utilisÃ© dans cette bibliothÃ¨que
        Backend-->>Frontend: 409 Conflict "A reading list with this name already exists in this library"
        Frontend-->>Utilisateur: Message erreur + modifier nom

    else Nom disponible
        Backend->>BaseDeDonnees: INSERT INTO READING_LIST (id_user, id_library, list_name, description, is_public)
        note over BaseDeDonnees: Contrainte unique (id_user, id_library, list_name)
        BaseDeDonnees-->>Backend: Liste crÃ©Ã©e avec id_list UUID

        Backend-->>Frontend: 201 Created + {id_list}
        Frontend-->>Utilisateur: Afficher liste vide + proposer ajout livres
    end
```

**DiffÃ©rences avec design initial :**
- âœ… Contrainte unique (id_user, id_library, list_name)
- âœ… Soft delete (deleted_at)
- âœ… VisibilitÃ© hÃ©rite de la bibliothÃ¨que parente
- âŒ Pas de permission LIST_CREATE spÃ©cifique (propriÃ©tÃ© bibliothÃ¨que suffit)

=== Ajout d'un livre Ã  une Liste de Lecture

```mermaid
sequenceDiagram
    participant Utilisateur
    participant Frontend
    participant Backend
    participant BaseDeDonnees

    Utilisateur->>Frontend: Ajouter livre Ã  liste de lecture existante
    Frontend->>Backend: POST /api/reading-lists/{id_list}/books {id_book}

    note over Backend: Token JWT requis
    Backend->>Backend: Extraire utilisateur du JWT

    %% VÃ©rification propriÃ©tÃ© liste
    Backend->>BaseDeDonnees: SELECT * FROM READING_LIST WHERE id_list = ? AND id_user = ? AND deleted_at IS NULL
    BaseDeDonnees-->>Backend: Liste utilisateur validÃ©e

    %% VÃ©rification existence livre
    Backend->>BaseDeDonnees: SELECT * FROM BOOK WHERE id_book = ?
    BaseDeDonnees-->>Backend: Livre validÃ©

    %% VÃ©rification doublon
    Backend->>BaseDeDonnees: SELECT * FROM READING_LIST_BOOK WHERE id_list = ? AND id_book = ?

    alt Livre dÃ©jÃ  dans liste
        Backend-->>Frontend: 409 Conflict "Book already in this reading list"
        Frontend-->>Utilisateur: Message information

    else Livre pas encore dans liste
        Backend->>BaseDeDonnees: INSERT INTO READING_LIST_BOOK (id_list, id_book)
        note over BaseDeDonnees: Pas de statut lecture/prioritÃ©/notes dans version actuelle
        BaseDeDonnees-->>Backend: Relation crÃ©Ã©e

        Backend-->>Frontend: 201 Created "Book added to reading list successfully"
        Frontend-->>Utilisateur: Livre ajoutÃ© Ã  la liste
    end
```

**DiffÃ©rences avec design initial :**
- âŒ Pas de statut lecture (a_lire, en_cours, lu, abandonnÃ©)
- âŒ Pas de notes personnelles sur livres
- âŒ Pas de prioritÃ© (1-5)
- âœ… Table READING_LIST_BOOK simple (id_list + id_book + created_at)
- âŒ Pas de permission LIST_WRITE spÃ©cifique

=== Ajout d'un avis avec is_public et is_spoiler

```mermaid
sequenceDiagram
    participant Utilisateur
    participant Frontend
    participant Backend
    participant BaseDeDonnees

    Utilisateur->>Frontend: RÃ©diger avis sur livre
    note over Frontend: Checkboxes : â˜ Public (default false), â˜ Spoiler (default false)

    Frontend->>Frontend: Validation cÃ´tÃ© client
    Frontend->>Backend: POST /api/reviews {id_book, title, comment, is_public, is_spoiler}

    note over Backend: Token JWT requis (utilisateur connectÃ©)
    Backend->>Backend: Extraire utilisateur du JWT

    %% VÃ©rification existence livre
    Backend->>BaseDeDonnees: SELECT * FROM BOOK WHERE id_book = ?
    BaseDeDonnees-->>Backend: Livre validÃ©

    %% VÃ©rification unicitÃ© (id_user, id_book)
    Backend->>BaseDeDonnees: SELECT * FROM REVIEW WHERE id_user = ? AND id_book = ?

    alt Avis dÃ©jÃ  existant
        Backend-->>Frontend: 409 Conflict "You have already reviewed this book"
        Frontend-->>Utilisateur: Proposer modifier avis existant

    else Premier avis pour ce livre
        Backend->>BaseDeDonnees: INSERT INTO REVIEW (id_user, id_book, title, comment, is_public, is_spoiler, published_at)
        note over BaseDeDonnees: Contrainte unique (id_user, id_book)\nPas de champs consent_to_publish/consent_date
        BaseDeDonnees-->>Backend: Avis crÃ©Ã© avec id_review UUID

        alt Avis public
            Backend-->>Frontend: 201 Created "Review created successfully" (public)
            Frontend-->>Utilisateur: "Avis publiÃ© publiquement"
        else Avis privÃ©
            Backend-->>Frontend: 201 Created "Review created successfully" (private)
            Frontend-->>Utilisateur: "Avis sauvegardÃ© (privÃ©, visible par vous seul)"
        end
    end
```

**DiffÃ©rences avec design initial :**
- âŒ Pas de champ `published_as` (pseudonyme)
- âŒ Pas de champs `consent_to_publish`, `consent_date`
- âœ… is_public contrÃ´le visibilitÃ© (default false = privÃ©)
- âœ… is_spoiler contrÃ´le masquage contenu (default false)
- âœ… Contrainte unique (id_user, id_book) : un avis par livre
- âœ… CASCADE DELETE user, RESTRICT DELETE book
- âŒ Pas de permission REVIEW_CREATE spÃ©cifique

=== Ajout d'une note Ã  un livre

```mermaid
sequenceDiagram
    participant Utilisateur
    participant Frontend
    participant Backend
    participant BaseDeDonnees

    Utilisateur->>Frontend: Noter un livre (1-5 Ã©toiles)
    Frontend->>Backend: POST /api/rates {id_book, rating}

    note over Backend: Token JWT requis
    Backend->>Backend: Extraire utilisateur du JWT

    Backend->>BaseDeDonnees: SELECT * FROM BOOK WHERE id_book = ?
    BaseDeDonnees-->>Backend: Livre validÃ©

    Backend->>BaseDeDonnees: SELECT * FROM RATE WHERE id_user = ? AND id_book = ?

    alt Utilisateur a dÃ©jÃ  notÃ©
        Backend->>BaseDeDonnees: UPDATE RATE SET rating = ?, updated_at = NOW()
        BaseDeDonnees-->>Backend: Note mise Ã  jour
        Backend-->>Frontend: 200 OK "Rating updated successfully"

    else PremiÃ¨re notation
        Backend->>BaseDeDonnees: INSERT INTO RATE (id_user, id_book, rating)
        note over BaseDeDonnees: Contrainte unique (id_user, id_book)
        BaseDeDonnees-->>Backend: Note crÃ©Ã©e avec id_rate UUID
        Backend-->>Frontend: 201 Created "Rating created successfully"
    end

    Frontend-->>Utilisateur: Afficher confirmation notation
```

**DiffÃ©rences avec design initial :**
- âœ… Table RATE sÃ©parÃ©e de REVIEW
- âœ… Contrainte unique (id_user, id_book)
- âœ… CASCADE DELETE user, RESTRICT DELETE book
- âŒ Pas de permission RATING_CREATE spÃ©cifique
- âŒ Pas de recalcul automatique moyenne sur BOOK

=== Partage de bibliothÃ¨que (visibilitÃ© is_public)

```mermaid
sequenceDiagram
    participant Proprietaire
    participant Frontend
    participant Backend
    participant BaseDeDonnees
    participant AutreUtilisateur

    Proprietaire->>Frontend: Rendre bibliothÃ¨que publique
    Frontend->>Backend: PATCH /api/libraries/{id_library} {is_public: true}

    note over Backend: Token JWT requis
    Backend->>Backend: Extraire propriÃ©taire du JWT

    Backend->>BaseDeDonnees: SELECT * FROM LIBRARY WHERE id_library = ? AND id_user = ? AND deleted_at IS NULL
    BaseDeDonnees-->>Backend: BibliothÃ¨que propriÃ©taire validÃ©e

    Backend->>BaseDeDonnees: UPDATE LIBRARY SET is_public = true, updated_at = NOW()
    BaseDeDonnees-->>Backend: BibliothÃ¨que mise Ã  jour

    Backend-->>Frontend: 200 OK "Library visibility updated"
    Frontend-->>Proprietaire: "BibliothÃ¨que maintenant publique"

    note over AutreUtilisateur: Les utilisateurs peuvent voir bibliothÃ¨ques publiques

    AutreUtilisateur->>Frontend: Consulter bibliothÃ¨ques publiques
    Frontend->>Backend: GET /api/libraries/public

    Backend->>BaseDeDonnees: SELECT * FROM LIBRARY WHERE is_public = true AND deleted_at IS NULL
    BaseDeDonnees-->>Backend: BibliothÃ¨ques publiques

    Backend-->>Frontend: Liste bibliothÃ¨ques publiques
    Frontend-->>AutreUtilisateur: Afficher bibliothÃ¨ques accessibles (lecture seule)
```

**DiffÃ©rences avec design initial :**
- âŒ **PAS** de table LIBRARY_PERMISSION (supprimÃ©e)
- âœ… VisibilitÃ© gÃ©rÃ©e par champ is_public (boolean)
- âœ… BibliothÃ¨ques publiques = lecture seule pour tous
- âœ… BibliothÃ¨ques privÃ©es = propriÃ©taire uniquement
- âŒ Pas de permissions granulaires (read/write/admin)

=== Affichage des avis avec gestion spoiler

```mermaid
sequenceDiagram
    participant Utilisateur
    participant Frontend
    participant Backend
    participant BaseDeDonnees

    Utilisateur->>Frontend: Consulter avis d'un livre
    Frontend->>Backend: GET /api/reviews/book/{id_book}

    note over Backend: Token JWT optionnel (public/connectÃ©)

    alt Utilisateur connectÃ©
        Backend->>Backend: Extraire utilisateur du JWT
        Backend->>BaseDeDonnees: SELECT avis publics + avis utilisateur
        note over BaseDeDonnees: WHERE is_public = true OR id_user = current_user
    else Visiteur
        Backend->>BaseDeDonnees: SELECT avis publics uniquement
        note over BaseDeDonnees: WHERE is_public = true
    end

    BaseDeDonnees-->>Backend: Liste avis avec flags is_spoiler
    Backend->>Backend: Compter avis avec spoilers
    Backend-->>Frontend: {reviews[], spoilerCount}

    Frontend->>Frontend: Rendu avec spoilers masquÃ©s par dÃ©faut (CSS blur)
    note over Frontend: is_spoiler=true â†’ Classe "review-spoiler"

    Frontend-->>Utilisateur: Afficher avis + bouton "RÃ©vÃ©ler spoilers (X)"

    alt Utilisateur clique "RÃ©vÃ©ler spoilers"
        Frontend->>Frontend: Toggle spoilersRevealed = true
        Frontend->>Frontend: Supprimer floutage CSS
        Frontend-->>Utilisateur: Tous avis visibles sans flou
        note over Frontend: Bouton devient "Masquer spoilers"
    else Utilisateur ne rÃ©vÃ¨le pas
        Frontend-->>Utilisateur: Spoilers restent floutÃ©s
        note over Frontend: Protection spoiler respectÃ©e
    end
```

**DiffÃ©rences avec design initial :**
- âœ… is_spoiler flag sur REVIEW
- âœ… Masquage gÃ©rÃ© cÃ´tÃ© frontend (CSS blur)
- âœ… RÃ©vÃ©lation sur demande utilisateur
- âŒ Pas de permission READ_REVIEWS spÃ©cifique
- âœ… Filtrage avis publics/privÃ©s selon authentification

[[section-en]]
== ğŸ‡¬ğŸ‡§ğŸ‡ºğŸ‡¸ Sequence Diagrams

<<section-fr,ğŸ‡«ğŸ‡· Passer en FranÃ§ais>> | ğŸ‡¬ğŸ‡§ğŸ‡ºğŸ‡¸ *English*

=== Search Book (Hybrid: DB + OpenLibrary API)

```mermaid
sequenceDiagram
    participant User
    participant Frontend
    participant Backend
    participant Database
    participant OpenLibrary_API

    User->>Frontend: search "science fiction"
    Frontend->>Backend: GET /api/books/search?q=science fiction
    note over Backend: Optional JWT token (logged in or visitor)

    alt Logged in user
        Backend->>Backend: Extract user from JWT (auth middleware)
        Backend->>Database: Get roles/permissions (with cache)
    else Visitor (not logged in)
        Backend->>Backend: Anonymous user (read-only access)
    end

    %% Phase 1: Search in our DB
    Backend->>Database: SELECT * FROM BOOK WHERE title ILIKE '%science fiction%'
    Database-->>Backend: Matching books with metadata

    alt Sufficient results in DB (â‰¥ 10 books)
        Backend->>Backend: Sort by relevance
        Backend-->>Frontend: Local DB results
        Frontend-->>User: Display books with Cloudinary covers
    else Insufficient results (< 10 books)
        %% Phase 2: Complement with OpenLibrary API
        Backend->>OpenLibrary_API: GET /search.json?q=science fiction&fields=key,title,author_name,cover_i,isbn,subject
        OpenLibrary_API-->>Backend: API results (raw metadata)
        note over Backend: ~70% payload reduction via field limiting

        %% No is_temporary system in current version
        Backend->>Backend: Merge DB + API results
        Backend-->>Frontend: Hybrid results
        Frontend-->>User: Mixed books (DB + API)
    end

    note over Frontend: No "Community" vs "External" distinction in current version
```

**Differences from initial design:**
- âŒ No `is_temporary` system for temporary import
- âŒ No automatic cleanup after 72h
- âœ… Field limiting for API payload optimization
- âœ… Trending books cache 1h (cacheService)

=== Login with JWT

```mermaid
sequenceDiagram
    participant User
    participant Frontend
    participant Backend
    participant DenoKV
    participant Database

    User->>Frontend: enter credentials (email, password)
    Frontend->>Backend: POST /api/users/login {email, password}

    %% authLockout middleware checks for lockout
    Backend->>DenoKV: Check failed attempts (authLockout)
    DenoKV-->>Backend: Account not locked

    Backend->>Database: SELECT * FROM USER WHERE email = ? AND deleted_at IS NULL
    Database-->>Backend: User found (or not)
    Backend->>Backend: Verify password (bcrypt, not Argon2)

    alt Valid credentials
        Backend->>DenoKV: Reset failed attempts
        Backend->>Database: UPDATE USER SET last_login = NOW()
        Backend->>Database: SELECT roles via USER_ROLE
        Backend->>Database: SELECT permissions via ROLE_PERMISSION
        Database-->>Backend: RBAC data

        Backend->>Backend: Generate JWT token (single, no refresh)
        Backend->>Backend: Set httpOnly cookie
        Backend-->>Frontend: 200 OK + {token, user, roles, permissions} + httpOnly cookie

        Frontend->>Frontend: Store user/roles/permissions (not token)
        Frontend-->>User: Redirect to dashboard
    else Invalid credentials
        Backend->>DenoKV: Increment failed attempts
        alt 5 attempts reached
            Backend->>DenoKV: Lock account 15 min (lockedUntil)
            Backend-->>Frontend: 429 Too Many Requests
            Frontend-->>User: "Account locked. Try again in X minutes"
        else Less than 5 attempts
            Backend-->>Frontend: 401 Unauthorized "Invalid email or password"
            Frontend-->>User: Vague error message (security)
        end
    end
```

**Differences from initial design:**
- âŒ No refresh token (single JWT)
- âŒ bcrypt hash, not Argon2
- âœ… httpOnly cookie for token (XSS protection)
- âœ… 15 min lockout after 5 attempts (Deno KV)
- âœ… HTTP 429 for lockout
- âœ… Roles/permissions cache (cacheService)

=== Registration with USER Role Assignment

```mermaid
sequenceDiagram
    participant User
    participant Frontend
    participant Backend
    participant Database

    User->>Frontend: fill form (firstname, lastname, username, email, password, passwordConfirm)
    Frontend->>Backend: POST /api/users/register {firstname, lastname, username, email, password, passwordConfirm}

    %% Zod validation
    Backend->>Backend: Validate data (Zod middleware)
    note over Backend: 8 chars min, 1 upper, 1 lower, 1 digit, 1 special (@$!%*?&) REQUIRED

    Backend->>Database: SELECT * FROM USER WHERE email = ? OR username = ?
    Database-->>Backend: Check uniqueness

    alt Email already used
        Backend-->>Frontend: 409 Conflict "A user with this email already exists"
        Frontend-->>User: Redirect to login
    else Username already taken
        Backend-->>Frontend: 409 Conflict "A user with this username already exists"
        Frontend-->>User: Error message + suggestions
    else Valid new user
        Backend->>Backend: Hash password (bcrypt)
        Backend->>Database: BEGIN TRANSACTION

        Backend->>Database: INSERT INTO USER (firstname, lastname, username, email, password)
        Database-->>Backend: User created with UUID

        Backend->>Database: SELECT id_role FROM ROLE WHERE role_name = 'USER'
        Backend->>Database: INSERT INTO USER_ROLE (id_user, id_role)
        note over Database: USER role assigned automatically

        Backend->>Database: COMMIT TRANSACTION

        Backend->>Database: SELECT roles and permissions
        Backend->>Backend: Generate JWT token + httpOnly cookie
        Backend-->>Frontend: 201 Created + {token, user, roles, permissions}

        Frontend-->>User: Automatic login + redirect to dashboard
    end
```

**Differences from initial design:**
- âŒ **NO** automatic library creation (not implemented)
- âœ… USER role assigned automatically
- âœ… Strict Zod validation (special character REQUIRED)
- âœ… Automatic login after registration
- âœ… Username accepts hyphens `-` in addition to underscore

=== Display Book Details

```mermaid
sequenceDiagram
    participant User
    participant Frontend
    participant Backend
    participant OpenLibrary_API
    participant Database

    User->>Frontend: View book details (id_book UUID)
    Frontend->>Backend: GET /api/books/{id_book}

    note over Backend: Optional JWT token (public/logged in)

    Backend->>Database: SELECT * FROM BOOK WHERE id_book = ?

    alt Book found locally
        Backend->>Database: SELECT authors (BOOK_AUTHOR + AUTHOR)
        Backend->>Database: SELECT genres (BOOK_GENRE + GENRE)
        Backend->>Database: SELECT public reviews (REVIEW WHERE is_public = true)
        Backend->>Database: SELECT ratings (RATE)
        Database-->>Backend: Complete book data

        Backend->>Backend: Calculate average rating
        Backend-->>Frontend: Book + authors + genres + reviews + stats

    else Book not found locally
        Backend-->>Frontend: 404 Not Found "Book not found"
        note over Frontend: No automatic creation from API\nIn current version
    end

    Frontend-->>User: Display book details with Cloudinary cover
```

**Differences from initial design:**
- âŒ No `is_temporary` system
- âŒ No automatic book creation from API on consultation
- âœ… id_book UUID, not book_code
- âœ… Covers served from Cloudinary (optimized WebP)

=== Add Book to Library

```mermaid
sequenceDiagram
    participant User
    participant Frontend
    participant Backend
    participant OpenLibrary_API
    participant Cloudinary
    participant Database

    User->>Frontend: Click "Add to my library" (from OpenLibrary search)
    Frontend->>Backend: POST /api/books/openlibrary {openLibraryData: {key, title, author_name, isbn, cover_i, subject}}

    note over Backend: JWT token required (auth middleware)
    Backend->>Backend: Extract user from JWT

    %% Check book existence
    Backend->>Database: SELECT * FROM BOOK WHERE openlibrary_key = ? OR isbn = ?

    alt Book already exists
        Database-->>Backend: Book found
        Backend->>Backend: Return {book, isNew: false}

    else New book
        Backend->>Database: BEGIN TRANSACTION

        Backend->>Database: INSERT INTO BOOK (title, isbn, openlibrary_key, publication_year)
        Database-->>Backend: Book created with id_book UUID

        %% Upload cover to Cloudinary
        Backend->>OpenLibrary_API: Find best French cover (languageService)
        OpenLibrary_API-->>Backend: Optimal cover_id
        Backend->>Cloudinary: Upload OpenLibrary URL â†’ WebP auto:best
        Cloudinary-->>Backend: HTTPS Cloudinary URL
        Backend->>Database: UPDATE BOOK SET image = ?

        %% Create authors
        loop For each author
            Backend->>Database: SELECT * FROM AUTHOR WHERE author_name = ?
            alt Author exists
                Database-->>Backend: Existing id_author
            else New author
                Backend->>Database: INSERT INTO AUTHOR (author_name)
                Database-->>Backend: New id_author
            end
            Backend->>Database: INSERT INTO BOOK_AUTHOR (id_book, id_author)
        end

        %% Map and create genres
        Backend->>Backend: Map OpenLibrary subjects â†’ genres (genreMapping)
        note over Backend: 25 categories, 160+ variants, "Divers" fallback
        loop For each mapped genre
            Backend->>Database: SELECT * FROM GENRE WHERE genre_name = ?
            alt Genre exists
                Database-->>Backend: Existing id_genre
            else New genre
                Backend->>Database: INSERT INTO GENRE (genre_name)
                Database-->>Backend: New id_genre
            end
            Backend->>Database: INSERT INTO BOOK_GENRE (id_book, id_genre)
        end

        Backend->>Database: COMMIT TRANSACTION
        Backend->>Backend: Return {book, isNew: true}
    end

    %% Add to user library
    Backend->>Database: SELECT id_library FROM LIBRARY WHERE id_user = ?
    Database-->>Backend: User's id_library

    Backend->>Database: SELECT * FROM BOOK_LIBRARY WHERE id_book = ? AND id_library = ?
    alt Already in library
        Backend-->>Frontend: 409 Conflict "Book already in your library"
    else Not yet in library
        Backend->>Database: INSERT INTO BOOK_LIBRARY (id_book, id_library)
        Database-->>Backend: Relation created
        Backend-->>Frontend: 201 Created + {book}
    end

    Frontend-->>User: Confirmation + suggest adding to reading list
```

**Differences from initial design:**
- âŒ No `is_temporary` field on BOOK
- âœ… Double existence check (openlibrary_key + isbn)
- âœ… Cloudinary upload with WebP optimization
- âœ… Automatic French cover selection (languageService)
- âœ… Intelligent genre mapping (genreMapping utility)
- âœ… Permanent book from creation

=== Remove Book from Library

```mermaid
sequenceDiagram
    participant User
    participant Frontend
    participant Backend
    participant Database

    User->>Frontend: Remove book from library
    Frontend->>Backend: DELETE /api/libraries/{id_library}/books/{id_book}

    note over Backend: JWT token required
    Backend->>Backend: Extract user from JWT

    Backend->>Database: SELECT * FROM LIBRARY WHERE id_library = ? AND id_user = ? AND deleted_at IS NULL
    Database-->>Backend: Verify library ownership

    Backend->>Database: DELETE FROM BOOK_LIBRARY WHERE id_book = ? AND id_library = ?
    Database-->>Backend: Relation deleted

    Backend-->>Frontend: 200 OK "Book removed from library successfully"
    Frontend-->>User: Update library view
```

**Differences from initial design:**
- âœ… id_library and id_book UUID (not book_code)
- âœ… Soft delete check (deleted_at IS NULL)
- âœ… No specific LIBRARY_DELETE permission (ownership sufficient)

=== Create Reading List

```mermaid
sequenceDiagram
    participant User
    participant Frontend
    participant Backend
    participant Database

    User->>Frontend: Click "Create new reading list"
    User->>Frontend: Fill form (list_name, description, is_public)
    Frontend->>Backend: POST /api/reading-lists {list_name, description, id_library, is_public}

    note over Backend: JWT token required
    Backend->>Backend: Extract user from JWT

    %% Validate library ownership
    Backend->>Database: SELECT * FROM LIBRARY WHERE id_library = ? AND id_user = ? AND deleted_at IS NULL
    Database-->>Backend: User's library validated

    %% Check name uniqueness within library
    Backend->>Database: SELECT * FROM READING_LIST WHERE id_user = ? AND id_library = ? AND list_name = ? AND deleted_at IS NULL

    alt Name already used in this library
        Backend-->>Frontend: 409 Conflict "A reading list with this name already exists in this library"
        Frontend-->>User: Error message + modify name

    else Name available
        Backend->>Database: INSERT INTO READING_LIST (id_user, id_library, list_name, description, is_public)
        note over Database: Unique constraint (id_user, id_library, list_name)
        Database-->>Backend: List created with id_list UUID

        Backend-->>Frontend: 201 Created + {id_list}
        Frontend-->>User: Display empty list + suggest adding books
    end
```

**Differences from initial design:**
- âœ… Unique constraint (id_user, id_library, list_name)
- âœ… Soft delete (deleted_at)
- âœ… Visibility inherited from parent library
- âŒ No specific LIST_CREATE permission (library ownership sufficient)

=== Add Book to Reading List

```mermaid
sequenceDiagram
    participant User
    participant Frontend
    participant Backend
    participant Database

    User->>Frontend: Add book to existing reading list
    Frontend->>Backend: POST /api/reading-lists/{id_list}/books {id_book}

    note over Backend: JWT token required
    Backend->>Backend: Extract user from JWT

    %% Verify list ownership
    Backend->>Database: SELECT * FROM READING_LIST WHERE id_list = ? AND id_user = ? AND deleted_at IS NULL
    Database-->>Backend: User's list validated

    %% Verify book existence
    Backend->>Database: SELECT * FROM BOOK WHERE id_book = ?
    Database-->>Backend: Book validated

    %% Check for duplicate
    Backend->>Database: SELECT * FROM READING_LIST_BOOK WHERE id_list = ? AND id_book = ?

    alt Book already in list
        Backend-->>Frontend: 409 Conflict "Book already in this reading list"
        Frontend-->>User: Information message

    else Book not yet in list
        Backend->>Database: INSERT INTO READING_LIST_BOOK (id_list, id_book)
        note over Database: No reading status/priority/notes in current version
        Database-->>Backend: Relation created

        Backend-->>Frontend: 201 Created "Book added to reading list successfully"
        Frontend-->>User: Book added to list
    end
```

**Differences from initial design:**
- âŒ No reading status (to_read, reading, read, dnf)
- âŒ No personal notes on books
- âŒ No priority (1-5)
- âœ… Simple READING_LIST_BOOK table (id_list + id_book + created_at)
- âŒ No specific LIST_WRITE permission

=== Add Review with is_public and is_spoiler

```mermaid
sequenceDiagram
    participant User
    participant Frontend
    participant Backend
    participant Database

    User->>Frontend: Write review on book
    note over Frontend: Checkboxes: â˜ Public (default false), â˜ Spoiler (default false)

    Frontend->>Frontend: Client-side validation
    Frontend->>Backend: POST /api/reviews {id_book, title, comment, is_public, is_spoiler}

    note over Backend: JWT token required (logged in user)
    Backend->>Backend: Extract user from JWT

    %% Check book existence
    Backend->>Database: SELECT * FROM BOOK WHERE id_book = ?
    Database-->>Backend: Book validated

    %% Check uniqueness (id_user, id_book)
    Backend->>Database: SELECT * FROM REVIEW WHERE id_user = ? AND id_book = ?

    alt Review already exists
        Backend-->>Frontend: 409 Conflict "You have already reviewed this book"
        Frontend-->>User: Suggest editing existing review

    else First review for this book
        Backend->>Database: INSERT INTO REVIEW (id_user, id_book, title, comment, is_public, is_spoiler, published_at)
        note over Database: Unique constraint (id_user, id_book)\nNo consent_to_publish/consent_date fields
        Database-->>Backend: Review created with id_review UUID

        alt Public review
            Backend-->>Frontend: 201 Created "Review created successfully" (public)
            Frontend-->>User: "Review published publicly"
        else Private review
            Backend-->>Frontend: 201 Created "Review created successfully" (private)
            Frontend-->>User: "Review saved (private, visible to you only)"
        end
    end
```

**Differences from initial design:**
- âŒ No `published_as` field (pseudonym)
- âŒ No `consent_to_publish`, `consent_date` fields
- âœ… is_public controls visibility (default false = private)
- âœ… is_spoiler controls content masking (default false)
- âœ… Unique constraint (id_user, id_book): one review per book
- âœ… CASCADE DELETE user, RESTRICT DELETE book
- âŒ No specific REVIEW_CREATE permission

=== Add Rating to Book

```mermaid
sequenceDiagram
    participant User
    participant Frontend
    participant Backend
    participant Database

    User->>Frontend: Rate book (1-5 stars)
    Frontend->>Backend: POST /api/rates {id_book, rating}

    note over Backend: JWT token required
    Backend->>Backend: Extract user from JWT

    Backend->>Database: SELECT * FROM BOOK WHERE id_book = ?
    Database-->>Backend: Book validated

    Backend->>Database: SELECT * FROM RATE WHERE id_user = ? AND id_book = ?

    alt User already rated
        Backend->>Database: UPDATE RATE SET rating = ?, updated_at = NOW()
        Database-->>Backend: Rating updated
        Backend-->>Frontend: 200 OK "Rating updated successfully"

    else First time rating
        Backend->>Database: INSERT INTO RATE (id_user, id_book, rating)
        note over Database: Unique constraint (id_user, id_book)
        Database-->>Backend: Rating created with id_rate UUID
        Backend-->>Frontend: 201 Created "Rating created successfully"
    end

    Frontend-->>User: Display rating confirmation
```

**Differences from initial design:**
- âœ… Separate RATE table from REVIEW
- âœ… Unique constraint (id_user, id_book)
- âœ… CASCADE DELETE user, RESTRICT DELETE book
- âŒ No specific RATING_CREATE permission
- âŒ No automatic average calculation on BOOK

=== Library Sharing (is_public visibility)

```mermaid
sequenceDiagram
    participant Owner
    participant Frontend
    participant Backend
    participant Database
    participant OtherUser

    Owner->>Frontend: Make library public
    Frontend->>Backend: PATCH /api/libraries/{id_library} {is_public: true}

    note over Backend: JWT token required
    Backend->>Backend: Extract owner from JWT

    Backend->>Database: SELECT * FROM LIBRARY WHERE id_library = ? AND id_user = ? AND deleted_at IS NULL
    Database-->>Backend: Owner's library validated

    Backend->>Database: UPDATE LIBRARY SET is_public = true, updated_at = NOW()
    Database-->>Backend: Library updated

    Backend-->>Frontend: 200 OK "Library visibility updated"
    Frontend-->>Owner: "Library now public"

    note over OtherUser: Users can view public libraries

    OtherUser->>Frontend: View public libraries
    Frontend->>Backend: GET /api/libraries/public

    Backend->>Database: SELECT * FROM LIBRARY WHERE is_public = true AND deleted_at IS NULL
    Database-->>Backend: Public libraries

    Backend-->>Frontend: Public libraries list
    Frontend-->>OtherUser: Display accessible libraries (read-only)
```

**Differences from initial design:**
- âŒ **NO** LIBRARY_PERMISSION table (removed)
- âœ… Visibility managed by is_public field (boolean)
- âœ… Public libraries = read-only for everyone
- âœ… Private libraries = owner only
- âŒ No granular permissions (read/write/admin)

=== Display Reviews with Spoiler Management

```mermaid
sequenceDiagram
    participant User
    participant Frontend
    participant Backend
    participant Database

    User->>Frontend: View book reviews
    Frontend->>Backend: GET /api/reviews/book/{id_book}

    note over Backend: Optional JWT token (public/logged in)

    alt Logged in user
        Backend->>Backend: Extract user from JWT
        Backend->>Database: SELECT public reviews + user reviews
        note over Database: WHERE is_public = true OR id_user = current_user
    else Visitor
        Backend->>Database: SELECT public reviews only
        note over Database: WHERE is_public = true
    end

    Database-->>Backend: Review list with is_spoiler flags
    Backend->>Backend: Count reviews with spoilers
    Backend-->>Frontend: {reviews[], spoilerCount}

    Frontend->>Frontend: Render with spoilers masked by default (CSS blur)
    note over Frontend: is_spoiler=true â†’ "review-spoiler" class

    Frontend-->>User: Display reviews + "Reveal spoilers (X)" button

    alt User clicks "Reveal spoilers"
        Frontend->>Frontend: Toggle spoilersRevealed = true
        Frontend->>Frontend: Remove CSS blur
        Frontend-->>User: All reviews visible without blur
        note over Frontend: Button becomes "Hide spoilers"
    else User doesn't reveal
        Frontend-->>User: Spoilers remain blurred
        note over Frontend: Spoiler protection respected
    end
```

**Differences from initial design:**
- âœ… is_spoiler flag on REVIEW
- âœ… Masking handled frontend-side (CSS blur)
- âœ… Reveal on user request
- âŒ No specific READ_REVIEWS permission
- âœ… Public/private review filtering based on authentication

== Notes de synchronisation / Synchronization Notes

**FR :** Ces diagrammes sont synchronisÃ©s avec le code backend actuel (userController, userService, authLockout, bookService, reviewService, etc.). Les diffÃ©rences avec le design initial sont documentÃ©es pour chaque diagramme.

**EN :** These diagrams are synchronized with the current backend code (userController, userService, authLockout, bookService, reviewService, etc.). Differences from the initial design are documented for each diagram.

**Architecture actuelle / Current Architecture :**
- Backend: Deno 2.0 + Hono framework
- ORM: Drizzle ORM
- Database: PostgreSQL
- Auth: JWT + httpOnly cookies + bcrypt
- Lockout: Deno KV (15 min aprÃ¨s 5 tentatives)
- Cache: Deno KV pour roles/permissions/trending
- Images: Cloudinary CDN (WebP auto:best)
- API externe: OpenLibrary (avec limitation champs)
