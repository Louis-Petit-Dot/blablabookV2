= Architecture S√©curit√© BlaBlaBook V2 - Guide Complet
:toc: left
:toclevels: 4
:sectanchors:
:source-highlighter: highlight.js
:icons: font
:version: 2.0
:date: {docdate}

// Navigation inter-documents
link:../project/CONCEPTION-BLABLABOOKV2.adoc[üìã Conception] |
link:../cdc/technical-architecture.adoc[üèóÔ∏è Architecture] |
link:../diagrams/activity/authentification-workflow.adoc[üîê Auth Workflow]

---

== üõ°Ô∏è Vue d'ensemble s√©curitaire

=== Philosophie "Security by Design"

**S√©curit√© int√©gr√©e d√®s la conception, pas ajout√©e apr√®s.**

[NOTE]
====
**Principe fondamental :** Chaque fonctionnalit√© est pens√©e avec la s√©curit√© en premier.
Pas de compromis sur la s√©curit√© pour gagner du temps ou simplifier le code.
====

=== Triple Protection

[cols="1,2,3"]
|===
|Couche |Approche |Explication simple

|**üèóÔ∏è Security by Design**
|S√©curit√© native
|Comme construire une maison avec des fondations solides plut√¥t que d'ajouter des barreaux aux fen√™tres apr√®s

|**üîí Zero Trust**
|"Ne jamais faire confiance"
|Comme un vigile qui v√©rifie CHAQUE personne, m√™me celles qu'il conna√Æt

|**üõ°Ô∏è OWASP Top 10**
|Standards industrie
|Comme suivre un manuel des 10 erreurs de s√©curit√© les plus dangereuses
|===

== üîí Zero Trust Architecture

=== Le principe expliqu√© simplement

**Analogie du ch√¢teau fort :**

[cols="2,3"]
|===
|**‚ùå S√©curit√© traditionnelle** |**‚úÖ Zero Trust**

|Une fois dans le ch√¢teau, on peut tout faire
|Chaque porte du ch√¢teau demande √† nouveau qui vous √™tes

|Si quelqu'un vole vos cl√©s, il a acc√®s √† tout
|M√™me avec des cl√©s vol√©es, chaque porte v√©rifie qui vous √™tes
|===

=== Impl√©mentation Zero Trust BlaBlaBook V2

[source,typescript]
----
// Chaque requ√™te = nouvelle v√©rification
const zeroTrustFlow = {
  1: "Utilisateur fait une action",
  2: "V√©rifier le JWT token (qui √™tes-vous ?)",
  3: "V√©rifier les permissions (que pouvez-vous faire ?)",
  4: "V√©rifier le device (√™tes-vous sur le bon appareil ?)",
  5: "V√©rifier l'IP (√™tes-vous au bon endroit ?)",
  6: "Si tout OK ‚Üí autoriser l'action",
  7: "Sinon ‚Üí bloquer et alerter"
};
----

[IMPORTANT]
====
**Refresh token = 24h maximum** (pas 7 jours)

Pourquoi ? Si quelqu'un vole votre token, il ne peut l'utiliser que 24h au lieu d'une semaine.
====

=== Device Fingerprinting (Empreinte d'appareil)

**Qu'est-ce que c'est ?**
Cr√©er une "carte d'identit√©" unique de votre navigateur/ordinateur.

**Comment √ßa marche :**

[source,typescript]
----
// √âl√©ments collect√©s pour cr√©er l'empreinte
const deviceFingerprint = {
  navigateur: "Chrome 120.0",
  systeme: "Windows 11",
  resolution: "1920x1080",
  timezone: "Europe/Paris",
  langue: "fr-FR"
};

// Transform√© en hash unique
const fingerprint = "sha256_abc123def456"; // Impossible √† deviner
----

**Pourquoi c'est utile :**
Si quelqu'un vole votre session mais utilise un autre ordinateur, on le d√©tecte imm√©diatement.

== üõ°Ô∏è OWASP Top 10 - Protection compl√®te

=== A01: Broken Access Control (Contr√¥le d'acc√®s cass√©)

**‚ùå Le probl√®me :** Un utilisateur normal peut acc√©der aux fonctions admin.

**‚úÖ Notre solution :**

[source,typescript]
----
// Middleware de v√©rification des permissions
const checkPermission = (requiredPermission: string) => {
  return async (c: Context, next: Next) => {
    const user = c.get("user");

    // V√©rifier si l'utilisateur a la permission
    if (!user.permissions.includes(requiredPermission)) {
      return c.json({ error: "Acc√®s interdit" }, 403);
    }

    await next();
  };
};

// Usage sur une route admin
app.delete("/api/books/:id",
  checkPermission("delete_any_book"), // Seuls les admins ont √ßa
  deleteBookHandler
);
----

**En mots simples :** Comme avoir diff√©rentes cl√©s pour diff√©rentes pi√®ces. La cl√© de votre chambre n'ouvre pas le coffre-fort.

=== A02: Cryptographic Failures (√âchecs cryptographiques)

**‚ùå Le probl√®me :** Mots de passe stock√©s en clair, donn√©es sensibles non chiffr√©es.

**‚úÖ Notre solution :**

[source,typescript]
----
import { hash, verify } from "https://deno.land/x/scrypt@v4.3.4/mod.ts";

// Hachage s√©curis√© des mots de passe
const hashPassword = async (password: string): Promise<string> => {
  // Scrypt est plus s√©curis√© que bcrypt pour Deno
  return await hash(password);
};

// V√©rification
const verifyPassword = async (password: string, hashed: string): Promise<boolean> => {
  return await verify(password, hashed);
};

// HTTPS obligatoire en production
const secureHeaders = {
  "Strict-Transport-Security": "max-age=31536000; includeSubDomains",
  "Content-Security-Policy": "default-src 'self'"
};
----

**En mots simples :** Au lieu de noter votre mot de passe sur un papier, on le transforme en code secret que m√™me nous ne pouvons pas lire.

=== A03: Injection (Injection SQL)

**‚ùå Le probl√®me :** Un attaquant peut ex√©cuter du code malveillant via les formulaires.

**‚úÖ Notre solution : Drizzle ORM**

[source,typescript]
----
// ‚ùå DANGEREUX - Injection SQL possible
const badQuery = `SELECT * FROM users WHERE email = '${userInput}'`;

// ‚úÖ S√âCURIS√â - Drizzle prot√®ge automatiquement
const safeQuery = await db.select()
  .from(users)
  .where(eq(users.email, userInput)); // Drizzle √©chappe automatiquement

// ‚úÖ S√âCURIS√â - Validation en amont avec Zod
const userSchema = z.object({
  email: z.string().email().max(255),
  password: z.string().min(8).max(100)
});

// Si les donn√©es ne respectent pas le sch√©ma ‚Üí rejet automatique
const validatedData = userSchema.parse(userInput);
----

**En mots simples :** Au lieu de recopier b√™tement ce que dit l'utilisateur, on v√©rifie que c'est bien ce qu'on attend.

=== A04: Insecure Design (Conception non s√©curis√©e)

**‚ùå Le probl√®me :** L'application n'a pas √©t√© pens√©e pour √™tre s√©curis√©e.

**‚úÖ Notre solution : Security by Design**

[source,typescript]
----
// Exemple : Partage de biblioth√®que
const shareLibrarySecure = async (libraryId: string, targetUserId: string) => {
  // 1. V√©rifier que l'utilisateur poss√®de la biblioth√®que
  const library = await getLibraryWithOwnershipCheck(libraryId, currentUserId);

  // 2. V√©rifier que l'utilisateur cible existe
  const targetUser = await getUserById(targetUserId);
  if (!targetUser) throw new Error("Utilisateur inexistant");

  // 3. V√©rifier qu'il n'y a pas d√©j√† un partage
  const existingShare = await getLibraryPermission(libraryId, targetUserId);
  if (existingShare) throw new Error("D√©j√† partag√©");

  // 4. Cr√©er le partage avec permission limit√©e par d√©faut
  await createLibraryPermission({
    libraryId,
    userId: targetUserId,
    permission: "read", // Jamais "admin" par d√©faut
    grantedAt: new Date()
  });

  // 5. Logger l'action pour audit
  await logSecurityEvent("LIBRARY_SHARED", {
    owner: currentUserId,
    target: targetUserId,
    library: libraryId
  });
};
----

**En mots simples :** Penser √† tous les cas de figure malveillants avant de coder, pas apr√®s avoir √©t√© hack√©.

=== A05: Security Misconfiguration (Mauvaise configuration)

**‚úÖ Notre solution : Configuration s√©curis√©e par d√©faut**

[source,typescript]
----
import helmet from "npm:helmet@7.1.0";

// Headers de s√©curit√© automatiques
app.use("*", helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"], // Pour le CSS
      scriptSrc: ["'self'"], // Pas de JavaScript externe
      imgSrc: ["'self'", "data:", "https://covers.openlibrary.org"], // Images OpenLibrary OK
    }
  },
  hsts: {
    maxAge: 31536000, // 1 an
    includeSubDomains: true
  }
}));

// CORS restrictif
const corsConfig = {
  origin: ["https://blablabook.fr", "https://www.blablabook.fr"], // Seulement nos domaines
  methods: ["GET", "POST", "PUT", "DELETE"],
  allowedHeaders: ["Content-Type", "Authorization"],
  credentials: true // Pour les cookies refresh token
};
----

**En mots simples :** Configurer l'application comme un bunker, pas comme une maison avec la porte ouverte.

=== A06: Vulnerable Components (Composants vuln√©rables)

**‚úÖ Notre solution : Deno + Audit automatique**

[source,typescript]
----
// deno.json - Versions explicites et r√©centes
{
  "imports": {
    "hono": "https://deno.land/x/hono@v3.12.8/mod.ts", // Version sp√©cifique
    "drizzle-orm": "npm:drizzle-orm@^0.29.0", // Version r√©cente
    "helmet": "npm:helmet@^7.1.0" // Headers s√©curis√©s
  }
}

// Audit automatique dans CI/CD
// deno task audit
"audit": "deno cache --reload src/main.ts && deno info --json src/main.ts"
----

**En mots simples :** Utiliser des biblioth√®ques r√©centes et fiables, comme utiliser des serrures modernes plut√¥t que des cadenas rouill√©s.

=== A07: Authentication Failures (√âchecs d'authentification)

**‚úÖ Notre solution : JWT + Rate Limiting + Zero Trust**

[source,typescript]
----
// Rate limiting sur les connexions
const loginRateLimit = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 tentatives max
  message: "Trop de tentatives de connexion. R√©essayez dans 15 minutes.",
  standardHeaders: true
});

// Protection force brute
const loginAttempts = new Map<string, { count: number, lastAttempt: Date }>();

const trackLoginAttempt = (email: string, success: boolean) => {
  if (success) {
    loginAttempts.delete(email); // Reset si succ√®s
    return;
  }

  const attempts = loginAttempts.get(email) || { count: 0, lastAttempt: new Date() };
  attempts.count++;
  attempts.lastAttempt = new Date();

  if (attempts.count >= 5) {
    // Bloquer pendant 30 minutes apr√®s 5 √©checs
    const blockUntil = new Date(attempts.lastAttempt.getTime() + 30 * 60 * 1000);
    throw new Error(`Compte temporairement bloqu√© jusqu'√† ${blockUntil}`);
  }

  loginAttempts.set(email, attempts);
};
----

**En mots simples :** Si quelqu'un essaie de deviner votre mot de passe, on le bloque automatiquement apr√®s quelques tentatives.

=== A08: Software Integrity Failures (√âchecs d'int√©grit√© logicielle)

**‚úÖ Notre solution : Deno + Verification d'int√©grit√©**

[source,typescript]
----
// deno.lock - Verrouillage des versions
{
  "https://deno.land/x/hono@v3.12.8/mod.ts": "abc123...", // Checksum de s√©curit√©
}

// V√©rification des imports en CI/CD
// Si le checksum change = potentielle compromission
"verify": "deno cache --lock=deno.lock --lock-write src/main.ts"

// Variables d'environnement s√©curis√©es
const requiredEnvVars = ["JWT_SECRET", "DB_PASSWORD"];
requiredEnvVars.forEach(envVar => {
  if (!Deno.env.get(envVar)) {
    console.error(`‚ùå Variable d'environnement manquante: ${envVar}`);
    Deno.exit(1);
  }
});
----

**En mots simples :** V√©rifier que personne n'a trafiqu√© le code qu'on t√©l√©charge, comme v√©rifier les sceaux de s√©curit√© sur les m√©dicaments.

=== A09: Security Logging Failures (√âchecs de journalisation)

**‚úÖ Notre solution : Audit complet des actions sensibles**

[source,typescript]
----
interface SecurityEvent {
  type: "LOGIN" | "FAILED_LOGIN" | "PERMISSION_CHANGE" | "DATA_ACCESS" | "SUSPICIOUS_ACTIVITY";
  userId?: string;
  ip: string;
  userAgent: string;
  timestamp: Date;
  details: Record<string, any>;
  severity: "LOW" | "MEDIUM" | "HIGH" | "CRITICAL";
}

const logSecurityEvent = async (event: SecurityEvent) => {
  // Log local pour debug
  console.log(`üîê [${event.severity}] ${event.type}`, event);

  // Stockage BDD pour audit
  await db.insert(securityLogs).values({
    type: event.type,
    userId: event.userId,
    ip: event.ip,
    userAgent: event.userAgent,
    details: event.details,
    severity: event.severity,
    timestamp: event.timestamp
  });

  // Alerte imm√©diate si critique
  if (event.severity === "CRITICAL") {
    await sendSecurityAlert(event);
  }
};

// Usage dans l'authentification
await logSecurityEvent({
  type: "FAILED_LOGIN",
  ip: clientIP,
  userAgent: req.headers["user-agent"],
  timestamp: new Date(),
  details: { email, reason: "Invalid password" },
  severity: "MEDIUM"
});
----

**En mots simples :** Noter tout ce qui se passe de suspect, comme un syst√®me de vid√©osurveillance pour le code.

=== A10: Server-Side Request Forgery (SSRF)

**‚úÖ Notre solution : Validation stricte des URLs externes**

[source,typescript]
----
// Seules les URLs OpenLibrary autoris√©es
const allowedDomains = [
  "openlibrary.org",
  "covers.openlibrary.org"
];

const validateExternalUrl = (url: string): boolean => {
  try {
    const urlObj = new URL(url);

    // Bloquer les IPs priv√©es (127.0.0.1, 192.168.x.x, etc.)
    if (isPrivateIP(urlObj.hostname)) {
      throw new Error("IP priv√©e interdite");
    }

    // Seuls les domaines autoris√©s
    if (!allowedDomains.includes(urlObj.hostname)) {
      throw new Error("Domaine non autoris√©");
    }

    // Seulement HTTPS
    if (urlObj.protocol !== "https:") {
      throw new Error("HTTPS obligatoire");
    }

    return true;
  } catch {
    return false;
  }
};

// Usage pour r√©cup√©rer des couvertures de livres
const fetchBookCover = async (coverUrl: string) => {
  if (!validateExternalUrl(coverUrl)) {
    throw new Error("URL de couverture invalide");
  }

  return await fetch(coverUrl, {
    method: "GET",
    timeout: 5000 // 5 secondes max
  });
};
----

**En mots simples :** Ne faire confiance qu'aux sites web qu'on conna√Æt, comme ne donner son num√©ro de t√©l√©phone qu'aux amis.

== üîß Stack S√©curitaire Technique

=== Technologies et leur r√¥le

[cols="2,2,4"]
|===
|Technologie |R√¥le s√©curitaire |Explication simple

|**ü¶ï Deno Runtime**
|Permissions explicites
|Contrairement √† Node.js, Deno ne peut rien faire sans permission explicite

|**üõ°Ô∏è Helmet**
|Headers s√©curis√©s
|Ajoute automatiquement les protections navigateur (XSS, clickjacking...)

|**üåê CORS**
|Filtrage domaines
|Seuls nos sites web peuvent utiliser notre API

|**‚è±Ô∏è Rate Limiter**
|Protection force brute
|Limite le nombre de requ√™tes par minute/heure

|**‚úÖ Drizzle ORM**
|Anti-injection SQL
|Impossible d'injecter du code malveillant via les formulaires

|**üîê JWT Stateless**
|Sessions s√©curis√©es
|Pas de stockage serveur = impossible √† compromettre c√¥t√© serveur

|**üéØ Validateur Deno/Zod**
|Validation donn√©es
|Rejette automatiquement les donn√©es malform√©es

|**üîí CSRF Protection**
|Anti-attaque crois√©e
|Emp√™che les sites malveillants d'utiliser votre session
|===

=== Configuration Helmet compl√®te

[source,typescript]
----
// Protection maximum avec Helmet
app.use("*", helmet({
  // Emp√™che l'injection de code JavaScript malveillant
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"], // Seul notre domaine
      styleSrc: ["'self'", "'unsafe-inline'"], // CSS autoris√©
      scriptSrc: ["'self'"], // Pas de JS externe
      objectSrc: ["'none'"], // Pas de Flash/plugins
      upgradeInsecureRequests: [], // Force HTTPS
    }
  },

  // Force HTTPS pendant 1 an
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  },

  // Emp√™che l'int√©gration dans une iframe (clickjacking)
  frameguard: { action: 'deny' },

  // Emp√™che la d√©tection du type de fichier (XSS)
  noSniff: true,

  // Active la protection XSS du navigateur
  xssFilter: true,

  // Cache les informations serveur
  hidePoweredBy: true,

  // Contr√¥le les r√©f√©rents
  referrerPolicy: { policy: "strict-origin-when-cross-origin" }
}));
----

=== Rate Limiting adaptatif

[source,typescript]
----
// Rate limits diff√©renci√©s par endpoint
const rateLimits = {
  // Connexion : tr√®s restrictif
  login: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 5, // 5 tentatives
    message: "Trop de tentatives de connexion"
  },

  // Inscription : restrictif
  register: {
    windowMs: 60 * 60 * 1000, // 1 heure
    max: 3, // 3 inscriptions max par heure
    message: "Trop d'inscriptions"
  },

  // API lecture : permissif
  api: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 1000, // 1000 requ√™tes
    message: "Limite API d√©pass√©e"
  },

  // API √©criture : mod√©r√©
  apiWrite: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // 100 modifications
    message: "Trop de modifications"
  }
};
----

=== CSRF Protection

[source,typescript]
----
// Protection CSRF pour les actions sensibles
const csrfProtection = async (c: Context, next: Next) => {
  const method = c.req.method;

  // CSRF n√©cessaire pour modifications
  if (["POST", "PUT", "DELETE", "PATCH"].includes(method)) {
    const csrfToken = c.req.header("X-CSRF-Token");
    const sessionCSRF = c.get("user")?.csrfToken;

    if (!csrfToken || csrfToken !== sessionCSRF) {
      return c.json({ error: "Token CSRF manquant ou invalide" }, 403);
    }
  }

  await next();
};

// G√©n√©ration token CSRF dans JWT
const generateCSRFToken = (): string => {
  return crypto.randomUUID(); // Token al√©atoire unique
};
----

== üìä Monitoring et Alertes S√©curit√©

=== Dashboard S√©curit√© Temps R√©el

[source,typescript]
----
// M√©triques s√©curit√© √† surveiller
const securityMetrics = {
  // Tentatives de connexion √©chou√©es par heure
  failedLogins: await getFailedLoginsLastHour(),

  // Changements d'IP suspects
  suspiciousIPs: await getSuspiciousIPChanges(),

  // Tentatives d'acc√®s non autoris√©es
  unauthorizedAccess: await getUnauthorizedAttempts(),

  // Utilisations de tokens expir√©s
  expiredTokenUse: await getExpiredTokenAttempts(),

  // Vitesse anormale de requ√™tes
  rateLimitViolations: await getRateLimitViolations()
};

// Seuils d'alerte
const alertThresholds = {
  failedLogins: 20, // 20 √©checs/heure = alerte
  suspiciousIPs: 5, // 5 changements IP/jour = suspect
  unauthorizedAccess: 10, // 10 tentatives = alerte imm√©diate
  expiredTokenUse: 50, // 50 tokens expir√©s = possible attaque
  rateLimitViolations: 100 // 100 violations = attaque probable
};
----

=== R√©ponse Automatique aux Incidents

[source,typescript]
----
// Actions automatiques selon le niveau de menace
const securityResponse = async (threat: SecurityThreat) => {
  switch (threat.severity) {
    case "LOW":
      // Log seulement
      await logSecurityEvent(threat);
      break;

    case "MEDIUM":
      // Log + notification admin
      await logSecurityEvent(threat);
      await notifySecurityTeam(threat);
      break;

    case "HIGH":
      // Bloquer IP temporairement
      await blockIPTemporary(threat.ip, "30 minutes");
      await alertSecurityTeam(threat);
      break;

    case "CRITICAL":
      // Bloquer IP + r√©voquer tous tokens utilisateur
      await blockIPPermanent(threat.ip);
      if (threat.userId) {
        await revokeAllUserTokens(threat.userId);
      }
      await emergencyAlert(threat);
      break;
  }
};
----

== üìã Checklist S√©curit√© D√©ploiement

=== Avant chaque d√©ploiement

- [ ] **Audit d√©pendances** : `deno task audit`
- [ ] **Tests s√©curit√©** : Tous les tests de s√©curit√© passent
- [ ] **Variables env** : Toutes les variables s√©curis√©es d√©finies
- [ ] **HTTPS** : Certificat SSL valide et configur√©
- [ ] **Headers** : Helmet configur√© avec tous les headers
- [ ] **Rate limits** : Configur√©s selon les environnements
- [ ] **JWT secrets** : Secrets forts et uniques par environnement
- [ ] **CORS** : Domaines autoris√©s corrects
- [ ] **Logs** : Syst√®me de log et alertes fonctionnel

=== Monitoring continu

- [ ] **Dashboards** : M√©triques s√©curit√© temps r√©el
- [ ] **Alertes** : Notifications automatiques configur√©es
- [ ] **Sauvegardes** : Logs s√©curit√© sauvegard√©s
- [ ] **R√©vision** : Audit s√©curit√© mensuel planifi√©

== üéì Formation √âquipe

=== Bonnes pratiques d√©veloppement

**Pour les d√©veloppeurs qui rejoignent l'√©quipe :**

1. **üîê Authentification** : Toujours v√©rifier les permissions avant les actions
2. **üíâ Injection** : Utiliser exclusivement Drizzle, jamais de SQL brut
3. **üîç Validation** : Valider TOUTES les donn√©es utilisateur avec Zod
4. **üìù Logs** : Logger toutes les actions sensibles
5. **üîí Secrets** : Jamais de mots de passe/cl√©s dans le code
6. **‚ö° Rate limits** : Penser aux limites sur les nouveaux endpoints
7. **üõ°Ô∏è Headers** : V√©rifier que Helmet couvre les nouveaux endpoints
8. **üéØ CORS** : Ne pas d√©sactiver CORS "pour que √ßa marche"

=== Code Review S√©curit√©

**Questions √† poser syst√©matiquement :**

- Cette fonction v√©rifie-t-elle les permissions ?
- Les donn√©es utilisateur sont-elles valid√©es ?
- Y a-t-il des secrets/mots de passe dans le code ?
- Cette action est-elle logg√©e pour l'audit ?
- Le rate limiting est-il appropri√© ?
- L'erreur r√©v√®le-t-elle des infos sensibles ?

---

**BlaBlaBook V2 - Architecture S√©curit√© Compl√®te**
**Stack s√©curis√©e : Deno + Zero Trust + OWASP Top 10 + Security by Design**