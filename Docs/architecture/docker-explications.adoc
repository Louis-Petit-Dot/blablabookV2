= Docker Explications - BlaBlaBook V2
:toc: left
:toclevels: 3
:sectanchors:
:icons: font

== ğŸ³ Vue d'ensemble

Ce document explique en dÃ©tail les Dockerfiles du projet BlaBlaBook V2 :

* **Backend Deno** : 1 stage (simple et efficace)
* **Frontend Next.js** : 1 stage (dev) + 2 stages (prod, optimisÃ©)

== ğŸ“¦ Architecture Dockerfiles

[cols="2,2,2,3"]
|===
|Service |Fichier |Stages |Usage

|**Backend Dev**
|`backend/Dockerfile.dev`
|1 stage
|DÃ©veloppement avec watch mode

|**Backend Prod**
|`backend/Dockerfile.prod`
|1 stage
|Production optimisÃ©

|**Frontend Dev**
|`frontend/Dockerfile.dev`
|1 stage
|DÃ©veloppement avec hot reload

|**Frontend Prod**
|`frontend/Dockerfile.prod`
|2 stages
|Production ultra-optimisÃ©
|===

== ğŸ¦• Backend Deno : 1 Stage Suffit

=== Pourquoi 1 seul stage ?

**Deno n'a pas besoin de multi-stage car :**

* âœ… Pas de `node_modules/` (dÃ©pendances cachÃ©es dans l'image)
* âœ… ExÃ©cute TypeScript directement (pas de build complexe)
* âœ… Code source nÃ©cessaire en runtime
* âœ… Image dÃ©jÃ  lÃ©gÃ¨re (~150 MB)

**Gain multi-stage :** ~20-30 MB (faible)

**DÃ©cision :** SimplicitÃ© > Optimisation excessive

=== Dockerfile.prod Backend ExpliquÃ©

==== Ligne 1 : Image de base

[source,dockerfile]
----
FROM denoland/deno:alpine
----

**Explication :**

* `FROM` : Directive Docker pour spÃ©cifier l'image de base
* `denoland/deno` : Image officielle Deno
* `alpine` : Distribution Linux minimaliste (~5 MB vs ~100 MB Debian)

**Pourquoi Alpine ?**

* âœ… Image lÃ©gÃ¨re (moins de packages = moins de vulnÃ©rabilitÃ©s)
* âœ… Startup rapide
* âš ï¸ Peut avoir des vulnÃ©rabilitÃ©s (OpenSSL, etc.)

==== Lignes 3-6 : Fix vulnÃ©rabilitÃ©s Alpine

[source,dockerfile]
----
RUN apk update && \
    apk upgrade --no-cache && \
    apk add --no-cache libstdc++ libgcc && \
    rm -rf /var/cache/apk/*
----

**Explication mot par mot :**

* `RUN` : ExÃ©cute une commande dans le conteneur pendant le build
* `apk` : **Alpine Package Keeper** (gestionnaire de packages Alpine, Ã©quivalent `apt` Ubuntu)
* `update` : Met Ã  jour l'index des packages disponibles
* `upgrade` : Met Ã  jour les packages installÃ©s vers derniÃ¨res versions (fix CVE OpenSSL)
* `--no-cache` : Ne garde pas le cache tÃ©lÃ©chargÃ© (image plus lÃ©gÃ¨re)
* `add` : Installe de nouveaux packages
* `libstdc++` : Librairie C++ standard (nÃ©cessaire pour argon2 - hash passwords)
* `libgcc` : Librairie GCC (compilateur C, dÃ©pendance argon2)
* `rm -rf /var/cache/apk/*` : Supprime le cache APK (Ã©conomise ~10-20 MB)

**Pourquoi `&&` et `\` ?**

* `&&` : EnchaÃ®ne les commandes (si une Ã©choue, tout s'arrÃªte)
* `\` : Retour Ã  la ligne (lisibilitÃ©)

**Alternative (sans `&&`) :**
[source,dockerfile]
----
RUN apk update
RUN apk upgrade --no-cache
RUN apk add --no-cache libstdc++ libgcc
RUN rm -rf /var/cache/apk/*
----

**ProblÃ¨me :** CrÃ©e 4 layers Docker au lieu d'1 â†’ Image plus grosse

**RÃ¨gle :** Grouper les commandes liÃ©es avec `&&`

==== Lignes 8-10 : User non-root (sÃ©curitÃ©)

[source,dockerfile]
----
RUN addgroup --system --gid 1001 denouser && \
    adduser --system --uid 1001 denouser
----

**Explication :**

* `addgroup` : CrÃ©e un groupe systÃ¨me Linux
* `--system` : Groupe systÃ¨me (pas un user humain)
* `--gid 1001` : **Group ID** = identifiant unique du groupe (1001 arbitraire, > 1000 = users)
* `denouser` : Nom du groupe
* `adduser` : CrÃ©e un utilisateur systÃ¨me
* `--uid 1001` : **User ID** = identifiant unique de l'utilisateur
* `denouser` : Nom de l'utilisateur

**Pourquoi crÃ©er un user dÃ©diÃ© ?**

Par dÃ©faut, Docker tourne en **root** (UID 0, superutilisateur).

**Risque :**
[source,bash]
----
# Si une faille permet exÃ©cution de code malveillant:
Attaquant â†’ Exploit â†’ ExÃ©cution code en root â†’ AccÃ¨s TOTAL au conteneur
----

**Avec user non-root :**
[source,bash]
----
Attaquant â†’ Exploit â†’ ExÃ©cution code en denouser â†’ AccÃ¨s LIMITÃ‰
                                                   (pas de sudo, pas accÃ¨s fichiers systÃ¨me)
----

**Principe du moindre privilÃ¨ge :** Donner uniquement les droits nÃ©cessaires.

**Analogie :** Tu ne donnes pas ton mot de passe admin Windows Ã  une app random.

==== Ligne 12 : Workdir

[source,dockerfile]
----
WORKDIR /app
----

**Explication :**

* `WORKDIR` : DÃ©finit le rÃ©pertoire de travail (comme `cd /app`)
* Toutes les commandes suivantes s'exÃ©cutent dans `/app`
* Si `/app` n'existe pas, Docker le crÃ©e automatiquement

==== Lignes 14-15 : Copier configs avec ownership

[source,dockerfile]
----
COPY --chown=denouser:denouser deno.json deno.lock ./
----

**Explication mot par mot :**

* `COPY` : Copie fichiers depuis l'hÃ´te vers le conteneur
* `--chown=denouser:denouser` : **Change ownership** (propriÃ©taire des fichiers)
  - Format : `--chown=USER:GROUP`
  - `denouser` : User propriÃ©taire
  - `denouser` : Groupe propriÃ©taire
* `deno.json deno.lock` : Fichiers Ã  copier (source sur hÃ´te)
* `./` : Destination dans le conteneur (ici `/app/` car WORKDIR)

**Pourquoi `--chown` ?**

Sans `--chown`, les fichiers copiÃ©s appartiennent Ã  **root**.

[source,bash]
----
# Sans --chown
COPY deno.json ./
# â†’ Fichier appartient Ã  root:root
# â†’ denouser ne peut pas le lire âŒ

# Avec --chown
COPY --chown=denouser:denouser deno.json ./
# â†’ Fichier appartient Ã  denouser:denouser
# â†’ denouser peut le lire âœ…
----

**VÃ©rifier ownership dans un conteneur :**
[source,bash]
----
docker run --rm mon-image ls -la /app
# -rw-r--r-- 1 denouser denouser  123 Jan 15 10:30 deno.json
#             â†‘ owner   â†‘ group
----

==== Ligne 18 : Copier code source

[source,dockerfile]
----
COPY --chown=denouser:denouser src/ ./src/
----

**Explication :**

* Copie le dossier `src/` de l'hÃ´te
* Vers `/app/src/` dans le conteneur
* Avec ownership `denouser:denouser`

==== Ligne 21 : Cache dÃ©pendances Deno

[source,dockerfile]
----
RUN deno cache src/index.ts
----

**Explication :**

* `deno cache` : TÃ©lÃ©charge et cache toutes les dÃ©pendances importÃ©es
* Analyse `src/index.ts` et tous ses imports rÃ©cursifs
* Stocke les dÃ©pendances dans `~/.cache/deno/`

**Exemple :**
[source,typescript]
----
// src/index.ts
import { Hono } from "https://deno.land/x/hono@v3.12.0/mod.ts";
import { sign } from "jsonwebtoken";
----

**RÃ©sultat `deno cache` :**
[source,bash]
----
TÃ©lÃ©charge:
â”œâ”€â”€ hono@v3.12.0
â”œâ”€â”€ jsonwebtoken
â””â”€â”€ Toutes dÃ©pendances transitives

Stocke dans: ~/.cache/deno/
----

**Avantage :** Au runtime, pas besoin de tÃ©lÃ©charger (dÃ©jÃ  en cache).

==== Ligne 24 : USER denouser

[source,dockerfile]
----
USER denouser
----

**Explication :**

* Change l'utilisateur pour toutes les commandes suivantes
* Avant cette ligne : commandes en **root**
* AprÃ¨s cette ligne : commandes en **denouser**

**Impact :**

* `CMD` (ligne 30) tournera en `denouser`, pas root
* Le serveur Deno tourne en user non-root âœ…

==== Ligne 27 : EXPOSE

[source,dockerfile]
----
EXPOSE 3000
----

**Explication :**

* `EXPOSE` : Documente le port utilisÃ© par le conteneur
* **N'ouvre PAS le port** (juste documentation)
* Pour ouvrir le port : `-p 3000:3000` lors du `docker run`

**Usage :**
[source,bash]
----
docker run -p 3000:3000 mon-image
#           â†‘ port hÃ´te : port conteneur
----

==== Lignes 30-34 : CMD avec permissions Deno

[source,dockerfile]
----
CMD ["deno", "run", \
     "--allow-net", \
     "--allow-read", \
     "--allow-env", \
     "src/index.ts"]
----

**Explication :**

* `CMD` : Commande exÃ©cutÃ©e au dÃ©marrage du conteneur
* Format JSON array : `["commande", "arg1", "arg2"]`
* `\` : Retour Ã  la ligne (lisibilitÃ©)

**Arguments Deno :**

* `deno run` : Lance un script TypeScript
* `--allow-net` : **Autorise accÃ¨s rÃ©seau** (HTTP/HTTPS, sockets)
* `--allow-read` : **Autorise lecture fichiers** (config, .env, etc.)
* `--allow-env` : **Autorise lecture variables d'environnement** (process.env)
* `src/index.ts` : Fichier Ã  exÃ©cuter

**Pourquoi permissions explicites ?**

Deno est **sÃ©curisÃ© par dÃ©faut** (deny all).

[source,bash]
----
# Sans permissions
deno run src/index.ts
# â†’ âŒ Error: Requires net access (essaie d'ouvrir port 3000)

# Avec --allow-net
deno run --allow-net src/index.ts
# â†’ âœ… Serveur dÃ©marre
----

**Permissions disponibles :**

[cols="2,3,2"]
|===
|Permission |Description |BlaBlaBook V2

|`--allow-net`
|RÃ©seau (HTTP, sockets)
|âœ… NÃ©cessaire (API)

|`--allow-read`
|Lecture fichiers
|âœ… NÃ©cessaire (config)

|`--allow-env`
|Variables env
|âœ… NÃ©cessaire (.env)

|`--allow-write`
|Ã‰criture fichiers
|âŒ Pas besoin

|`--allow-run`
|ExÃ©cuter sous-process
|âŒ Pas besoin

|`--allow-all`
|Toutes permissions
|âŒ Trop permissif
|===

**Principe :** Donner SEULEMENT les permissions nÃ©cessaires (moindre privilÃ¨ge).

=== Question : Lancer manuellement ?

**Question :**
> "Je dois Ã©crire Ã  chaque fois `deno run --allow-net --allow-read --allow-env src/index.ts` ?"

**RÃ©ponse :**

==== En dÃ©veloppement local (hors Docker)

**Option 1 : Utiliser `deno task` (recommandÃ©)** âœ…

[source,bash]
----
# DÃ©fini dans deno.json
deno task dev
----

**Fichier `deno.json` :**
[source,json]
----
{
  "tasks": {
    "dev": "deno run --allow-net --allow-read --allow-env --watch src/index.ts"
  }
}
----

**Avantages :**

* âœ… Commande courte (`deno task dev`)
* âœ… Permissions centralisÃ©es dans `deno.json`
* âœ… `--watch` recharge automatiquement le code

**Option 2 : Script Bash** âœ…

[source,bash]
----
# scripts/dev.sh
#!/bin/bash
deno run \
  --allow-net \
  --allow-read \
  --allow-env \
  --watch \
  src/index.ts
----

**Usage :**
[source,bash]
----
chmod +x scripts/dev.sh
./scripts/dev.sh
----

**Option 3 : Taper la commande complÃ¨te** âŒ (pÃ©nible)

[source,bash]
----
deno run --allow-net --allow-read --allow-env src/index.ts
----

==== En production (Docker)

**Dans le Dockerfile :**
[source,dockerfile]
----
CMD ["deno", "run", "--allow-net", "--allow-read", "--allow-env", "src/index.ts"]
----

**Tu n'Ã©cris RIEN manuellement :**

[source,bash]
----
# DÃ©marrer le conteneur
docker compose -f docker-compose.prod.yml up

# La commande CMD est lancÃ©e automatiquement âœ…
----

==== En production (VPS sans Docker)

**Option 1 : Utiliser systemd service** âœ… (recommandÃ©)

[source,ini]
----
# /etc/systemd/system/blablabook.service
[Unit]
Description=BlaBlaBook Backend API
After=network.target

[Service]
Type=simple
User=denouser
WorkingDirectory=/opt/blablabook/backend
ExecStart=/usr/local/bin/deno run \
  --allow-net \
  --allow-read \
  --allow-env \
  src/index.ts
Restart=always

[Install]
WantedBy=multi-user.target
----

**Usage :**
[source,bash]
----
sudo systemctl start blablabook
sudo systemctl enable blablabook  # Auto-start au boot
----

**Avantages :**

* âœ… DÃ©marre automatiquement au boot
* âœ… RedÃ©marre si crash
* âœ… Logs avec `journalctl -u blablabook`

**Option 2 : PM2 (Process Manager)** âœ…

[source,bash]
----
# Installer PM2 (Node.js requis)
npm install -g pm2

# DÃ©marrer avec PM2
pm2 start "deno run --allow-net --allow-read --allow-env src/index.ts" --name blablabook

# Sauvegarder config
pm2 save
pm2 startup
----

**Option 3 : Script + nohup** âš ï¸ (basique)

[source,bash]
----
nohup deno run --allow-net --allow-read --allow-env src/index.ts > output.log 2>&1 &
----

=== RÃ©sumÃ© Backend

**Dockerfile.prod Backend = 1 stage**

[cols="2,3"]
|===
|Ã‰lÃ©ment |Raison

|**1 stage uniquement**
|Deno lÃ©ger, pas de build complexe

|**Fix Alpine**
|Patch OpenSSL vulnerability

|**User non-root**
|SÃ©curitÃ© (principe moindre privilÃ¨ge)

|**--chown**
|Files appartiennent Ã  denouser

|**Permissions explicites**
|`--allow-net/read/env` uniquement
|===

== ğŸŸ¢ Frontend Next.js : Multi-Stage Obligatoire

=== Pourquoi 2 stages ?

**Next.js nÃ©cessite multi-stage car :**

* âŒ `node_modules/` Ã©norme (500-800 MB avec dev dependencies)
* âŒ Code source TypeScript/JSX pas nÃ©cessaire aprÃ¨s build
* âŒ Outils build (typescript, eslint, webpack) inutiles en prod

**Gain multi-stage :** ~650 MB (78% plus lÃ©ger !)

**DÃ©cision :** Multi-stage obligatoire (standard industrie)

=== Dockerfile.prod Frontend ExpliquÃ©

==== STAGE 1 : Builder (construction)

[source,dockerfile]
----
FROM node:22-alpine AS builder
# â†‘ AS builder = Nom du stage
----

**Explication :**

* `AS builder` : Donne un nom Ã  ce stage
* Permet de rÃ©fÃ©rencer ce stage avec `--from=builder`

**Contenu STAGE 1 :**

[source,dockerfile]
----
RUN apk update && apk upgrade --no-cache

WORKDIR /app

COPY package*.json ./
RUN npm ci              # Install TOUTES dÃ©pendances (dev + prod)

COPY . .                # Copie TOUT le code source
RUN npm run build       # Build Next.js
----

**RÃ©sultat :**
[source,plaintext]
----
builder/ (800 MB) - TEMPORAIRE
â”œâ”€â”€ node_modules/        (500 MB - typescript, eslint, etc.)
â”œâ”€â”€ src/                 (code source)
â”œâ”€â”€ .next/standalone/    âœ… On va copier Ã§a
â”œâ”€â”€ .next/static/        âœ… On va copier Ã§a
â””â”€â”€ public/              âœ… On va copier Ã§a
----

**Ce stage est JETÃ‰ aprÃ¨s le build !**

==== STAGE 2 : Runner (production)

[source,dockerfile]
----
FROM node:22-alpine AS runner
# â†‘ Nouvelle image VIERGE (on repart de zÃ©ro)
----

**Explication :**

* Nouvelle image propre, sans rien du STAGE 1
* On va copier SEULEMENT ce qui est nÃ©cessaire

**Copie sÃ©lective depuis builder :**

[source,dockerfile]
----
COPY --from=builder --chown=nextjs:nodejs /app/public ./public
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static
----

**Explication :**

* `--from=builder` : Copie depuis le STAGE 1 (builder), pas depuis l'hÃ´te
* `/app/public` dans builder â†’ `./public` dans runner
* `--chown=nextjs:nodejs` : Files appartiennent Ã  nextjs (user non-root)

**RÃ©sultat STAGE 2 :**
[source,plaintext]
----
runner/ (150 MB) - IMAGE FINALE âœ…
â”œâ”€â”€ public/              (images, fonts)
â”œâ”€â”€ .next/standalone/    (Node.js + deps prod minimales)
â”œâ”€â”€ .next/static/        (JS/CSS minifiÃ©s)
â””â”€â”€ C'est TOUT !

Pas de:
âŒ node_modules/ complet
âŒ src/ code source
âŒ typescript, eslint, webpack
----

==== Next.js Standalone Output

**Configuration requise (`next.config.js`) :**

[source,javascript]
----
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'standalone',  // âš ï¸ Important pour Docker !
};

module.exports = nextConfig;
----

**Explication :**

* `output: 'standalone'` : Next.js gÃ©nÃ¨re un build optimisÃ© pour Docker
* CrÃ©e `.next/standalone/` avec :
  - `server.js` (serveur Node.js minimal)
  - DÃ©pendances prod uniquement (pas typescript, eslint)
  - PrÃªt Ã  run avec `node server.js`

**Sans standalone :**
[source,plaintext]
----
.next/
â”œâ”€â”€ build/
â”œâ”€â”€ cache/
â””â”€â”€ NÃ©cessite node_modules/ complet (500 MB) âŒ
----

**Avec standalone :**
[source,plaintext]
----
.next/standalone/
â”œâ”€â”€ server.js                    âœ…
â”œâ”€â”€ node_modules/ (minimal 50MB) âœ…
â””â”€â”€ PrÃªt Ã  lancer
----

=== Comparaison Taille Images

[cols="2,2,2,2"]
|===
|Image |Taille |Contenu |Usage

|**Backend Single-stage**
|150 MB
|Deno + src/
|âœ… OK

|**Frontend Single-stage**
|847 MB
|Node + node_modules complet + src
|âŒ Trop lourd

|**Frontend Multi-stage**
|187 MB
|Node + standalone minimal
|âœ… OK
|===

**Gain Frontend multi-stage : 660 MB (78%)**

== ğŸ“Š Tableau RÃ©capitulatif

[cols="2,2,2,3"]
|===
|Service |Environnement |Stages |CaractÃ©ristiques

|**Backend Dev**
|DÃ©veloppement
|1 stage
|Watch mode, permissions larges

|**Backend Prod**
|Production
|1 stage
|User non-root, permissions minimales

|**Frontend Dev**
|DÃ©veloppement
|1 stage
|Hot reload, node_modules montÃ©

|**Frontend Prod**
|Production
|2 stages
|Multi-stage, standalone, ultra-lÃ©ger
|===

== ğŸ” SÃ©curitÃ© : User Non-Root

=== Pourquoi user non-root ?

**ScÃ©nario d'attaque :**

[source,plaintext]
----
1. Attaquant trouve vulnÃ©rabilitÃ© dans Hono/Next.js
2. Exploit â†’ ExÃ©cution code arbitraire
3. Si conteneur tourne en root â†’ AccÃ¨s TOTAL
4. Attaquant peut:
   - Lire tous fichiers (dont secrets)
   - Modifier l'application
   - Installer backdoors
   - AccÃ©der Ã  d'autres conteneurs (rÃ©seau Docker)
----

**Avec user non-root :**

[source,plaintext]
----
1. Attaquant trouve vulnÃ©rabilitÃ©
2. Exploit â†’ ExÃ©cution code en denouser/nextjs
3. AccÃ¨s LIMITÃ‰:
   - âŒ Pas accÃ¨s root
   - âŒ Pas modifier fichiers systÃ¨me
   - âŒ Pas installer packages
   - âœ… Seulement accÃ¨s /app/ et ses fichiers
----

**Impact rÃ©duit de 90% !**

=== Commandes pour vÃ©rifier

[source,bash]
----
# VÃ©rifier user dans un conteneur
docker run --rm mon-image whoami
# denouser  âœ…

# VÃ©rifier ownership fichiers
docker run --rm mon-image ls -la /app
# -rw-r--r-- 1 denouser denouser  123 Jan 15 deno.json
----

== ğŸš€ Commandes Docker Utiles

=== Build images

[source,bash]
----
# Backend dev
docker build -f backend/Dockerfile.dev -t backend-dev backend/

# Backend prod
docker build -f backend/Dockerfile.prod -t backend-prod backend/

# Frontend dev
docker build -f frontend/Dockerfile.dev -t frontend-dev frontend/

# Frontend prod (multi-stage automatique)
docker build -f frontend/Dockerfile.prod -t frontend-prod frontend/
----

=== Run conteneurs

[source,bash]
----
# Backend
docker run -p 3000:3000 --env-file backend/.env backend-prod

# Frontend
docker run -p 3001:3001 frontend-prod
----

=== Docker Compose (recommandÃ©)

[source,bash]
----
# Dev (backend + frontend + postgres + adminer)
docker compose -f docker-compose.dev.yml up --build

# Prod (backend + frontend + postgres)
docker compose -f docker-compose.prod.yml up --build -d
----

=== Inspecter images

[source,bash]
----
# Taille images
docker images

# Layers d'une image
docker history mon-image

# Scanner vulnÃ©rabilitÃ©s
docker run aquasec/trivy image mon-image
----

== ğŸ“š Glossaire Docker

[cols="2,3"]
|===
|Terme |DÃ©finition

|**FROM**
|Image de base (ex: node:22-alpine)

|**RUN**
|ExÃ©cute commande pendant BUILD

|**CMD**
|Commande exÃ©cutÃ©e au START du conteneur

|**COPY**
|Copie fichiers hÃ´te â†’ conteneur

|**WORKDIR**
|DÃ©finit rÃ©pertoire de travail (cd)

|**EXPOSE**
|Documente port utilisÃ© (pas d'ouverture)

|**USER**
|Change l'utilisateur pour commandes suivantes

|**--chown**
|Change propriÃ©taire fichiers copiÃ©s

|**AS**
|Nomme un stage (multi-stage)

|**--from=**
|Copie depuis un autre stage

|**Layer**
|Couche Docker (chaque RUN/COPY = 1 layer)

|**Cache**
|Docker rÃ©utilise layers inchangÃ©s

|**Multi-stage**
|Plusieurs FROM dans 1 Dockerfile
|===

== ğŸ¯ Best Practices

=== Ordre des COPY (cache Docker)

**âŒ Mauvais ordre :**
[source,dockerfile]
----
COPY . .              # Copie TOUT
RUN npm ci            # Invalide cache Ã  chaque modif code
----

**âœ… Bon ordre :**
[source,dockerfile]
----
COPY package*.json ./  # Layer 1: Configs (change rarement)
RUN npm ci             # Layer 2: Install (mis en cache si package.json inchangÃ©)
COPY . .               # Layer 3: Code (change souvent)
----

**Avantage :** Si tu modifies `src/index.ts`, Docker rÃ©utilise layers 1-2 (npm ci pas relancÃ©).

=== Grouper commandes RUN

**âŒ Mauvais (4 layers) :**
[source,dockerfile]
----
RUN apk update
RUN apk upgrade
RUN apk add libstdc++
RUN rm -rf /var/cache/apk/*
----

**âœ… Bon (1 layer) :**
[source,dockerfile]
----
RUN apk update && \
    apk upgrade && \
    apk add libstdc++ && \
    rm -rf /var/cache/apk/*
----

=== User non-root obligatoire prod

[source,dockerfile]
----
# CrÃ©er user
RUN addgroup --system myapp && adduser --system myapp

# Copier avec ownership
COPY --chown=myapp:myapp . .

# Passer en user
USER myapp
----

=== .dockerignore obligatoire

[source,plaintext]
----
# frontend/.dockerignore
node_modules
.next
.git
.env.local
----

**Gain :** Image 5-10x plus lÃ©gÃ¨re, build plus rapide

== ğŸ”— Ressources

* Docker Best Practices : https://docs.docker.com/develop/dev-best-practices/
* Multi-stage builds : https://docs.docker.com/build/building/multi-stage/
* Next.js Docker : https://nextjs.org/docs/deployment#docker-image
* Deno Docker : https://deno.land/manual/getting_started/setup_your_environment#docker

---

_Document crÃ©Ã© : {docdate}_
_Version : 1.0_
_Projet : BlaBlaBook V2_