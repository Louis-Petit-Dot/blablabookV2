= Middleware AuthLockout - Analyse ComplÃ¨te
:toc:
:toclevels: 3

== Vue d'ensemble

Le middleware authLockout protÃ¨ge l'API BlaBlaBook V2 contre les attaques de force brute sur les comptes utilisateur. Il surveille les tentatives de connexion Ã©chouÃ©es et verrouille temporairement les comptes aprÃ¨s trop d'Ã©checs consÃ©cutifs. C'est le systÃ¨me de sÃ©curitÃ© qui empÃªche les pirates d'essayer des milliers de mots de passe pour forcer l'accÃ¨s aux comptes.

== Fonctions principales

=== authLockoutMiddleware
**Objectif:** VÃ©rifier si un compte n'est pas temporairement verrouillÃ© avant d'autoriser une tentative de connexion
**Quand:** AppliquÃ© uniquement sur la route de connexion (POST /login)
**Pourquoi important:** EmpÃªche les attaques automatisÃ©es qui testent des milliers de mots de passe

=== recordFailedLogin
**Objectif:** Enregistrer un Ã©chec de connexion et Ã©ventuellement verrouiller le compte
**Quand:** AppelÃ©e par le contrÃ´leur aprÃ¨s chaque tentative de connexion Ã©chouÃ©e
**Pourquoi important:** Compte les Ã©checs pour dÃ©clencher la protection

=== recordSuccessfulLogin
**Objectif:** Remettre Ã  zÃ©ro le compteur d'Ã©checs aprÃ¨s une connexion rÃ©ussie
**Quand:** AppelÃ©e par le contrÃ´leur aprÃ¨s chaque connexion rÃ©ussie
**Pourquoi important:** Permet Ã  l'utilisateur lÃ©gitime de rÃ©initialiser la protection

== Principe des attaques par force brute

=== Qu'est-ce qu'une attaque par force brute
Imaginez un cambrioleur qui essaie toutes les combinaisons possibles sur un cadenas jusqu'Ã  trouver la bonne. Une attaque par force brute fait la mÃªme chose avec les mots de passe : un programme informatique teste automatiquement des milliers ou millions de mots de passe jusqu'Ã  trouver le bon.

=== Application aux comptes BlaBlaBook
Sans protection, un attaquant pourrait :
- Essayer tous les mots de passe courants (123456, password, etc.)
- Tester des dictionnaires entiers de mots de passe
- Utiliser des informations personnelles de l'utilisateur (date de naissance, nom, etc.)
- Continuer indÃ©finiment jusqu'Ã  rÃ©ussir

=== Comment le middleware authLockout empÃªche cela
Le systÃ¨me compte les Ã©checs de connexion et dit : "Trop d'erreurs, attendez 15 minutes avant de rÃ©essayer". Cela rend l'attaque si lente qu'elle devient pratiquement impossible.

== Fonctionnement du middleware authLockout

=== Principe du compte Ã  rebours
Le systÃ¨me authLockout fonctionne comme un gardien qui surveille les tentatives :

1. **Surveillance discrÃ¨te** : Il observe chaque tentative de connexion sans se montrer
2. **Comptage des erreurs** : Il compte secrÃ¨tement les Ã©checs pour chaque adresse email
3. **DÃ©tection de comportement suspect** : AprÃ¨s 5 Ã©checs, il considÃ¨re que c'est suspect
4. **Verrouillage temporaire** : Il bloque toute nouvelle tentative pendant 15 minutes
5. **Remise Ã  zÃ©ro automatique** : AprÃ¨s une connexion rÃ©ussie, il efface l'historique

=== Stockage des tentatives avec Deno KV

Le systÃ¨me utilise Deno KV (key-value store) pour stocker les tentatives avec fallback mÃ©moire :

**Deno KV (prioritaire) :**
- Base de donnÃ©es clÃ©-valeur native de Deno
- Persistance des donnÃ©es mÃªme aprÃ¨s redÃ©marrage du serveur
- Expiration automatique des entrÃ©es via `expireIn`
- Partageable entre plusieurs instances de l'application

**Fallback mÃ©moire :**
- Si Deno KV n'est pas disponible, utilise un Map JavaScript en mÃ©moire
- Permet au systÃ¨me de fonctionner mÃªme sans Deno KV
- Les donnÃ©es sont perdues au redÃ©marrage

**Pour chaque email, le systÃ¨me mÃ©morise :**
- **Nombre d'Ã©checs** : Compteur incrÃ©mentÃ© Ã  chaque erreur
- **DerniÃ¨re tentative** : Horodatage de la derniÃ¨re tentative
- **VerrouillÃ© jusqu'Ã ** : Timestamp de fin de verrouillage (si applicable)

=== FenÃªtre de temps glissante
Le systÃ¨me utilise une fenÃªtre de 15 minutes :
- Si 15 minutes s'Ã©coulent entre deux tentatives, le compteur repart Ã  zÃ©ro
- Seuls les Ã©checs rÃ©cents comptent pour le verrouillage
- Cela permet aux utilisateurs lÃ©gitimes de retrouver l'accÃ¨s aprÃ¨s une pause

== Configuration de sÃ©curitÃ©

=== ParamÃ¨tres de protection
- **Nombre maximum d'essais** : 5 tentatives autorisÃ©es
- **DurÃ©e de verrouillage** : 15 minutes de blocage
- **FenÃªtre de comptage** : 15 minutes pour accumuler les Ã©checs

=== Ã‰quilibre sÃ©curitÃ©/utilisabilitÃ©
Ces valeurs offrent un bon compromis :
- **5 essais** : Assez pour qu'un utilisateur lÃ©gitime se trompe quelques fois
- **15 minutes** : Assez court pour ne pas frustrer, assez long pour dÃ©courager les attaques
- **FenÃªtre glissante** : Les utilisateurs lÃ©gitimes peuvent reprendre aprÃ¨s une pause

=== PossibilitÃ© d'ajustement
Les valeurs peuvent Ãªtre facilement modifiÃ©es selon les besoins :
- Plus strict pour des comptes sensibles
- Plus permissif pour amÃ©liorer l'expÃ©rience utilisateur
- Adaptation selon l'analyse des tentatives d'attaque

== Route utilisant le middleware authLockout

=== Protection spÃ©cialisÃ©e de la connexion
**Route unique protÃ©gÃ©e :** POST /api/users/login

**Pourquoi uniquement cette route :**
- La connexion est le seul point d'entrÃ©e pour les attaques par force brute
- Les autres routes nÃ©cessitent dÃ©jÃ  une authentification
- Concentrer la protection lÃ  oÃ¹ elle est vraiment nÃ©cessaire

**Placement dans la chaÃ®ne de middlewares :**
1. **authLockoutMiddleware** : VÃ©rifie les verrouillages en premier
2. **csrfProtection** : VÃ©rifie l'origine de la requÃªte
3. **validateSchema** : Valide le format des donnÃ©es
4. **userController.login** : Traite la connexion proprement dite

== Exemple de flux complet

=== ScÃ©nario : Un attaquant tente une attaque par force brute sur le compte de Marie

==== Situation de dÃ©part
Un attaquant a rÃ©cupÃ©rÃ© l'adresse email de Marie (marie@example.com) et lance un programme automatique pour tester des milliers de mots de passe courants.

==== Tentatives 1 Ã  5 : Surveillance discrÃ¨te
Pour chaque tentative Ã©chouÃ©e :
- Le middleware authLockout vÃ©rifie que marie@example.com n'est pas encore verrouillÃ©e
- Il laisse passer la tentative vers le contrÃ´leur
- Le contrÃ´leur vÃ©rifie le mot de passe et constate l'Ã©chec
- Il appelle recordFailedLogin('marie@example.com')
- Le systÃ¨me incrÃ©mente le compteur : 1, puis 2, puis 3, 4, 5

==== Tentative 6 : DÃ©clenchement du verrouillage
Lors de la 5Ã¨me tentative Ã©chouÃ©e :
- recordFailedLogin constate que c'est le 5Ã¨me Ã©chec
- Il dÃ©cide de verrouiller le compte pour 15 minutes
- Il calcule : maintenant + 15 minutes = heure de dÃ©verrouillage
- Il enregistre cette information

==== Tentatives 7+ : Blocage actif
Pour toutes les tentatives suivantes :
- Le middleware authLockout vÃ©rifie marie@example.com
- Il trouve que le compte est verrouillÃ© jusqu'Ã  [heure future]
- Il bloque immÃ©diatement sans mÃªme vÃ©rifier le mot de passe
- Il renvoie : "Account temporarily locked. Try again in X minutes."

==== Protection rÃ©ussie
L'attaquant se retrouve bloquÃ© :
- Son programme doit attendre 15 minutes entre chaque sÃ©rie de 5 tentatives
- Une attaque qui aurait pris quelques minutes prend maintenant des annÃ©es
- L'attaque devient Ã©conomiquement non rentable
- Marie est protÃ©gÃ©e

=== ScÃ©nario alternatif : Marie se trompe puis rÃ©ussit

==== Tentatives lÃ©gitimes
Marie essaie de se connecter mais se trompe 3 fois :
- Le systÃ¨me compte : 1, 2, 3 tentatives Ã©chouÃ©es
- Marie n'est pas encore verrouillÃ©e (limite Ã  5)

==== Connexion rÃ©ussie
Ã€ la 4Ã¨me tentative, Marie se souvient de son vrai mot de passe :
- Le contrÃ´leur valide la connexion
- Il appelle recordSuccessfulLogin('marie@example.com')
- Le systÃ¨me efface complÃ¨tement l'historique d'Ã©checs
- Marie peut continuer normalement

==== Remise Ã  zÃ©ro
Si Marie se trompe encore plus tard :
- Le compteur repart de zÃ©ro
- Elle a de nouveau droit Ã  5 tentatives
- Le systÃ¨me ne pÃ©nalise pas les erreurs passÃ©es

== Gestion des verrouillages

=== Informations fournies Ã  l'utilisateur
Quand un compte est verrouillÃ©, l'utilisateur reÃ§oit :
- Un message clair : "Account temporarily locked"
- La durÃ©e d'attente prÃ©cise : "Try again in X minutes"
- L'heure exacte de dÃ©verrouillage (format ISO)

=== Calcul du temps restant
Le systÃ¨me calcule prÃ©cisÃ©ment :
- Temps actuel vs heure de dÃ©verrouillage
- Conversion en minutes pour l'affichage
- Arrondi au supÃ©rieur pour Ãªtre sÃ»r

=== DÃ©verrouillage automatique
Aucune intervention manuelle n'est nÃ©cessaire :
- Le systÃ¨me vÃ©rifie automatiquement Ã  chaque nouvelle tentative
- Si le temps de verrouillage est Ã©coulÃ©, l'accÃ¨s est restaurÃ©
- Le compteur d'Ã©checs repart Ã  zÃ©ro

== Nettoyage et maintenance

=== Expiration automatique avec Deno KV
Le systÃ¨me utilise l'expiration automatique native de Deno KV :
- Chaque entrÃ©e est crÃ©Ã©e avec un `expireIn: ATTEMPT_WINDOW` (15 minutes)
- Deno KV supprime automatiquement les entrÃ©es expirÃ©es
- Plus besoin de nettoyage pÃ©riodique manuel
- LibÃ©ration automatique de l'espace de stockage

=== Avantages de Deno KV
Le stockage avec Deno KV apporte :
- **Persistance** : Les verrouillages survivent aux redÃ©marrages du serveur
- **Partage** : Les informations peuvent Ãªtre partagÃ©es entre plusieurs instances
- **Performance** : AccÃ¨s trÃ¨s rapides, optimisÃ© pour les clÃ©-valeurs
- **SimplicitÃ©** : Pas besoin de base de donnÃ©es externe

=== Fallback mÃ©moire pour compatibilitÃ©
Si Deno KV n'est pas disponible :
- Le systÃ¨me bascule automatiquement sur un Map en mÃ©moire
- Les verrouillages sont perdus au redÃ©marrage
- Ne partage pas entre instances
- Convient pour dÃ©veloppement et tests

=== Stockage de l'email dans le contexte
Le middleware stocke l'email de la tentative dans le contexte :
- `c.set('loginEmail', email)` pour utilisation par le controller
- Permet au controller d'appeler `recordFailedLogin()` ou `recordSuccessfulLogin()`
- Ã‰vite de re-parser le body JSON dans le controller

== Logging et surveillance

=== Alertes sur les verrouillages
Chaque verrouillage gÃ©nÃ¨re une alerte dans les logs :
- Email du compte verrouillÃ©
- Nombre de tentatives qui ont causÃ© le verrouillage
- Timestamp du verrouillage

=== Monitoring des attaques
Les logs permettent :
- D'identifier les comptes frÃ©quemment attaquÃ©s
- De dÃ©tecter les campagnes d'attaques coordonnÃ©es
- D'ajuster les paramÃ¨tres de sÃ©curitÃ© si nÃ©cessaire

=== Analyse des patterns
Les administrateurs peuvent :
- Voir quels comptes sont ciblÃ©s
- Identifier les pics d'activitÃ© malveillante
- Prendre des mesures prÃ©ventives supplÃ©mentaires

== Ã‰volution vers un systÃ¨me distribuÃ©

=== Limitations actuelles
Le systÃ¨me en mÃ©moire local a ses limites :
- Pas de persistance entre redÃ©marrages
- Pas de partage entre plusieurs serveurs
- Pas d'historique long terme

=== AmÃ©liorations possibles
Pour une version future :
- **Redis** : Partage entre serveurs, persistance
- **Base de donnÃ©es** : Historique complet, analytics
- **IP blocking** : Protection au niveau rÃ©seau

=== Migration transparente
L'architecture actuelle permet une Ã©volution facile :
- L'interface des fonctions reste la mÃªme
- Seul le stockage interne changerait
- Pas d'impact sur le code des contrÃ´leurs

== RÃ©sumÃ©

Le middleware authLockout est le **protecteur contre les attaques par force brute** de l'API BlaBlaBook V2. Il sÃ©curise **1 endpoint critique** avec :
- **Surveillance intelligente** : Comptage des Ã©checs par email
- **Verrouillage temporaire** : 15 minutes aprÃ¨s 5 Ã©checs
- **Remise Ã  zÃ©ro automatique** : Effacement aprÃ¨s connexion rÃ©ussie
- **Gestion du temps** : FenÃªtre glissante de 15 minutes
- **Nettoyage automatique** : Maintenance pÃ©riodique de la mÃ©moire

**Il transforme une attaque qui pourrait rÃ©ussir en quelques minutes en un processus qui prendrait des annÃ©es, protÃ©geant efficacement tous les comptes utilisateur contre les tentatives de piratage automatisÃ©es.**

== Diagramme de sÃ©quence - Workflow AuthLockout

[mermaid]
----
sequenceDiagram
    participant Attacker
    participant AuthLockoutMiddleware
    participant LoginAttemptStore
    participant ValidationMiddleware
    participant Controller
    participant LegitimateUser

    Note over Attacker, LegitimateUser: ScÃ©nario: Attaque par force brute sur marie@example.com

    rect rgb(255, 200, 200)
        Note over Attacker, Controller: 1. TENTATIVES D'ATTAQUE (1-5)
        loop Tentatives 1 Ã  5
            Attacker->>AuthLockoutMiddleware: POST /login {email: "marie@example.com", password: "motdepasse123"}
            AuthLockoutMiddleware->>AuthLockoutMiddleware: Parser body pour extraire email
            AuthLockoutMiddleware->>LoginAttemptStore: VÃ©rifier verrouillage pour marie@example.com
            LoginAttemptStore-->>AuthLockoutMiddleware: Pas encore verrouillÃ©e
            AuthLockoutMiddleware->>ValidationMiddleware: next() - Continuer pipeline

            ValidationMiddleware->>Controller: DonnÃ©es validÃ©es
            Controller->>Controller: VÃ©rifier mot de passe (Ã©chec)
            Controller->>LoginAttemptStore: recordFailedLogin("marie@example.com")
            LoginAttemptStore->>LoginAttemptStore: IncrÃ©menter compteur (1â†’2â†’3â†’4â†’5)

            alt Si tentative < 5
                Controller-->>Attacker: 401 "Invalid email or password"
            else Si tentative = 5 (dÃ©clenchement verrouillage)
                LoginAttemptStore->>LoginAttemptStore: Calculer lockedUntil = now + 15min
                LoginAttemptStore->>LoginAttemptStore: Enregistrer verrouillage
                Controller-->>Attacker: 401 "Invalid email or password"
                Note over LoginAttemptStore: Console.warn: Account locked marie@example.com (5 attempts)
            end
        end
    end

    rect rgb(255, 150, 150)
        Note over Attacker, Controller: 2. TENTATIVES BLOQUÃ‰ES (6+)
        loop Tentatives 6 Ã  âˆž
            Attacker->>AuthLockoutMiddleware: POST /login {email: "marie@example.com", password: "password456"}
            AuthLockoutMiddleware->>AuthLockoutMiddleware: Parser body pour extraire email
            AuthLockoutMiddleware->>LoginAttemptStore: VÃ©rifier verrouillage pour marie@example.com
            LoginAttemptStore-->>AuthLockoutMiddleware: lockedUntil > now (encore verrouillÃ©e)
            AuthLockoutMiddleware->>AuthLockoutMiddleware: Calculer temps restant en minutes
            AuthLockoutMiddleware-->>Attacker: 429 "Account temporarily locked. Try again in X minutes"
            Note over AuthLockoutMiddleware: ATTAQUE RALENTIE â°
        end
    end

    rect rgb(200, 255, 200)
        Note over LegitimateUser, Controller: 3. UTILISATION LÃ‰GITIME APRÃˆS EXPIRATION
        Note over LegitimateUser: 15 minutes plus tard...
        LegitimateUser->>AuthLockoutMiddleware: POST /login {email: "marie@example.com", password: "vraiMotDePasse"}
        AuthLockoutMiddleware->>LoginAttemptStore: VÃ©rifier verrouillage pour marie@example.com
        LoginAttemptStore->>LoginAttemptStore: lockedUntil < now (verrouillage expirÃ©)
        LoginAttemptStore->>LoginAttemptStore: Nettoyer ancienne entrÃ©e
        AuthLockoutMiddleware->>Controller: next() - Autoriser tentative

        Controller->>Controller: VÃ©rifier mot de passe (succÃ¨s)
        Controller->>LoginAttemptStore: recordSuccessfulLogin("marie@example.com")
        LoginAttemptStore->>LoginAttemptStore: Supprimer complÃ¨tement l'entrÃ©e
        Controller-->>LegitimateUser: 200 "Login successful" + token
        Note over LegitimateUser: MARIE RETROUVE L'ACCÃˆS âœ…
    end

    rect rgb(200, 200, 255)
        Note over AuthLockoutMiddleware, LoginAttemptStore: 4. NETTOYAGE AUTOMATIQUE
        LoginAttemptStore->>LoginAttemptStore: setInterval(5min) - Nettoyage pÃ©riodique
        LoginAttemptStore->>LoginAttemptStore: Parcourir toutes les entrÃ©es
        LoginAttemptStore->>LoginAttemptStore: Supprimer verrouillages expirÃ©s
        Note over LoginAttemptStore: Maintenance automatique ðŸ§¹
    end
----