= Middleware RBAC - Analyse Complète
:toc:
:toclevels: 3

== Vue d'ensemble

Le middleware RBAC (Role-Based Access Control) gère les permissions et rôles dans l'API BlaBlaBook V2. Il vérifie que les utilisateurs authentifiés ont les droits nécessaires pour effectuer les actions demandées. C'est le système de sécurité qui détermine "qui peut faire quoi" dans l'application.

== Fonctions principales

=== requireRole
**Objectif:** Vérifier qu'un utilisateur possède un rôle spécifique
**Quand:** Utilisé sur les routes administratives qui nécessitent des privilèges spéciaux
**Pourquoi important:** Empêche les utilisateurs normaux d'accéder aux fonctions d'administration

=== requirePermission
**Objectif:** Vérifier qu'un utilisateur possède une permission spécifique pour une action sur une ressource
**Quand:** Pourrait être utilisé pour un contrôle granulaire des permissions
**Pourquoi important:** Permet un contrôle très précis des droits d'accès
**Options:**
- `bypassCache`: Force la récupération des permissions depuis la base de données au lieu du contexte

== Fonctionnement du middleware RBAC

=== Principe de vérification des rôles avec cache
Le middleware requireRole fonctionne comme un contrôleur d'accès à un club VIP avec liste VIP pré-chargée :

1. **Identification de la personne** : Il récupère l'identité de l'utilisateur depuis le contexte (fourni par jwtMiddleware)
2. **Vérification du cache contexte** : Il vérifie d'abord si les rôles sont déjà dans le contexte utilisateur
3. **Utilisation du cache** : Si les rôles sont présents dans le contexte, il les utilise directement (optimisation)
4. **Fallback base de données** : Si absents ou si `bypassCache: true`, il interroge la base de données
5. **Vérification du niveau** : Il compare le rôle requis avec les rôles possédés
6. **Autorisation d'accès** : Si le rôle correspond, il laisse passer
7. **Refus d'accès** : Si le rôle ne correspond pas, il bloque l'accès

=== Optimisation avec enrichissement du contexte
Grâce au jwtMiddleware qui enrichit le contexte avec roles/permissions :

**Scénario rapide (contexte enrichi) :**
- Le jwtMiddleware a déjà récupéré les rôles et les a mis dans `user.roles`
- Le middleware RBAC utilise directement ces données
- **Pas de requête base de données** → Performance optimale

**Scénario fallback (contexte vide ou bypassCache) :**
- Les rôles ne sont pas dans le contexte OU l'option `bypassCache: true` est spécifiée
- Le middleware interroge userRoleService.getUserRoles()
- Requête base de données pour récupérer les rôles

**Avantages :**
- **Performance** : La majorité des requêtes évitent l'accès DB
- **Cohérence** : Option bypassCache pour forcer une vérification fraîche si nécessaire
- **Flexibilité** : Fonctionne avec ou sans cache contexte

=== Dépendance avec l'authentification
Le middleware RBAC ne peut fonctionner qu'après le middleware d'authentification :
- Il a besoin de l'identité utilisateur fournie par jwtMiddleware
- Il utilise l'ID utilisateur pour interroger la base de données (si nécessaire)
- Il vérifie d'abord que l'utilisateur est bien authentifié
- Il bénéficie de l'enrichissement du contexte avec roles/permissions

== Routes utilisant requireRole

=== Catégorie : Administration des utilisateurs

**Routes concernées :**
- Lister tous les utilisateurs du système
- Supprimer un compte utilisateur

**Pourquoi ADMIN requis :**
- Lister tous les utilisateurs : Information sensible qui ne doit être visible que par les administrateurs
- Supprimer un utilisateur : Action irréversible qui nécessite les plus hauts privilèges

**Impact :** Seuls les comptes avec le rôle ADMIN peuvent gérer les utilisateurs du système

=== Catégorie : Gestion du contenu éditorial

**Routes concernées :**
- Créer de nouveaux auteurs dans la base de données
- Supprimer des auteurs existants
- Créer de nouveaux genres littéraires

**Pourquoi ADMIN requis :**
- Créer/supprimer des auteurs : Impact sur tout le catalogue de livres
- Créer des genres : Structure fondamentale de classification des livres
- Cohérence éditoriale : Ces données doivent être gérées de manière centralisée

**Impact :** Seuls les administrateurs peuvent modifier le référentiel éditorial

=== Catégorie : Administration système complète

**Routes concernées :**
- Toutes les opérations sur les rôles (création, consultation, modification, suppression)
- Gestion des permissions associées aux rôles
- Attribution et révocation des rôles aux utilisateurs
- Consultation des permissions système

**Pourquoi ADMIN requis :**
- Gestion des rôles : Modification de la structure d'autorisation du système
- Attribution de rôles : Donner des privilèges à d'autres utilisateurs
- Permissions système : Configuration de sécurité critique

**Impact :** Seuls les super-administrateurs peuvent modifier la structure de permissions

## Interaction avec les services

=== Utilisation du userRoleService
Le middleware RBAC s'appuie sur le userRoleService pour :
- Récupérer les rôles d'un utilisateur depuis la base de données
- Récupérer toutes les permissions effectives d'un utilisateur
- Naviguer dans les relations complexes entre utilisateurs, rôles et permissions

=== Requêtes en base de données
À chaque vérification de rôle, le système :
- Fait une requête pour récupérer les rôles de l'utilisateur
- Joint les tables users, user_roles et roles
- Vérifie la correspondance avec le rôle requis
- Cache potentiellement le résultat pour éviter les requêtes répétées

## Exemple de flux complet

=== Scénario : Un utilisateur tente d'accéder à la liste de tous les utilisateurs

==== Situation de départ
Marc, utilisateur normal de BlaBlaBook, trouve un lien vers l'administration et essaie d'accéder à la liste complète des utilisateurs inscrits sur la plateforme.

==== Étape 1 : Authentification réussie
Le middleware jwtMiddleware :
- Vérifie le token JWT de Marc
- Confirme son identité (user_456)
- Stocke ses informations dans le contexte de la requête

==== Étape 2 : Vérification du rôle ADMIN
Le middleware requireRole('ADMIN') :
- Récupère l'ID de Marc (user_456) depuis le contexte
- Appelle userRoleService.getUserRoles(user_456)
- Le service interroge la base de données et trouve que Marc a seulement le rôle "USER"
- Compare "USER" avec "ADMIN" requis → pas de correspondance

==== Étape 3 : Blocage de l'accès
Le middleware :
- Constate que Marc n'a pas le rôle requis
- Bloque immédiatement la requête
- Renvoie une erreur 403 "Insufficient role" avec le détail "ADMIN required"
- Marc ne peut pas accéder à la liste des utilisateurs

==== Alternative : Si Marc était administrateur
Si Marc avait eu le rôle ADMIN :
- La vérification aurait réussi
- La requête aurait continué vers le contrôleur
- Marc aurait pu consulter la liste complète des utilisateurs

==== Sécurité renforcée
Ce système garantit que :
- Les données sensibles restent protégées
- Seules les personnes autorisées accèdent aux fonctions critiques
- Les actions administratives sont tracées et contrôlées

## Gestion des erreurs

=== Utilisateur non authentifié
Si le middleware RBAC est appelé sans authentification préalable :
- Il détecte l'absence d'informations utilisateur
- Il renvoie immédiatement une erreur 401 "Authentication required"
- Il empêche toute tentative d'accès non autorisé

=== Utilisateur introuvable
Si l'ID utilisateur du token ne correspond à aucun utilisateur en base :
- Le service retourne null
- Le middleware renvoie une erreur 404 "User not found"
- Cela peut indiquer un token corrompu ou un utilisateur supprimé

=== Erreur de service
Si la base de données est inaccessible ou qu'une erreur technique survient :
- Le middleware capture l'exception
- Il renvoie une erreur 500 "Error checking role"
- L'accès est refusé par prudence

=== Rôle insuffisant
Quand l'utilisateur existe mais n'a pas le bon rôle :
- Le middleware renvoie une erreur 403 "Insufficient role"
- Il indique clairement quel rôle était requis
- L'utilisateur comprend pourquoi l'accès est refusé

## Architecture des permissions

=== Structure hiérarchique simple
Actuellement, l'API utilise principalement deux niveaux :
- **USER** : Rôle de base pour tous les utilisateurs inscrits
- **ADMIN** : Rôle administratif avec tous les privilèges

=== Extensibilité future
L'architecture permet d'ajouter facilement :
- De nouveaux rôles (MODERATOR, EDITOR, etc.)
- Des permissions plus granulaires
- Des contrôles d'accès plus fins selon les besoins

=== Permissions par action et ressource
Le système requirePermission (bien que peu utilisé actuellement) permet :
- De définir des permissions spécifiques comme "CREATE" sur "BOOK"
- De créer des matrices de droits très détaillées
- D'adapter les permissions selon l'évolution du produit

## Avantages sécuritaires

=== Séparation des responsabilités
Le système RBAC assure :
- Une séparation claire entre utilisateurs normaux et administrateurs
- Une protection des fonctions sensibles du système
- Une traçabilité des actions selon les rôles

=== Principe du moindre privilège
Chaque utilisateur :
- N'a que les permissions nécessaires à son usage
- Ne peut pas accéder aux fonctions pour lesquelles il n'est pas autorisé
- Voit ses actions limitées à son périmètre de responsabilité

=== Défense en profondeur
Le contrôle des rôles s'ajoute :
- À l'authentification (qui êtes-vous ?)
- À la validation des données (que voulez-vous faire ?)
- À la vérification de propriété (sur quoi voulez-vous agir ?)

## Performance et optimisation

=== Impact des vérifications optimisées
Avec le système de cache contexte :

**Scénario optimal (99% des cas) :**
- Le jwtMiddleware enrichit le contexte avec roles/permissions
- Le middleware RBAC lit directement depuis le contexte
- **Aucune requête base de données** supplémentaire
- Latence minimale (quelques microsecondes)

**Scénario fallback (rare) :**
- Le contexte ne contient pas les rôles (erreur de cache)
- OU l'option `bypassCache: true` est spécifiée
- Une requête base de données est effectuée
- Latence additionnelle (quelques millisecondes)

=== Optimisations implémentées
Le système utilise actuellement :
- **Enrichissement contexte** : Rôles/permissions chargés une fois par jwtMiddleware
- **Cache Deno KV** : Cache partagé pour les données utilisateur
- **Fallback intelligent** : Base de données utilisée seulement si nécessaire
- **Option bypassCache** : Permet de forcer une vérification fraîche si critique

=== Architecture multi-niveaux
```
Requête
  ↓
jwtMiddleware → Cache Deno KV → Contexte enrichi (roles, permissions, is_admin)
  ↓
rbacMiddleware → Lecture contexte (rapide) OU DB (fallback)
  ↓
Controller
```

=== Équilibre sécurité/performance
Le système optimisé offre :
- **Performance** : Cache contexte pour 99% des requêtes
- **Sécurité** : Option bypassCache pour vérifications critiques
- **Cohérence** : Cache Deno KV synchronisé, invalidation sur changement de rôles
- **Simplicité** : Transparent pour les controllers

## Cas d'usage administratif

=== Administration quotidienne
Les administrateurs utilisent ces permissions pour :
- Gérer les comptes utilisateur problématiques
- Enrichir le catalogue éditorial
- Maintenir la qualité des données référentiel

=== Gestion des incidents
En cas de problème, les administrateurs peuvent :
- Suspendre des comptes abusifs
- Corriger des données erronées
- Intervenir sur les contenus inappropriés

=== Évolution du système
Les privilèges administrateur permettent :
- D'ajouter de nouveaux contenus éditoriaux
- De configurer de nouveaux rôles si nécessaire
- D'adapter les permissions aux besoins évolutifs

## Résumé

Le middleware RBAC est le **contrôleur de privilèges** de l'API BlaBlaBook V2. Il protège **20 endpoints administratifs** avec :
- **requireRole('ADMIN')** : Vérification du rôle administrateur
- **Vérification en temps réel** : Consultation de la base de données pour chaque requête
- **Protection multiniveau** : Gestion des utilisateurs, contenu éditorial et système
- **Sécurité par défaut** : Accès refusé en cas d'erreur

**Il garantit que seules les personnes autorisées peuvent effectuer les actions sensibles du système, protégeant ainsi l'intégrité et la sécurité de l'application.**

== Diagramme de séquence - Workflow RBAC

[mermaid]
----
sequenceDiagram
    participant Client
    participant JWTMiddleware
    participant RequireRole
    participant UserRoleService
    participant Database
    participant Controller

    Note over Client, Controller: Exemple: GET /api/users (lister utilisateurs - ADMIN requis)

    Client->>JWTMiddleware: Requête avec Authorization token
    JWTMiddleware->>JWTMiddleware: Vérifier et décoder JWT
    JWTMiddleware->>JWTMiddleware: c.set('user', decodedUser)
    JWTMiddleware->>RequireRole: next() - Passer à RBAC

    RequireRole->>RequireRole: c.get('user') - Récupérer utilisateur
    RequireRole->>RequireRole: Vérifier présence user.id

    alt Si user.id manquant
        RequireRole-->>Client: 401 "Authentication required"
    else User authentifié
        RequireRole->>UserRoleService: getUserRoles(user.id)
        UserRoleService->>Database: SELECT roles WHERE user_id = ?
        Database-->>UserRoleService: [{role_name: "USER"}]
        UserRoleService-->>RequireRole: {roles: [{role_name: "USER"}]}

        RequireRole->>RequireRole: Chercher role "ADMIN" dans la liste

        alt Si role ADMIN trouvé
            RequireRole->>Controller: next() - Autoriser accès
            Controller->>Controller: Traiter requête admin
            Controller-->>Client: 200 + données sensibles
        else Si role ADMIN non trouvé
            RequireRole-->>Client: 403 "Insufficient role" + required: "ADMIN"
        end
    end

    alt Si erreur base de données
        UserRoleService-->>RequireRole: Exception
        RequireRole-->>Client: 500 "Error checking role"
    end

    alt Si utilisateur introuvable
        UserRoleService-->>RequireRole: null
        RequireRole-->>Client: 404 "User not found"
    end
----