= Middleware ErrorHandler - Analyse Complète
:toc:
:toclevels: 3

== Vue d'ensemble

Le middleware errorHandler est le filet de sécurité ultime de l'API BlaBlaBook V2. Il capture toutes les erreurs qui n'ont pas été gérées par les contrôleurs ou services, les transforme en réponses HTTP appropriées et protège l'application contre les plantages. C'est le dernier rempart qui garantit que l'API répond toujours de manière professionnelle.

== Fonction principale

=== Capturer et transformer les erreurs
**Objectif:** Intercepter toutes les erreurs non gérées et les convertir en réponses HTTP propres
**Quand:** Appliqué globalement sur toute l'application ET localement sur certaines routes sensibles
**Pourquoi important:** Empêche l'application de planter et donne des réponses cohérentes aux utilisateurs

== Application du middleware errorHandler

=== Application globale
Dans le fichier principal (index.ts), le middleware est appliqué sur **toutes les routes** avec l'astérisque (*). Il agit comme un filet de sécurité global qui capture tout ce qui pourrait mal se passer.

=== Application locale renforcée
Certaines routes particulièrement sensibles ont une protection supplémentaire :
- **Routes des avis (reviews)** : Gestion des erreurs liées aux avis utilisateur
- **Routes des notes (rates)** : Gestion des erreurs de notation
- **Routes des listes de lecture** : Gestion des erreurs de manipulation des listes

Cette double protection garantit que ces fonctionnalités critiques ne peuvent jamais faire planter l'application.

== Fonctionnement du middleware errorHandler

=== Principe de fonctionnement
Le middleware errorHandler fonctionne comme un service d'urgence médical :

1. **Surveillance continue** : Il surveille discrètement toutes les opérations
2. **Détection des problèmes** : Dès qu'une erreur survient, il intervient immédiatement
3. **Diagnostic intelligent** : Il analyse le type d'erreur pour comprendre ce qui s'est passé
4. **Réponse appropriée** : Il donne une réponse adaptée selon la gravité du problème
5. **Protection du patient** : Il empêche l'application de s'arrêter brutalement

=== Capture des erreurs
Le middleware utilise un mécanisme try-catch qui entoure toute l'exécution :
- Il laisse les middlewares et contrôleurs s'exécuter normalement
- Si tout va bien, il ne fait rien
- Si une erreur survient n'importe où, il l'intercepte immédiatement

== Types d'erreurs gérées

=== Erreurs de validation avec détails
Quand le middleware de validation échoue :
- L'errorHandler reconnaît ce type d'erreur spécial
- Il récupère les détails de validation (quels champs, quels problèmes)
- Il renvoie une erreur 400 avec toutes les informations pour corriger

=== Erreurs métier avec statut personnalisé
Quand un service détecte un problème métier :
- L'errorHandler respecte le code de statut défini par le service
- Il transmet le message d'erreur tel quel
- Il maintient la logique métier intacte

=== Erreurs techniques avec détection intelligente
Quand une erreur technique survient sans code de statut :
- L'errorHandler analyse le message d'erreur
- Il devine le code de statut approprié selon le contenu
- Il applique des règles intelligentes pour déterminer la réponse

=== Erreurs inconnues avec protection totale
Quand quelque chose d'inattendu arrive :
- L'errorHandler capture tout
- Il empêche l'application de planter
- Il renvoie une erreur générique 500

== Logique de détection intelligente

=== Détection par mots-clés
L'errorHandler analyse le message d'erreur et détecte automatiquement :
- **"not found"** → Code 404 (Ressource non trouvée)
- **"already exists" ou "duplicate"** → Code 409 (Conflit)
- **"required", "invalid", "missing"** → Code 400 (Données incorrectes)
- **"unauthorized", "token"** → Code 401 (Non authentifié)
- **"forbidden", "access denied"** → Code 403 (Accès refusé)

=== Avantages de cette approche
Cette détection automatique permet :
- Aux développeurs de se concentrer sur la logique métier
- D'avoir des codes de statut cohérents sans effort
- De maintenir une API professionnelle même avec des erreurs simples

== Gestion selon l'environnement

=== En développement
Quand l'application tourne en mode développement :
- Tous les messages d'erreur sont transmis intégralement
- Les détails techniques sont visibles
- Les développeurs peuvent débugger facilement

=== En production
Quand l'application tourne en production :
- Les erreurs serveur internes (500+) sont masquées
- Les utilisateurs voient un message générique "Internal server error"
- Les détails techniques restent dans les logs serveur
- La sécurité est préservée

== Exemple de flux complet

=== Scénario : Un utilisateur tente de récupérer un avis inexistant

==== Situation de départ
Thomas veut consulter un avis sur un livre. Il clique sur un lien qui demande l'avis numéro 999, mais cet avis n'existe pas dans la base de données.

==== Étape 1 : Exécution normale
La requête passe par tous les middlewares normaux :
- Sécurité : OK
- Authentification : OK
- Autorisations : OK
- Le contrôleur d'avis est appelé

==== Étape 2 : Erreur dans le service
Le service reviewService.getById(999) :
- Cherche l'avis dans la base de données
- Ne trouve rien
- Lance une erreur : "Review not found"

==== Étape 3 : Intervention de l'errorHandler
L'errorHandler capture l'erreur :
- Il analyse le message "Review not found"
- Il détecte le mot-clé "not found"
- Il décide d'appliquer un code de statut 404

==== Étape 4 : Réponse structurée
L'errorHandler renvoie à Thomas :
- Code HTTP 404 (Not Found)
- Message JSON : { "success": false, "error": "Review not found" }
- Format professionnel et cohérent

==== Alternative : En cas d'erreur technique
Si la base de données avait été inaccessible :
- Le service aurait lancé une erreur technique
- L'errorHandler l'aurait capturée
- Il aurait renvoyé un code 500 avec un message générique en production
- Thomas aurait su qu'il fallait réessayer plus tard

== Logging et traçabilité

=== Informations enregistrées
Chaque erreur capturée est enregistrée avec :
- Le message d'erreur détaillé
- Le code de statut HTTP appliqué
- La stack trace complète (pour le débogage)
- L'URL et la méthode HTTP de la requête qui a causé l'erreur
- L'horodatage précis de l'incident

=== Utilité pour les développeurs
Ces logs permettent :
- D'identifier rapidement les problèmes récurrents
- De débugger les erreurs en production
- De monitorer la santé de l'application
- D'améliorer la robustesse du code

=== Console de débogage
En développement, toutes les informations s'affichent dans la console avec un marqueur visible "=== ERROR HANDLER CALLED ===" pour faciliter le débogage.

== Protection contre les plantages

=== Capture exhaustive
L'errorHandler capture **tous** les types d'erreurs :
- Erreurs JavaScript classiques
- Erreurs d'accès base de données
- Erreurs de réseau
- Erreurs de validation
- Erreurs métier personnalisées
- Erreurs inattendues de toute nature

=== Garantie de réponse
Même dans les situations les plus catastrophiques :
- L'API répond toujours quelque chose
- Le client n'est jamais laissé en attente
- L'application continue de fonctionner
- Les autres utilisateurs ne sont pas impactés

=== Récupération gracieuse
Après avoir géré une erreur :
- L'application retourne à un état stable
- Les ressources sont libérées correctement
- La prochaine requête peut être traitée normalement

== Avantages pour l'expérience utilisateur

=== Messages cohérents
Les utilisateurs reçoivent toujours :
- Des messages d'erreur dans le même format JSON
- Des codes de statut HTTP appropriés
- Des indications claires sur ce qui s'est passé
- Une expérience professionnelle même en cas de problème

=== Pas d'information sensible
En production, les utilisateurs ne voient jamais :
- Des détails techniques internes
- Des chemins de fichiers du serveur
- Des informations sur la structure de la base de données
- Des erreurs qui pourraient aider un attaquant

=== Stabilité garantie
Les utilisateurs bénéficient :
- D'une application qui ne plante jamais
- De la possibilité de réessayer après une erreur temporaire
- D'un service fiable même en cas de problème interne

== Routes avec protection renforcée

=== Routes des avis (reviews)
Protection double parce que les avis sont critiques :
- Beaucoup de manipulations utilisateur
- Risque d'erreurs lors de la création/modification
- Impact direct sur l'expérience utilisateur

=== Routes des notes (rates)
Protection double parce que la notation est sensible :
- Calculs potentiellement complexes
- Contraintes de unicité par utilisateur/livre
- Impact sur les statistiques globales

=== Routes des listes de lecture
Protection double parce que les listes sont personnelles :
- Manipulations fréquentes par les utilisateurs
- Relations complexes avec les livres
- Données importantes pour les utilisateurs

Cette protection renforcée garantit que ces fonctionnalités centrales restent toujours disponibles.

== Résumé

Le middleware errorHandler est le **filet de sécurité** de l'API BlaBlaBook V2. Il protège **100% des requêtes** avec :
- **Capture universelle** : Toutes les erreurs sont interceptées
- **Détection intelligente** : Codes de statut automatiques selon le contexte
- **Protection environnementale** : Messages adaptés selon développement/production
- **Logging complet** : Traçabilité pour le débogage et le monitoring
- **Protection renforcée** : Double sécurité sur les routes critiques

**Il garantit qu'aucune erreur ne peut faire planter l'API et que tous les utilisateurs reçoivent des réponses professionnelles et cohérentes.**

== Diagramme de séquence - Workflow ErrorHandler

[mermaid]
----
sequenceDiagram
    participant Client
    participant ErrorHandler
    participant NextMiddleware
    participant Controller
    participant Service
    participant Logger

    Note over Client, Logger: Exemple: GET /api/reviews/999 (avis inexistant)

    Client->>ErrorHandler: Requête
    ErrorHandler->>ErrorHandler: try { await next() }
    ErrorHandler->>NextMiddleware: next() - Exécuter pipeline

    NextMiddleware->>Controller: Route vers contrôleur
    Controller->>Service: reviewService.getById(999)
    Service->>Service: Chercher avis en base
    Service-->>Controller: throw Error("Review not found")
    Controller-->>NextMiddleware: Erreur remontée
    NextMiddleware-->>ErrorHandler: Erreur capturée

    Note over ErrorHandler: Analyse de l'erreur
    ErrorHandler->>Logger: Log complet de l'erreur
    ErrorHandler->>ErrorHandler: Analyser type d'erreur

    alt Si erreur avec détails de validation
        ErrorHandler->>ErrorHandler: Extraire détails Zod
        ErrorHandler-->>Client: 400 + détails validation
    else Si erreur avec status personnalisé
        ErrorHandler->>ErrorHandler: Utiliser error.status
        ErrorHandler-->>Client: Status personnalisé + message
    else Si erreur sans status (détection intelligente)
        ErrorHandler->>ErrorHandler: Analyser message d'erreur

        alt Message contient "not found"
            ErrorHandler-->>Client: 404 "Review not found"
        else Message contient "already exists"
            ErrorHandler-->>Client: 409 "Conflict"
        else Message contient "unauthorized"
            ErrorHandler-->>Client: 401 "Unauthorized"
        else Message contient "forbidden"
            ErrorHandler-->>Client: 403 "Forbidden"
        else Message contient "required/invalid"
            ErrorHandler-->>Client: 400 "Bad Request"
        else Autre message
            ErrorHandler->>ErrorHandler: Vérifier environnement

            alt Si production ET status >= 500
                ErrorHandler-->>Client: 500 "Internal server error"
            else Si développement OU status < 500
                ErrorHandler-->>Client: Status + message original
            end
        end
    else Erreur non-Error (cas extrême)
        ErrorHandler-->>Client: 500 "Internal server error"
    end
----