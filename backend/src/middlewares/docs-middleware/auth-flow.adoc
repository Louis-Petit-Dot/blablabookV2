= Flux d'Authentification - auth.ts
:toc:
:toclevels: 3

== Vue d'ensemble

Le fichier `auth.ts` contient les utilitaires d'authentification et le middleware JWT pour s√©curiser l'API BlaBlaBook V2.

**Architecture de s√©curit√© V2 :**

* **JWT httpOnly Cookie** : Token stock√© dans un cookie s√©curis√© (protection XSS)
* **Expiration 8h** : Session travail compl√®te sans refresh token
* **SameSite=Strict** : Protection CSRF automatique
* **Secure flag** : HTTPS obligatoire en production
* **Centralis√©** : `authUtils` g√®re set/clear/verify token

== Composants

=== authUtils

Objet contenant 6 fonctions utilitaires pour l'authentification :

==== 1. hashPassword(password: string)

[source,typescript]
----
async hashPassword(password: string): Promise<string>
----

* **Entr√©e** : Mot de passe en clair (string)
* **Traitement** : Utilise `argon2.hash()` pour hasher le mot de passe
* **Sortie** : Hash s√©curis√© (string)
* **Usage** : Lors de la cr√©ation d'un utilisateur (register)

==== 2. verifyPassword(hash: string, password: string)

[source,typescript]
----
async verifyPassword(hash: string, password: string): Promise<boolean>
----

* **Entr√©e** : Hash stock√© en DB + mot de passe saisi
* **Traitement** : Utilise `argon2.verify()` pour comparer
* **Sortie** : `true` si valide, `false` sinon
* **Usage** : Lors de la connexion (login)

==== 3. generateJWT(user)

[source,typescript]
----
generateJWT(user: { id_user: string; email: string; username: string }): string
----

* **Entr√©e** : Objet utilisateur avec id, email, username
* **Traitement** : Cr√©e un token JWT sign√© avec `JWT_SECRET`
* **Sortie** : Token JWT (expire dans 8h)
* **Payload** : `{ id, email, username, iat, exp }`
* **Usage** : Apr√®s login/register r√©ussi

==== 4. verifyJWT(token: string)

[source,typescript]
----
verifyJWT(token: string): object | null
----

* **Entr√©e** : Token JWT
* **Traitement** : V√©rifie la signature avec `JWT_SECRET`
* **Sortie** : Payload d√©cod√© ou `null` si invalide
* **Usage** : Dans le middleware pour valider les tokens

==== 5. setCookieToken(c: Context, token: string) üÜï

[source,typescript]
----
setCookieToken(c: Context, token: string): void
----

* **Entr√©e** : Hono Context + token JWT
* **Traitement** : D√©finit le header `Set-Cookie` avec flags de s√©curit√©
* **Cookie** : `access_token=<JWT>; HttpOnly; SameSite=Strict; Path=/; Max-Age=28800`
* **Secure flag** : Automatiquement ajout√© en production (`NODE_ENV=production`)
* **Usage** : Appel√© dans `login()` et `create()` controllers apr√®s g√©n√©ration JWT
* **S√©curit√©** :
  - `HttpOnly` : JavaScript ne peut pas lire (protection XSS)
  - `SameSite=Strict` : Cookie non envoy√© sur requ√™tes cross-origin (protection CSRF)
  - `Max-Age=28800` : 8 heures (8 √ó 60 √ó 60 secondes)
  - `Secure` : HTTPS uniquement en production

==== 6. clearCookieToken(c: Context) üÜï

[source,typescript]
----
clearCookieToken(c: Context): void
----

* **Entr√©e** : Hono Context
* **Traitement** : D√©finit le header `Set-Cookie` avec `Max-Age=0` pour supprimer le cookie
* **Cookie** : `access_token=; HttpOnly; SameSite=Strict; Path=/; Max-Age=0`
* **Usage** : Appel√© dans `logout()` controller
* **Effet** : Le navigateur supprime imm√©diatement le cookie

=== jwtMiddleware

Middleware Hono pour prot√©ger les routes :

[source,typescript]
----
export async function jwtMiddleware(c: Context, next: Next)
----

* **Extraction** : Lit le cookie `access_token` depuis le header `Cookie`
* **Parsing** : Parse le header Cookie (format: `cookie1=value1; cookie2=value2`)
* **Validation** : Utilise `verifyJWT()` pour v√©rifier signature et expiration
* **R√©sultat** : Ajoute `user` au contexte (`c.set('user', decoded)`) ou retourne 401

**Flow :**
```
1. R√©cup√®re header Cookie ‚Üí "access_token=eyJhbGc...; csrf_token=abc123"
2. Split par "; " ‚Üí ["access_token=eyJhbGc...", "csrf_token=abc123"]
3. Find cookie startsWith "access_token=" ‚Üí "access_token=eyJhbGc..."
4. Split par "=" et prend [1] ‚Üí "eyJhbGc..."
5. V√©rifie JWT ‚Üí { id, email, username } ou null
6. Si valid ‚Üí tente d'enrichir le contexte utilisateur depuis le cache (Deno KV) :
  - R√©cup√®re `roles` via `cacheService.getUserRoles(id)`
  - R√©cup√®re `permissions` via `cacheService.getUserPermissions(id)`
  - Si absent du cache, appelle `userRoleService.getUserRoles(id)` et `userRoleService.getUserPermissions(id)` et met en cache les r√©sultats
  - Calcule `is_admin = roles.some(r => r.role_name.toUpperCase() === 'ADMIN')`
  - D√©finit `c.set('user', { ...decoded, roles, permissions, is_admin })`
7. Si invalid ‚Üí return 401 Unauthorized
```

== Flux d'authentification

=== 1. Inscription (Register) - Flow httpOnly Cookie

[mermaid]
----
sequenceDiagram
    participant Client
    participant Controller
    participant Service
    participant AuthUtils
    participant DB

    Client->>Controller: POST /users (email, password)
    Controller->>Service: userService.create(userData)
    Service->>AuthUtils: hashPassword(password)
    AuthUtils->>Service: hashedPassword
    Service->>DB: INSERT user avec hash
    DB->>Service: newUser
    Service->>AuthUtils: generateJWT(user)
    AuthUtils->>Service: token JWT
    Service->>Controller: { user, token }
    Controller->>AuthUtils: setCookieToken(c, token)
    AuthUtils->>Controller: Set-Cookie header d√©fini
    Controller->>Client: 201 Created + Set-Cookie: access_token=JWT; HttpOnly
    Note over Client: Navigateur stocke automatiquement le cookie
----

=== 2. Connexion (Login) - Flow httpOnly Cookie

[mermaid]
----
sequenceDiagram
    participant Client
    participant Controller
    participant Service
    participant AuthUtils
    participant DB

    Client->>Controller: POST /users/login (email, password)
    Controller->>Service: userService.login(email, password)
    Service->>DB: SELECT user by email
    DB->>Service: user with hash
    Service->>AuthUtils: verifyPassword(hash, password)
    AuthUtils->>Service: true/false
    alt Password valide
        Service->>AuthUtils: generateJWT(user)
        AuthUtils->>Service: token JWT
        Service->>Controller: { user, token }
        Controller->>AuthUtils: setCookieToken(c, token)
        AuthUtils->>Controller: Set-Cookie header d√©fini
        Controller->>Client: 200 OK + Set-Cookie: access_token=JWT; HttpOnly
        Note over Client: Navigateur stocke automatiquement le cookie
    else Password invalide
        Service->>Controller: null
        Controller->>Client: 401 Unauthorized
    end
----

=== 3. Route prot√©g√©e - Flow avec Cookie

[mermaid]
----
sequenceDiagram
    participant Client
    participant Middleware
    participant AuthUtils
    participant Controller

    Note over Client: Navigateur envoie automatiquement le cookie
    Client->>Middleware: GET /protected (Cookie: access_token=JWT)
    Middleware->>Middleware: Parse header Cookie
    Middleware->>Middleware: Extract access_token value
    Middleware->>AuthUtils: verifyJWT(token)
    alt Token valide
        AuthUtils->>Middleware: decoded payload { id, email, username }
        Middleware->>Middleware: c.set('user', decoded)
        Middleware->>Controller: next()
        Controller->>Client: 200 OK + donn√©es prot√©g√©es
    else Token invalide/expir√©
        AuthUtils->>Middleware: null
        Middleware->>Client: 401 Unauthorized
    end
----

=== 4. Logout - Clear Cookie

[mermaid]
----
sequenceDiagram
    participant Client
    participant Controller
    participant AuthUtils

    Client->>Controller: POST /logout (Cookie: access_token=JWT)
    Controller->>AuthUtils: clearCookieToken(c)
    AuthUtils->>Controller: Set-Cookie: access_token=; Max-Age=0
    Controller->>Client: 200 OK + Set-Cookie (Max-Age=0)
    Note over Client: Navigateur supprime automatiquement le cookie
----

== Transport des donn√©es

=== Anatomie d'une requ√™te HTTP (avec Cookie)

[source,http]
----
POST /users/login HTTP/1.1          ‚Üê URL + m√©thode
Host: localhost:8000                ‚Üê Headers
Content-Type: application/json      ‚Üê Headers
Cookie: access_token=eyJhbGc...     ‚Üê Headers (cookie envoy√© automatiquement)

{                                   ‚Üê BODY (contenu JSON)
  "email": "user@example.com",
  "password": "secret123"
}
----

**R√©ponse avec Set-Cookie :**
[source,http]
----
HTTP/1.1 200 OK
Content-Type: application/json
Set-Cookie: access_token=eyJhbGc...; HttpOnly; SameSite=Strict; Path=/; Max-Age=28800

{
  "message": "Login successful",
  "user": { "id_user": "123", "email": "user@example.com", ... }
}
----

NOTE: Le token n'est **jamais** retourn√© dans le JSON, uniquement dans le cookie Set-Cookie

=== R√©cup√©ration des donn√©es

[cols="1,1,1,1"]
|===
|M√©thode |Usage |Exemple |S√©curit√©

|`c.req.param()`
|URL parameters
|`/users/:id` ‚Üí `c.req.param('id')`
|‚ùå Visible dans logs

|`c.req.json()`
|Body JSON
|`{"password": "..."}` ‚Üí `c.req.json()`
|‚úÖ Chiffr√© HTTPS

|`c.req.header()`
|Headers HTTP
|`Authorization: Bearer token`
|‚úÖ Chiffr√© HTTPS

|`c.req.query()`
|Query parameters
|`?filter=value` ‚Üí `c.req.query('filter')`
|‚ùå Visible dans logs
|===

=== S√©curit√© du transport

* **Password** : TOUJOURS dans le body JSON (`c.req.json()`)
* **Token JWT** : Dans un cookie httpOnly (envoi automatique par navigateur)
* **IDs** : Peuvent √™tre dans l'URL (`c.req.param('id')`)
* **Filtres** : Query parameters acceptable (`c.req.query('filter')`)

IMPORTANT: Les passwords ne passent JAMAIS par l'URL !

=== Architecture httpOnly Cookie vs localStorage

[cols="1,2,2"]
|===
|Crit√®re |localStorage (‚ùå V1) |httpOnly Cookie (‚úÖ V2)

|**Stockage**
|`localStorage.setItem('token', jwt)`
|Automatique via `Set-Cookie` header

|**Lecture**
|`localStorage.getItem('token')`
|Automatique par navigateur (header `Cookie`)

|**Exposition XSS**
|‚ùå JavaScript peut lire le token
|‚úÖ JavaScript ne peut pas lire (HttpOnly)

|**Protection CSRF**
|‚úÖ Requ√™tes manuelles uniquement
|‚úÖ SameSite=Strict bloque cross-origin

|**Expiration**
|‚ö†Ô∏è G√©r√©e manuellement c√¥t√© client
|‚úÖ Max-Age g√©r√© par navigateur

|**HTTPS obligatoire**
|‚ö†Ô∏è Recommand√© mais non forc√©
|‚úÖ Secure flag force HTTPS en prod

|**Logout**
|`localStorage.removeItem('token')`
|`Set-Cookie: Max-Age=0`
|===

**Pourquoi httpOnly Cookie ?**

* **Protection XSS** : M√™me si un script malveillant s'ex√©cute (injection), il ne peut pas lire le token
* **Simplicit√© frontend** : Le navigateur g√®re automatiquement l'envoi du cookie
* **S√©curit√© OWASP** : Recommandation officielle pour tokens sensibles

== Configuration

=== Variables d'environnement

* `JWT_SECRET` : Cl√© secr√®te pour signer les tokens JWT
* D√©finie dans `.env` et document√©e dans `.env.example`

=== S√©curit√©

* **Argon2** : Algorithme de hashage r√©sistant aux attaques
* **JWT** : Tokens stateless avec expiration (8h)
* **httpOnly Cookie** : Protection XSS (JavaScript ne peut pas lire)
* **SameSite=Strict** : Protection CSRF (pas d'envoi cross-origin)
* **Secure flag** : HTTPS uniquement en production
* **Gestion d'erreurs** : try/catch pour les tokens invalides
* **Transport HTTPS** : Body, headers et cookies chiffr√©s

=== Cycle de vie du token

```
T0    : Login ‚Üí Set-Cookie: access_token=JWT; Max-Age=28800
T+1h  : Requ√™te ‚Üí Cookie envoy√© automatiquement ‚Üí JWT valide
T+4h  : Requ√™te ‚Üí Cookie envoy√© automatiquement ‚Üí JWT valide
T+8h  : Requ√™te ‚Üí Cookie envoy√© automatiquement ‚Üí JWT expir√© ‚Üí 401
T+8h1m: User doit se re-login
```

**Avantages JWT simple 8h :**

* ‚úÖ Pas de table refresh_tokens en DB
* ‚úÖ Pas de Redis requis
* ‚úÖ Stateless maintenu
* ‚úÖ Session compl√®te (journ√©e travail)
* ‚úÖ S√©curit√© suffisante pour MVP
* ‚ö†Ô∏è Re-login apr√®s 8h (acceptable pour UX)

=== Fonctionnement d'Argon2

==== Au Register
[source,typescript]
----
password = "secret123"

// Argon2 g√©n√®re automatiquement un salt al√©atoire unique
salt = "randomSalt123xyz" (g√©n√©r√© automatiquement)

// Hash final contient TOUT
hash = "$argon2id$v=19$m=65536,t=3,p=4$randomSalt123xyz$iughbciugeiughfhoeyhzdhuzh"
//     |version|  |param√®tres m√©moire/temps| |salt inclus| |hash final|
----

==== Au Login
[source,typescript]
----
passwordSaisi = "secret123"
hashStock√© = "$argon2id$v=19$m=65536,t=3,p=4$randomSalt123xyz$iughbciugeiughfhoeyhzdhuzh"

argon2.verify(hashStock√©, passwordSaisi)
// 1. Extrait le salt du hash : "randomSalt123xyz"
// 2. Refait le calcul : argon2("secret123" + "randomSalt123xyz" + params)
// 3. Compare avec le hash stock√© ‚Üí true/false
----

==== S√©curit√© Argon2
* **Salt unique** : Chaque password a un salt diff√©rent
* **Salt inclus** : Pas besoin de stocker le salt s√©par√©ment
* **Auto-suffisant** : Le hash contient toute l'information n√©cessaire
* **R√©sistant** : Temps/m√©moire configurables contre les attaques

==== Transport vs Stockage
[cols="1,1,1"]
|===
|Phase |HTTP |HTTPS

|**Transport Client‚ÜíServeur**
|‚ùå Password visible en clair
|‚úÖ Password chiffr√© TLS

|**Stockage en DB**
|‚úÖ Hash Argon2 (jamais le password)
|‚úÖ Hash Argon2 (jamais le password)

|**V√©rification**
|‚úÖ Argon2.verify() s√©curis√©
|‚úÖ Argon2.verify() s√©curis√©
|===

IMPORTANT: En production, TOUJOURS utiliser HTTPS !

== Usage dans l'application

=== Backend (Deno + Hono)

[source,typescript]
----
// Dans les routes prot√©g√©es (users-routes.ts)
import { jwtMiddleware } from '../middlewares/auth.ts';
userRoutes.get('/', jwtMiddleware, userController.getAll);

// Dans les controllers (userController.ts)
import { authUtils } from '../middlewares/auth.ts';

// Login: Set cookie
async login(c: Context) {
  const result = await userService.login(email, password);
  authUtils.setCookieToken(c, result.token); // üÜï Helper centralis√©
  return c.json({ message: 'Login successful', user });
}

// Logout: Clear cookie
async logout(c: Context) {
  authUtils.clearCookieToken(c); // üÜï Helper centralis√©
  return c.json({ message: 'Logout successful' });
}

// Route prot√©g√©e: R√©cup√©rer user
async getById(c: Context) {
  const currentUser = c.get('user'); // { id, email, username }
  // currentUser est disponible gr√¢ce √† jwtMiddleware
}
----

=== Frontend (Next.js + Axios)

[source,typescript]
----
// Configuration Axios (lib/axios.ts)
import axios from 'axios';

const api = axios.create({
  baseURL: 'http://localhost:3000/api',
  withCredentials: true, // ‚ö†Ô∏è OBLIGATOIRE pour envoyer les cookies
  headers: {
    'Content-Type': 'application/json'
  }
});

// Login
await api.post('/users/login', { email, password });
// ‚Üí Navigateur re√ßoit Set-Cookie et stocke automatiquement

// Requ√™te prot√©g√©e
const response = await api.get('/users');
// ‚Üí Navigateur envoie automatiquement Cookie: access_token=JWT

// Logout
await api.post('/users/logout');
// ‚Üí Navigateur re√ßoit Set-Cookie: Max-Age=0 et supprime le cookie
----

**Configuration CORS backend (security.ts) :**
```typescript
app.use('*', cors({
  origin: 'http://localhost:3001', // Frontend URL
  credentials: true, // ‚ö†Ô∏è OBLIGATOIRE pour les cookies
}));
```

NOTE: Le frontend **ne lit jamais** le token. Tout est g√©r√© automatiquement par le navigateur.