= Service RateService - Analyse Complète (Version Optimisée avec Projections)
:toc:
:toclevels: 3

== Vue d'ensemble

Le service rateService gère le système de notation des livres dans l'API BlaBlaBook V2. Il s'occupe de la création, modification et consultation des notes attribuées aux livres par les utilisateurs, avec calcul automatique des moyennes et gestion des statistiques de notation.

Cette version optimisée intègre des projections explicites pour sélectionner uniquement les données nécessaires, améliorer les performances et garantir la sécurité en excluant les données sensibles comme les mots de passe utilisateurs.

== Fonctions principales

=== getBookRates
**Objectif:** Récupérer toutes les notes d'un livre avec statistiques
**Quand:** Utilisé pour afficher les évaluations sur la page d'un livre
**Pourquoi important:** Permet aux utilisateurs de consulter les avis communautaires et les statistiques de notation

=== createOrUpdateRate
**Objectif:** Créer une nouvelle note ou mettre à jour une note existante
**Quand:** Utilisé lorsqu'un utilisateur note ou renote un livre
**Pourquoi important:** Permet l'expression d'opinion des utilisateurs et l'enrichissement des métadonnées

=== deleteRate
**Objectif:** Supprimer définitivement une note (par son auteur uniquement)
**Quand:** Utilisé lorsqu'un utilisateur souhaite retirer sa note
**Pourquoi important:** Permet le contrôle personnel des évaluations données

== Fonctionnement du service rateService

=== Rôle de gestionnaire d'évaluations communautaires
Le service rateService fonctionne comme un système de notation collaborative :

1. **Évaluations individuelles** : Chaque utilisateur peut noter chaque livre une seule fois
2. **Système de mise à jour** : Remplacement automatique des notes existantes
3. **Statistiques temps réel** : Calcul automatique de la moyenne des notes
4. **Contrôle propriétaire** : Seul l'auteur peut supprimer sa propre note
5. **Validation stricte** : Notes limitées à l'échelle 1-5 (entiers)

=== Système de notation
Le service applique un système standardisé :
- **Échelle** : Notes de 1 à 5 (entiers uniquement)
- **Unicité** : Une note par utilisateur par livre
- **Historique** : Dates de création et mise à jour conservées
- **Statistiques** : Moyenne calculée en temps réel

=== Intégration avec EntityValidator
Le service s'appuie sur EntityValidator pour :
- **validateUser** : Confirmer l'existence de l'utilisateur notant
- **validateBook** : Confirmer l'existence du livre noté
- **Validation automatique** : Intégration transparente dans toutes les opérations

== Projections explicites

=== Optimisation de getBookRates avec SELECT ciblé

Le service utilise des projections explicites pour sélectionner uniquement les champs nécessaires, améliorant ainsi les performances et la sécurité.

**Code de projection pour les notes :**
[source,typescript]
----
const rates = await db
    .select({
        id_rate: Rate.id_rate,
        rating: Rate.rating,
        created_at: Rate.created_at,
        updated_at: Rate.updated_at,
        user_id: User.id_user,
        user_username: User.username,
        user_firstname: User.firstname,
        user_lastname: User.lastname
        // IMPORTANT: User.password est EXCLU pour la sécurité
    })
    .from(Rate)
    .innerJoin(User, eq(Rate.id_user, User.id_user))
    .where(
        and(
            eq(Rate.id_book, bookId),
            isNull(User.deleted_at)
        )
    );
----

**Code de projection pour le calcul de moyenne :**
[source,typescript]
----
const statsResult = await db
    .select({
        average_rating: avg(Rate.rating)
    })
    .from(Rate)
    .innerJoin(User, eq(Rate.id_user, User.id_user))
    .where(
        and(
            eq(Rate.id_book, bookId),
            isNull(User.deleted_at)
        )
    );
----

**Points clés de sécurité et d'optimisation :**

1. **Exclusion du password User** : Le champ `User.password` est délibérément exclu de la sélection pour éviter toute fuite de données sensibles.

2. **Filtrage des utilisateurs supprimés** : `isNull(User.deleted_at)` garantit que seules les notes d'utilisateurs actifs sont retournées et comptabilisées dans la moyenne.

3. **Calcul SQL natif** : `avg(Rate.rating)` calculé directement en SQL pour performance optimale.

4. **Requêtes séparées** : Une requête pour les notes détaillées, une pour les statistiques - optimisation de la lecture.

== Opérations détaillées

=== Consultation des notes d'un livre (getBookRates)

**Fonctionnement en mots simples :**
Cette fonction agit comme un lecteur d'avis qui compile toutes les évaluations d'un livre avec calcul automatique de la moyenne.

**Processus de récupération :**
1. **Validation du livre** : Vérification que le livre existe via EntityValidator
2. **Projection explicite pour notes** : Récupère uniquement les champs nécessaires avec INNER JOIN User
3. **Exclusion du password** : Garantit que le mot de passe utilisateur n'est jamais exposé
4. **Filtrage utilisateurs supprimés** : `isNull(User.deleted_at)` pour cohérence
5. **Calcul statistique SQL** : Requête séparée avec `avg(Rate.rating)` pour la moyenne
6. **Enrichissement des données** : Combinaison notes individuelles + statistiques globales

**Données retournées :**
- Informations complètes du livre
- Liste des notes avec détails des auteurs (sans password)
- Moyenne des notes calculée en SQL (ou null si aucune note)
- Métadonnées temporelles (created_at, updated_at)

**Calcul de moyenne optimisé :**
La moyenne est calculée directement en SQL pour une performance maximale, avec exclusion automatique des utilisateurs supprimés.

**Protection contre les utilisateurs supprimés :**
Les notes des utilisateurs supprimés sont automatiquement exclues à la fois de la liste et du calcul de moyenne pour maintenir la cohérence des statistiques.

=== Création ou mise à jour de note (createOrUpdateRate)

**Fonctionnement en mots simples :**
Cette fonction agit comme un évaluateur intelligent qui ajoute une nouvelle note ou remplace une note existante.

**Processus de gestion :**
1. **Validation de la note** : Vérification que la note est un entier entre 1 et 5
2. **Validation des entités** : Confirmation que utilisateur et livre existent
3. **Détection d'existence** : Recherche d'une note existante pour la paire utilisateur-livre
4. **Logique conditionnelle** :
   - Si note existante → Mise à jour avec nouveau `updated_at`
   - Si nouvelle note → Création avec `created_at` automatique
5. **Retour enrichi** : Indication si mise à jour ou création + données de la note

**Validation stricte de la note :**
```javascript
if (rating < 1 || rating > 5 || !Number.isInteger(rating)) {
    throw new Error('Rating must be an integer between 1 and 5.');
}
```

**Logique de création vs mise à jour :**
- **Avantages** : Une seule fonction pour les deux cas d'usage
- **Simplicité** : Interface unifiée pour l'évaluation
- **Cohérence** : Timestamps automatiquement gérés selon le contexte

**Données retournées :**
- Note créée ou mise à jour
- Indicateur `updated: true/false` pour distinction du type d'opération
- Validation préalable garantit la cohérence des données

=== Suppression de note (deleteRate)

**Fonctionnement en mots simples :**
Cette fonction agit comme un contrôleur de propriété qui permet uniquement à l'auteur de retirer sa propre évaluation.

**Processus de suppression :**
1. **Recherche de la note** : Vérification que la note existe par son ID
2. **Contrôle de propriété** : Validation que l'utilisateur demandeur est l'auteur
3. **Suppression physique** : DELETE complet (hard delete) de la note
4. **Retour conditionnel** : null si note inexistante, note supprimée sinon

**Sécurité de propriété :**
```javascript
if (existingRate[0].id_user !== userId) {
    throw new Error('You can only delete your own ratings.');
}
```

**Gestion gracieuse :**
- Retour `null` pour les notes inexistantes (pas d'exception)
- Exception uniquement pour les violations de propriété
- Suppression physique pour libérer l'espace et permettre re-notation

== Validation et contrôles qualité

=== Validation des données de notation
Le service applique des contrôles stricts :
- **Échelle obligatoire** : Notes entre 1 et 5 uniquement
- **Type de données** : Entiers uniquement (pas de décimales)
- **Entités valides** : Utilisateur et livre doivent exister
- **Propriété** : Contrôle strict pour les suppressions

=== EntityValidator integration
Le service s'appuie sur EntityValidator pour :
- **validateUser** : Confirmer l'existence de l'utilisateur évaluateur
- **validateBook** : Confirmer l'existence du livre évalué
- **Gestion cohérente** : Messages d'erreur standardisés
- **Validation automatique** : Intégration transparente

=== Gestion des utilisateurs supprimés
Le service traite automatiquement les cas edge :
- **Exclusion des calculs** : Notes des utilisateurs supprimés ignorées
- **Cohérence statistique** : Moyennes recalculées sans les comptes supprimés
- **Préservation des données** : Notes conservées pour intégrité référentielle

== Gestion des erreurs spécialisées

=== Erreurs de validation de notation
- **Note invalide** : "Rating must be an integer between 1 and 5."
- **Contrôle préalable** : Validation avant toute opération en base
- **Rejet explicite** : Échec immédiat pour les valeurs non conformes

=== Erreurs de propriété
- **Suppression refusée** : "You can only delete your own ratings."
- **Contrôle strict** : Vérification de correspondance user_id
- **Sécurité** : Protection contre les suppressions malveillantes

=== Erreurs d'entités
- **Utilisateur inexistant** : Gérée par EntityValidator
- **Livre inexistant** : Gérée par EntityValidator
- **Validation précoce** : Échec avant opérations coûteuses

=== Gestion des cas limites
- **Livre sans notes** : Moyenne retournée à `null`
- **Note inexistante** : Retour `null` pour deleteRate
- **Calculs de moyenne** : Protection contre division par zéro

== Performance et optimisation

=== Requêtes optimisées
- **Projections explicites** : `.select()` avec champs spécifiques au lieu de SELECT *
- **Exclusion sécurisée** : Password User jamais inclus dans les résultats
- **JOINs efficaces** : INNER JOIN pour les données enrichies avec User
- **Calculs SQL natifs** : `avg(Rate.rating)` calculé directement en SQL
- **Requêtes séparées** : Notes détaillées + statistiques pour optimisation
- **LIMIT pour unicité** : LIMIT 1 pour les vérifications d'existence
- **Index recommandés** : Sur (id_user, id_book) pour recherches rapides

=== Projections explicites - Avantages
1. **Performance** : Réduction du volume de données transférées
2. **Sécurité** : Exclusion garantie des champs sensibles (password)
3. **Clarté** : Documentation explicite des champs utilisés
4. **Maintenance** : Facilite les évolutions du schéma
5. **Calculs optimisés** : Moyenne calculée en SQL pour efficacité maximale

=== Gestion des statistiques
- **Calcul temps réel** : Moyenne recalculée à chaque consultation via `avg()`
- **Exclusion intelligente** : `isNull(User.deleted_at)` appliqué aux deux requêtes
- **Cohérence garantie** : Filtrage identique pour liste et moyenne
- **Performance SQL** : avg() au niveau base de données pour efficacité

=== Optimisation mémoire
- **Requêtes ciblées** : Projections explicites sans SELECT *
- **Calculs côté base** : Moyenne calculée en SQL plutôt qu'en mémoire
- **Pas de cache nécessaire** : Données de notation généralement volatiles
- **Séparation efficace** : Deux requêtes optimisées plutôt qu'une complexe

== Interaction avec d'autres services

=== Dépendances directes
- **EntityValidator** : Validation des entités utilisateur et livre
- **Database connection** : Opérations CRUD via Drizzle ORM
- **Rate model** : Structure de données des évaluations

=== Services connexes
- **bookService** : Livres évalués par le système de notation
- **userService** : Utilisateurs auteurs des évaluations
- **reviewService** : Complémentarité avec les critiques textuelles

=== Impact sur d'autres fonctionnalités
- **Recommandations** : Notes utilisées pour suggérer des livres similaires
- **Classements** : Base pour les livres les mieux notés
- **Statistiques** : Métriques de popularité et qualité perçue
- **Recherche** : Filtrage possible par note moyenne

== Exemple de flux complet

=== Scénario : Notation collaborative d'un bestseller

**Situation de départ :**
Plusieurs utilisateurs évaluent "Dune" de Frank Herbert, avec mise à jour d'une note existante.

**Traitement par le service :**
1. **Première notation** : Alice donne 5/5 à Dune
   - Validation : note entière entre 1-5 ✓
   - Pas de note existante → Création nouvelle note
   - Retour : `{rate: newRate, updated: false}`

2. **Deuxième notation** : Bob donne 4/5 à Dune
   - Création d'une deuxième note indépendante
   - Moyenne actualisée : (5+4)/2 = 4.5

3. **Modification** : Alice change sa note en 3/5
   - Note existante détectée → Mise à jour
   - Nouveau `updated_at` automatique
   - Retour : `{rate: updatedRate, updated: true}`

4. **Consultation** : Récupération des évaluations
   - Moyenne recalculée : (3+4)/2 = 3.5
   - Liste des notes avec détails utilisateurs
   - Statistiques temps réel

**Évolution des statistiques :**
- Départ : Aucune note
- Après Alice : 5.0 (1 note)
- Après Bob : 4.5 (2 notes)
- Après modification Alice : 3.5 (2 notes)

**Résultat :**
Le système maintient automatiquement des statistiques cohérentes et à jour, permettant aux futurs lecteurs d'avoir une vision d'ensemble des évaluations communautaires.

== Diagramme de séquence - Workflow RateService

[mermaid]
----
sequenceDiagram
    participant Controller
    participant RateService
    participant EntityValidator
    participant Database

    Note over Controller, Database: Exemple: Création ou mise à jour d'une note

    Controller->>RateService: createOrUpdateRate({id_user, id_book, rating: 4})
    RateService->>RateService: Validate rating (1-5, integer)

    alt Si note invalide
        RateService-->>Controller: throw Error("Rating must be an integer between 1 and 5.")
    else Note valide
        RateService->>EntityValidator: validateUser(id_user)
        EntityValidator-->>RateService: userData
        RateService->>EntityValidator: validateBook(id_book)
        EntityValidator-->>RateService: bookData

        RateService->>Database: SELECT FROM rates WHERE id_user = ? AND id_book = ? LIMIT 1
        Database-->>RateService: existingRate || []

        alt Si note existante
            RateService->>Database: UPDATE rates SET rating = ?, updated_at = NOW() WHERE id_rate = ?
            Database-->>RateService: updatedRate
            RateService-->>Controller: {rate: updatedRate, updated: true}
        else Nouvelle note
            RateService->>Database: INSERT INTO rates VALUES({id_user, id_book, rating}) RETURNING
            Database-->>RateService: newRate
            RateService-->>Controller: {rate: newRate, updated: false}
        end
    end

    Note over Controller, Database: Exemple: Consultation des notes d'un livre

    Controller->>RateService: getBookRates(bookId)
    RateService->>EntityValidator: validateBook(bookId)
    EntityValidator-->>RateService: bookData

    par Récupération des notes
        RateService->>Database: JOIN Rate + User WHERE id_book = ? AND User.deleted_at IS NULL
        Database-->>RateService: rates[]
    and Calcul de moyenne
        RateService->>Database: SELECT avg(rating) FROM Rate JOIN User WHERE id_book = ? AND User.deleted_at IS NULL
        Database-->>RateService: {average_rating: 4.2}
    end

    RateService->>RateService: Parse average to float
    RateService-->>Controller: {book, rates[], average_rating: 4.2}

    Note over Controller, Database: Exemple: Suppression d'une note

    Controller->>RateService: deleteRate(rateId, userId)
    RateService->>Database: SELECT FROM rates WHERE id_rate = ? LIMIT 1
    Database-->>RateService: existingRate || []

    alt Si note inexistante
        RateService-->>Controller: null
    else Note trouvée
        alt Si utilisateur non propriétaire
            RateService-->>Controller: throw Error("You can only delete your own ratings.")
        else Propriétaire confirmé
            RateService->>Database: DELETE FROM rates WHERE id_rate = ? RETURNING
            Database-->>RateService: deletedRate
            RateService-->>Controller: deletedRate
        end
    end
----

== Résumé

Le service rateService est le **gestionnaire d'évaluations communautaires** de l'API BlaBlaBook V2. Il gère **3 opérations principales** avec :
- **Projections explicites** : Sélection ciblée des champs avec `.select()` pour performance et sécurité
- **Exclusion du password User** : Garantie de non-exposition des mots de passe (SÉCURITÉ)
- **Filtrage des utilisateurs supprimés** : `isNull(User.deleted_at)` appliqué aux notes et à la moyenne
- **Calcul SQL natif** : `avg(Rate.rating)` calculé directement en SQL pour efficacité maximale
- **Système de notation standardisé** : Échelle 1-5 avec validation stricte (entiers uniquement)
- **Gestion unifiée** : Création et mise à jour dans une seule fonction intelligente
- **Statistiques temps réel** : Calcul automatique des moyennes avec cohérence garantie
- **Contrôle de propriété** : Suppression limitée aux auteurs des notes
- **EntityValidator** : Validation cohérente des utilisateurs et livres
- **Requêtes séparées** : Optimisation avec une requête pour les notes, une pour les statistiques
- **LIMIT pour unicité** : LIMIT 1 pour vérifications d'existence

**Il assure l'évaluation collaborative, la sécurité des données et les statistiques de qualité du catalogue de livres.**