= Sanitizer - Protection XSS Backend
:toc:
:toclevels: 2

== Vue d'ensemble

**Principe fondamental :** Never trust user input

Le sanitizer prot√®ge contre les attaques XSS (Cross-Site Scripting) en nettoyant les donn√©es utilisateur **AVANT** validation Zod.

== Architecture S√©curit√©

```
Client ‚Üí Backend
   ‚Üì
1. Parse JSON (c.req.json())
   ‚Üì
2. Sanitize (stripHtml, cleanEmail, etc.) ‚Üê sanitizer.ts
   ‚Üì
3. Validate (Zod schemas) ‚Üê validation.ts
   ‚Üì
4. ORM (Drizzle - protection SQL Injection native)
   ‚Üì
Database
```

**Couches de protection :**

[cols="2,3,2"]
|===
|Couche |Responsabilit√© |Fichier

|**Sanitization**
|Supprime HTML, nettoie format
|`utils/sanitizer.ts`

|**Validation**
|Types, longueurs, formats
|`middlewares/validation.ts`

|**ORM**
|SQL Injection (parameterized queries)
|Drizzle (natif)
|===

== API Sanitizer

=== M√©thodes Principales

==== `stripHtml(input: string)`

Supprime toutes les balises HTML.

[source,typescript]
----
Sanitizer.stripHtml("<script>alert('xss')</script>Hello")
// ‚Üí "Hello"

Sanitizer.stripHtml("Hello<b>World</b>")
// ‚Üí "HelloWorld"
----

==== `cleanEmail(email: string)`

Normalise un email (lowercase + trim).

[source,typescript]
----
Sanitizer.cleanEmail(" User@EXAMPLE.com ")
// ‚Üí "user@example.com"
----

==== `cleanUsername(username: string)`

Garde uniquement alphanum√©rique + underscore.

[source,typescript]
----
Sanitizer.cleanUsername("user<script>123")
// ‚Üí "user123"

Sanitizer.cleanUsername("user_name_2025")
// ‚Üí "user_name_2025"
----

==== `sanitizeObject<T>(obj: T)`

Sanitize r√©cursif d'un objet.

[source,typescript]
----
Sanitizer.sanitizeObject({
  name: "<script>bad</script>",
  age: 25,
  nested: { bio: "<b>text</b>" }
})
// ‚Üí {
//   name: "",
//   age: 25,
//   nested: { bio: "text" }
// }
----

=== Helper `sanitizeRequestBody()`

Fonction optimis√©e pour les requ√™tes HTTP.

[source,typescript]
----
sanitizeRequestBody({
  email: " USER@TEST.COM ",
  username: "user<script>",
  firstname: "John<b>",
  password: "Secret123!"
})
// ‚Üí {
//   email: "user@test.com",        // cleanEmail
//   username: "userscript",         // cleanUsername
//   firstname: "Johnb",             // stripHtml
//   password: "Secret123!"          // inchang√© (hash√© apr√®s)
// }
----

**Champs trait√©s automatiquement :**

* `email` ‚Üí `cleanEmail()`
* `username` ‚Üí `cleanUsername()`
* Autres strings ‚Üí `stripHtml()`

== Int√©gration Middleware

Le sanitizer est **automatiquement** appliqu√© dans `validation.ts` :

[source,typescript]
----
// middlewares/validation.ts
export function validateSchema(schema) {
  return async function(c, next) {
    const body = await c.req.json();

    // 1. Sanitize AVANT validation
    const sanitizedBody = sanitizeRequestBody(body);

    // 2. Validation Zod
    const validatedData = schema.parse(sanitizedBody);

    c.set('validatedData', validatedData);
    await next();
  };
}
----

**Flow automatique :**

```
POST /api/users (email: " USER@TEST.COM ", username: "user<bad>")
   ‚Üì
validation middleware
   ‚Üì
sanitizeRequestBody()
   ‚Üí email: "user@test.com"
   ‚Üí username: "userbad"
   ‚Üì
Zod validation
   ‚Üí Types OK
   ‚Üì
Controller re√ßoit validatedData propre
```

== Exemples d'Attaques Bloqu√©es

=== Attaque 1 : XSS dans username

**Payload malveillant :**
[source,json]
----
{
  "username": "user<script>alert('xss')</script>",
  "email": "test@test.com",
  "password": "Test1234!"
}
----

**Apr√®s sanitization :**
[source,json]
----
{
  "username": "userscriptalertxssscript",
  "email": "test@test.com",
  "password": "Test1234!"
}
----

**R√©sultat :** Script supprim√©, attaque neutralis√©e.

=== Attaque 2 : HTML injection dans description

**Payload malveillant :**
[source,json]
----
{
  "lib_name": "Ma biblioth√®que",
  "description": "Livres pr√©f√©r√©s<iframe src='evil.com'></iframe>"
}
----

**Apr√®s sanitization :**
[source,json]
----
{
  "lib_name": "Ma biblioth√®que",
  "description": "Livres pr√©f√©r√©s"
}
----

**R√©sultat :** iframe supprim√©.

=== Attaque 3 : SQL Injection (d√©j√† prot√©g√© par Drizzle)

**Payload malveillant :**
[source,json]
----
{
  "email": "test@test.com' OR '1'='1"
}
----

**Protection Drizzle :**
```sql
-- Drizzle g√©n√®re automatiquement:
SELECT * FROM users WHERE email = $1
-- Param√®tre: "test@test.com' OR '1'='1" (trait√© comme string)
```

**R√©sultat :** Aucun risque SQL Injection avec Drizzle ORM.

== Pourquoi Backend ET Frontend ?

[cols="2,3,3"]
|===
|Aspect |Frontend Sanitization |Backend Sanitization

|**Objectif**
|UX (feedback rapide)
|S√©curit√© r√©elle

|**Bypassable**
|‚úÖ Oui (curl, Postman)
|‚ùå Non

|**N√©cessit√©**
|Optionnel (confort)
|**OBLIGATOIRE**

|**Exemple**
|Erreur avant envoi
|Protection serveur
|===

**R√®gle d'or :**

> Frontend = UX
> Backend = S√©curit√©

Le backend **DOIT** toujours valider, m√™me si le frontend valide d√©j√†.

== Tests

=== Test Manuel

[source,bash]
----
# Tester XSS username
curl -X POST http://localhost:3000/api/users \
  -H "Content-Type: application/json" \
  -d '{
    "username": "user<script>alert(1)</script>",
    "email": "test@test.com",
    "password": "Test1234!",
    "firstname": "Test",
    "lastname": "User"
  }'

# R√©sultat attendu: username enregistr√© comme "userscriptalert1script"
----

=== Test E2E

Le sanitizer est test√© automatiquement via :

[source,bash]
----
deno test --allow-net --allow-env tests/cookie-auth.test.ts
----

== Performance

**Impact sanitization :**

* `stripHtml()` : ~0.01ms par string
* `sanitizeRequestBody()` : ~0.05ms par objet

**N√©gligeable** compar√© au temps de r√©ponse global (DB queries, etc.).

== Limitations

=== Ce que le sanitizer NE fait PAS

* ‚ùå **Validation m√©tier** : C'est le r√¥le de Zod (email valide, longueur, etc.)
* ‚ùå **Protection SQL Injection** : C'est le r√¥le de Drizzle ORM (d√©j√† prot√©g√©)
* ‚ùå **Rate limiting** : C'est le r√¥le du middleware security.ts
* ‚ùå **CSRF protection** : C'est le r√¥le du middleware csrf.ts

=== Ce que le sanitizer FAIT

* ‚úÖ **Supprime HTML** : Balises `<script>`, `<iframe>`, etc.
* ‚úÖ **Normalise formats** : Email lowercase, username alphanum
* ‚úÖ **Trim espaces** : D√©but/fin de strings

== Maintenance

=== Ajouter un nouveau champ √† sanitize

[source,typescript]
----
// Dans sanitizeRequestBody()
export function sanitizeRequestBody(data: Record<string, any>) {
  const result: Record<string, any> = {};

  for (const key in data) {
    const value = data[key];

    // Email
    if (key === 'email' && typeof value === 'string') {
      result[key] = Sanitizer.cleanEmail(value);
    }
    // Username
    else if (key === 'username' && typeof value === 'string') {
      result[key] = Sanitizer.cleanUsername(value);
    }
    // üÜï Ajouter ici pour nouveau champ sp√©cifique
    else if (key === 'phone' && typeof value === 'string') {
      result[key] = value.replace(/[^0-9+]/g, ''); // Exemple t√©l√©phone
    }
    // Fallback: stripHtml pour toutes les strings
    else if (typeof value === 'string') {
      result[key] = Sanitizer.stripHtml(value);
    }
    else {
      result[key] = value;
    }
  }

  return result;
}
----

== R√©sum√©

[cols="2,3"]
|===
|Question |R√©ponse

|**Pourquoi sanitizer backend ?**
|Frontend bypassable, backend = s√©curit√© r√©elle

|**Quelle protection ?**
|XSS (HTML malveillant)

|**SQL Injection ?**
|D√©j√† prot√©g√© par Drizzle ORM

|**O√π est-il appliqu√© ?**
|Automatiquement dans `validation.ts`

|**Impact performance ?**
|N√©gligeable (~0.05ms)

|**Obligatoire ?**
|‚úÖ OUI - R√®gle OWASP
|===

---

_Document cr√©√©: {docdate}_
_Version: 1.0_
_Projet: BlaBlaBook V2_