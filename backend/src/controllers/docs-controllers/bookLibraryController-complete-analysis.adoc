= Controller BookLibraryController - Analyse Complète
:toc:
:toclevels: 3

== Vue d'ensemble

Le controller bookLibraryController constitue la couche de présentation pour la gestion des collections personnelles de livres dans l'API BlaBlaBook V2. Il expose des endpoints HTTP RESTful pour consulter, ajouter, supprimer des livres dans les bibliothèques utilisateurs et propose un workflow avancé d'ajout simultané aux bibliothèques et listes de lecture.

== Architecture du controller

=== Rôle dans l'architecture de collections personnelles
Le controller bookLibraryController agit comme l'interface HTTP pour la gestion des bibliothèques :

1. **Consultation sécurisée** : Accès aux bibliothèques avec contrôle des permissions
2. **Gestion des collections** : Ajout et suppression de livres dans les bibliothèques
3. **Workflow avancé** : Ajout simultané livre + organisation en listes
4. **Validation stricte** : Contrôles des champs obligatoires et permissions
5. **Intégration cross-service** : Coordination bibliothèques + listes de lecture

=== Design pattern de validation complète
Le controller applique une validation exhaustive sur tous les endpoints :
- **Paramètres obligatoires** : Vérification systématique des champs requis
- **Types de données** : Validation des booléens et structures attendues
- **Messages enrichis** : Réponses avec feedback explicite d'action
- **Codes de statut appropriés** : 201 pour créations, 200 pour consultations

== Endpoints disponibles

=== GET /libraries/:id/books - getLibraryBooks()
**Objectif:** Récupérer tous les livres d'une bibliothèque avec contrôle d'accès
**Méthode HTTP:** GET
**Paramètres:**
- `id` (URL parameter) : Identifiant de la bibliothèque
- `user_id` (query parameter, obligatoire) : Identifiant de l'utilisateur demandeur

**Flux de traitement sécurisé :**
1. Extraction de `libraryId` et `userId`
2. **Validation du paramètre obligatoire** : Vérification présence de user_id
3. Appel à `bookLibraryService.getLibraryBooks(libraryId, userId)`
4. Retour JSON avec contrôle d'accès appliqué côté service

**Code avec validation :**
```typescript
async getLibraryBooks(c: Context) {
    const libraryId = c.req.param('id');
    const userId = c.req.query('user_id');

    if (!userId) {
        throw new Error('user_id query parameter is required.');
    }

    const result = await bookLibraryService.getLibraryBooks(libraryId, userId);
    return c.json(result);
}
```

**Exemple d'utilisation :**
```http
GET /libraries/550e8400-e29b-41d4-a716-446655440000/books?user_id=550e8400-e29b-41d4-a716-446655440001
```

**Réponse type :**
```json
{
  "library": {
    "id_library": "550e8400...",
    "lib_name": "Ma collection SF",
    "description": "Mes livres de science-fiction préférés",
    "is_public": true,
    "is_system": false
  },
  "books": [
    {
      "id_book": "book_123",
      "title": "Dune",
      "isbn": "9780441172719",
      "created_at": "2024-01-15T14:30:00Z"
    }
  ],
  "total_books": 1
}
```

**Sécurité implémentée :**
- **user_id obligatoire** : Identification de l'utilisateur demandeur
- **Contrôle d'accès côté service** : Validation des permissions lecture
- **Bibliothèques publiques** : Accès autorisé pour tous
- **Bibliothèques privées** : Accès restreint au propriétaire

=== POST /libraries/books - addBookToLibrary()
**Objectif:** Ajouter un livre à une bibliothèque spécifique
**Méthode HTTP:** POST
**Body JSON requis:**
```json
{
  "id_book": "uuid-du-livre",
  "id_library": "uuid-de-la-bibliotheque",
  "user_id": "uuid-de-l-utilisateur"
}
```

**Flux de traitement avec validation :**
1. Parsing du body JSON via `c.req.json()`
2. **Validation des champs obligatoires** : Vérification des 3 champs requis
3. Appel à `bookLibraryService.addBookToLibrary(data)`
4. Retour JSON enrichi avec message de succès et code 201

**Code avec validation complète :**
```typescript
async addBookToLibrary(c: Context) {
    const data = await c.req.json();

    if (!data.id_book || !data.id_library || !data.user_id) {
        throw new Error('id_book, id_library, and user_id are required.');
    }

    const result = await bookLibraryService.addBookToLibrary(data);
    return c.json({
        message: 'Book added to library successfully.',
        ...result
    }, 201);
}
```

**Réponse de succès :**
```json
{
  "message": "Book added to library successfully.",
  "book_library": {
    "id_book_library": "assoc_456",
    "id_book": "550e8400...",
    "id_library": "550e8400...",
    "created_at": "2024-01-20T16:45:00Z"
  },
  "book": {
    "id_book": "550e8400...",
    "title": "Foundation",
    ...
  },
  "library": {
    "id_library": "550e8400...",
    "lib_name": "Ma collection SF",
    ...
  }
}
```

**Codes de réponse :**
- `201` : Livre ajouté avec succès
- `400` : Champs obligatoires manquants
- `404` : Livre ou bibliothèque non trouvé
- `403` : Accès refusé à la bibliothèque
- `409` : Livre déjà dans la bibliothèque

=== DELETE /libraries/books - removeBookFromLibrary()
**Objectif:** Supprimer un livre d'une bibliothèque
**Méthode HTTP:** DELETE
**Body JSON requis:**
```json
{
  "id_book": "uuid-du-livre",
  "id_library": "uuid-de-la-bibliotheque",
  "user_id": "uuid-de-l-utilisateur"
}
```

**Flux de traitement sécurisé :**
1. Parsing du body JSON
2. **Validation des champs obligatoires** : Même validation que l'ajout
3. Appel à `bookLibraryService.removeBookFromLibrary(data)`
4. Retour JSON avec message de confirmation

**Code avec validation :**
```typescript
async removeBookFromLibrary(c: Context) {
    const data = await c.req.json();

    if (!data.id_book || !data.id_library || !data.user_id) {
        throw new Error('id_book, id_library, and user_id are required.');
    }

    const result = await bookLibraryService.removeBookFromLibrary(data);
    return c.json({
        message: 'Book removed from library successfully.',
        ...result
    });
}
```

**Protections appliquées :**
- **Propriété de la bibliothèque** : Seul le propriétaire peut supprimer
- **Bibliothèques système** : Protection contre vidage des bibliothèques essentielles
- **Existence de l'association** : Vérification que le livre est bien dans la bibliothèque

=== POST /libraries/books/with-lists - addBookWithLists()
**Objectif:** Workflow avancé d'ajout livre + organisation optionnelle en listes
**Méthode HTTP:** POST
**Body JSON requis:**
```json
{
  "id_book": "uuid-du-livre",
  "user_id": "uuid-de-l-utilisateur",
  "is_private": true,
  "reading_list_ids": ["uuid-liste-1", "uuid-liste-2"]
}
```

**Flux de traitement complexe :**
1. Parsing et validation avec **contrôle de type booléen**
2. Préparation des données avec valeur par défaut pour reading_list_ids
3. Appel au **workflow orchestré** `bookLibraryService.addBookWithOptionalLists()`
4. Retour JSON du résultat complet avec code 201

**Code avec validation de types :**
```typescript
async addBookWithLists(c: Context) {
    const data = await c.req.json();

    if (!data.id_book || !data.user_id || typeof data.is_private !== 'boolean') {
        throw new Error('id_book, user_id, and is_private are required.');
    }

    const result = await bookLibraryService.addBookWithOptionalLists({
        id_book: data.id_book,
        user_id: data.user_id,
        is_private: data.is_private,
        reading_list_ids: data.reading_list_ids || []
    });

    return c.json({
        message: 'Book added successfully.',
        ...result
    }, 201);
}
```

**Validations spécialisées :**
- **is_private obligatoire** : Doit être un booléen (true/false)
- **reading_list_ids optionnel** : Tableau d'IDs ou tableau vide par défaut
- **Type checking strict** : `typeof data.is_private !== 'boolean'`

**Exemple d'utilisation :**
```http
POST /libraries/books/with-lists
Content-Type: application/json

{
  "id_book": "550e8400-e29b-41d4-a716-446655440000",
  "user_id": "550e8400-e29b-41d4-a716-446655440001",
  "is_private": false,
  "reading_list_ids": [
    "550e8400-e29b-41d4-a716-446655440002",
    "550e8400-e29b-41d4-a716-446655440003"
  ]
}
```

**Réponse du workflow complet :**
```json
{
  "message": "Book added successfully.",
  "book_library": {
    "id_book_library": "assoc_789",
    "id_book": "550e8400...",
    "id_library": "library_a_partager_123",
    "created_at": "2024-01-20T18:00:00Z"
  },
  "added_to_lists": [
    {
      "reading_list_book": {
        "id_book_list": "list_assoc_001",
        "id_book": "550e8400...",
        "id_list": "550e8400...002",
        "created_at": "2024-01-20T18:00:01Z"
      },
      "reading_list": {
        "id_list": "550e8400...002",
        "list_name": "À lire",
        ...
      }
    }
  ],
  "target_library": {
    "id_library": "library_a_partager_123",
    "lib_name": "À partager",
    "is_system": true,
    "is_public": false
  }
}
```

**Workflow orchestré :**
1. **Étape principale** : Ajout à la bibliothèque système appropriée
2. **Étape secondaire** : Ajout optionnel aux listes spécifiées
3. **Gestion des échecs** : Échecs de listes n'annulent pas l'ajout principal
4. **Retour détaillé** : Rapport complet des opérations réussies

== Patterns de conception

=== Validation exhaustive centralisée
Tous les endpoints appliquent le même pattern de validation :

```typescript
// Pattern de validation standard
const data = await c.req.json();
if (!requiredField1 || !requiredField2 || !requiredField3) {
    throw new Error('field1, field2, and field3 are required.');
}
```

**Avantages de l'uniformité :**
- **Prédictibilité** : Même comportement sur tous les endpoints
- **Maintenance** : Pattern répétable et évolutif
- **Documentation** : Messages d'erreur cohérents pour l'API
- **Tests** : Validation testable de manière systématique

=== Enrichissement des réponses
```typescript
// Ajout de messages de succès explicites
return c.json({
    message: 'Operation completed successfully.',
    ...result
}, statusCode);
```

**Bénéfices UX :**
- **Feedback clair** : Confirmation explicite des actions
- **Débogage facilité** : Messages standardisés pour développeurs
- **API documentée** : Réponses prévisibles pour intégration
- **Cohérence système** : Même format que autres controllers

=== Gestion des paramètres optionnels
```typescript
// Valeurs par défaut pour paramètres optionnels
reading_list_ids: data.reading_list_ids || []
```

## Sécurité et contrôle d'accès

=== Validation des permissions déléguée
```typescript
// Controller valide les champs, service valide les permissions
if (!userId) {
    throw new Error('user_id query parameter is required.');
}
const result = await bookLibraryService.getLibraryBooks(libraryId, userId);
```

**Niveaux de sécurité :**
1. **Controller** : Vérification présence des paramètres d'identification
2. **Service** : Validation des droits d'accès et propriété
3. **EntityValidator** : Existence des entités et règles métier
4. **Database** : Contraintes d'intégrité référentielle

=== Audit trail automatique
- **user_id obligatoire** : Traçabilité de toutes les opérations
- **created_at automatique** : Horodatage des ajouts
- **IDs d'association** : Identifiants uniques pour audit
- **Données d'association** : Conservation des liens pour historique

=== Protection des bibliothèques système
- **Validation côté service** : Impossible de vider les bibliothèques système
- **Règles métier** : "Bibliothèque privée" et "À partager" protégées
- **Workflow intelligent** : Sélection automatique de la bibliothèque appropriée
- **Restrictions d'accès** : Permissions différenciées par type de bibliothèque

== Gestion d'erreurs et codes de statut

=== Hiérarchie d'erreurs par criticité

**Erreurs de validation (400) :**
```typescript
// Champs obligatoires manquants
if (!data.id_book || !data.id_library || !data.user_id) {
    throw new Error('id_book, id_library, and user_id are required.');
}

// Type de données incorrect
if (typeof data.is_private !== 'boolean') {
    throw new Error('is_private must be a boolean.');
}
```

**Erreurs métier (403, 404, 409) :**
- Délégation au service pour gestion des règles complexes
- EntityValidator pour existence des entités
- Contraintes d'intégrité pour doublons

**Erreurs système (500) :**
- Propagation transparente via middlewares globaux
- Logging automatique pour debugging
- Messages génériques pour protection des détails internes

=== Codes de statut appropriés

[cols="1,1,1"]
|===
|Code |Endpoint |Situation

|200
|getLibraryBooks
|Consultation réussie

|201
|addBookToLibrary, addBookWithLists
|Création d'association

|400
|Tous
|Champs obligatoires manquants

|403
|Tous (via service)
|Accès refusé à la bibliothèque

|404
|Tous (via service)
|Livre, bibliothèque ou liste non trouvé

|409
|add* (via service)
|Livre déjà dans la bibliothèque
|===

== Workflow avancé : addBookWithLists

=== Orchestration cross-service
```typescript
// Coordination bibliothèque + listes de lecture
const result = await bookLibraryService.addBookWithOptionalLists({
    id_book: data.id_book,
    user_id: data.user_id,
    is_private: data.is_private,
    reading_list_ids: data.reading_list_ids || []
});
```

**Avantages du workflow orchestré :**
- **Atomicité partielle** : Ajout bibliothèque garanti, listes optionnelles
- **UX optimisée** : Une seule requête pour organisation complète
- **Gestion d'erreurs intelligente** : Échecs de listes n'annulent pas l'opération
- **Rapport détaillé** : Retour des succès et échecs pour feedback utilisateur

=== Stratégie de résilience
```mermaid
graph TD
    A[Ajout livre à bibliothèque] --> B{Succès ?}
    B -->|Oui| C[Ajout aux listes optionnelles]
    B -->|Non| D[Échec complet]

    C --> E[Pour chaque liste]
    E --> F{Ajout réussi ?}
    F -->|Oui| G[Ajouter au rapport succès]
    F -->|Non| H[Logger l'erreur, continuer]

    G --> I[Retour rapport complet]
    H --> I
    D --> J[Erreur propagée]
```

**Bénéfices de la résilience :**
- **Expérience utilisateur** : Succès partiel plutôt qu'échec total
- **Feedback détaillé** : Rapport de ce qui a fonctionné
- **Debugging facilité** : Logs des échecs individuels
- **Performance** : Pas d'interruption pour échecs mineurs

== Exemple de flux complet

=== Scénario : Ajout d'un livre avec organisation complète

**1. Ajout avec workflow complet :**
```http
POST /libraries/books/with-lists
Content-Type: application/json

{
  "id_book": "dune-uuid",
  "user_id": "alice-uuid",
  "is_private": false,
  "reading_list_ids": [
    "sf-classics-uuid",
    "to-read-uuid",
    "invalid-list-uuid"
  ]
}
```

**2. Traitement orchestré :**
- ✅ Ajout à bibliothèque "À partager" (is_private: false)
- ✅ Ajout à liste "SF Classics"
- ✅ Ajout à liste "To Read"
- ❌ Échec liste "invalid-list-uuid" (loggé, ignoré)

**3. Réponse détaillée :**
```json
{
  "message": "Book added successfully.",
  "book_library": {"id_book_library": "...", ...},
  "added_to_lists": [
    {"reading_list": {"list_name": "SF Classics"}, ...},
    {"reading_list": {"list_name": "To Read"}, ...}
  ],
  "target_library": {"lib_name": "À partager", "is_system": true}
}
```

**4. Vérification du résultat :**
```http
GET /libraries/a-partager-uuid/books?user_id=alice-uuid
```

**Livre visible dans la bibliothèque partagée avec traçabilité complète.**

== Diagramme de séquence - Workflow addBookWithLists

[mermaid]
----
sequenceDiagram
    participant Client
    participant BookLibraryController
    participant BookLibraryService
    participant BookReadingListService
    participant EntityValidator
    participant Database

    Note over Client, Database: POST /libraries/books/with-lists

    Client->>BookLibraryController: POST {id_book, user_id, is_private: false, reading_list_ids: []}
    BookLibraryController->>BookLibraryController: Parse JSON + validate required fields

    alt Si validation échoue
        BookLibraryController-->>Client: 400 "Required fields missing"
    else Validation réussie
        BookLibraryController->>BookLibraryService: addBookWithOptionalLists(data)

        Note over BookLibraryService: ÉTAPE 1 - Ajout à bibliothèque

        BookLibraryService->>BookLibraryService: _getSystemLibrary(userId, false)
        BookLibraryService->>Database: SELECT system libraries WHERE id_user = userId
        Database-->>BookLibraryService: systemLibraries[]
        BookLibraryService->>BookLibraryService: Find "À partager" library

        BookLibraryService->>BookLibraryService: addBookToLibrary({id_book, id_library: "À partager", user_id})
        BookLibraryService->>EntityValidator: validateBook + validateLibrary + validateAccess
        BookLibraryService->>Database: INSERT INTO book_library VALUES(...) RETURNING
        Database-->>BookLibraryService: bookLibraryAssociation

        Note over BookLibraryService: ÉTAPE 2 - Ajout aux listes optionnelles

        loop Pour chaque reading_list_id
            BookLibraryService->>BookReadingListService: addBookToList({id_book, id_list, user_id})

            alt Si ajout réussi
                BookReadingListService-->>BookLibraryService: listAssociation
                BookLibraryService->>BookLibraryService: Add to addedToLists[]
            else Si ajout échoue
                BookReadingListService-->>BookLibraryService: throw Error
                BookLibraryService->>BookLibraryService: console.error + continue
            end
        end

        BookLibraryService-->>BookLibraryController: {book_library, added_to_lists[], target_library}
        BookLibraryController->>BookLibraryController: Add success message
        BookLibraryController-->>Client: 201 {message: "Book added...", ...result}
    end
----

== Tests et validation

=== Points de test critiques

**Validation des champs :**
- Champs obligatoires manquants (400)
- Types de données incorrects (is_private non booléen)
- Paramètres query manquants (user_id)

**Workflow addBookWithLists :**
- Ajout réussi avec toutes les listes
- Ajout avec échecs partiels de listes
- Gestion des bibliothèques système

**Sécurité et permissions :**
- Accès aux bibliothèques publiques vs privées
- Tentatives d'ajout à bibliothèques non possédées
- Protection contre vidage des bibliothèques système

=== Tests d'intégration
- Workflow complet d'organisation de livres
- Cohérence entre bibliothèques et listes
- Performance avec grandes collections

== Résumé

Le controller bookLibraryController est l'**interface HTTP pour la gestion des collections personnelles** de l'API BlaBlaBook V2. Il expose **4 endpoints spécialisés** avec :

- **Validation exhaustive** : Contrôles stricts des champs obligatoires et types
- **Sécurité par délégation** : Contrôle d'accès géré par le service
- **Workflow orchestré** : Ajout simultané bibliothèque + listes avec résilience
- **Enrichissement UX** : Messages de succès explicites et rapport détaillé
- **Gestion d'erreurs graduée** : Codes de statut appropriés selon la criticité
- **Audit trail complet** : Traçabilité avec user_id obligatoire
- **Type safety** : Validation des booléens et structures de données

**Il coordonne la gestion des collections personnelles avec une approche user-centric sécurisée.**