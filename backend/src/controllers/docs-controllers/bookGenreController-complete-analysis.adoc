= Controller BookGenreController - Analyse Complète
:toc:
:toclevels: 3

== Vue d'ensemble

Le controller bookGenreController constitue la couche de présentation pour la gestion des associations entre livres et genres littéraires dans l'API BlaBlaBook V2. Il expose des endpoints HTTP RESTful pour consulter, assigner et naviguer dans les relations livre-genre, facilitant la catégorisation et la découverte thématique de contenu.

== Architecture du controller

=== Rôle dans l'architecture de catégorisation
Le controller bookGenreController agit comme l'interface HTTP pour la classification littéraire :

1. **Navigation livre → genres** : Consultation des catégories d'un livre
2. **Navigation genre → livres** : Exploration des livres d'une catégorie avec pagination
3. **Assignation contrôlée** : Attribution de genres aux livres avec validation
4. **Gestion de la pagination** : Contrôle des grandes collections par genre
5. **Validation d'entrée** : Contrôles de base des champs obligatoires

=== Design pattern mixte : simple + validation
Le controller combine simplicité et validation nécessaire :
- **Endpoints de consultation** : Délégation pure comme authorBookController
- **Endpoint d'assignation** : Validation des champs obligatoires
- **Gestion de pagination** : Parsing des paramètres avec valeurs par défaut
- **Messages de succès** : Enrichissement des réponses de création

== Endpoints disponibles

=== GET /books/:id/genres - getBookGenres()
**Objectif:** Récupérer tous les genres d'un livre spécifique
**Méthode HTTP:** GET
**Paramètres:**
- `id` (URL parameter) : Identifiant du livre

**Flux de traitement simple :**
1. Extraction de `bookId` via `c.req.param('id')`
2. Appel direct à `bookGenreService.getBookGenres(bookId)`
3. Retour JSON immédiat sans transformation

**Code complet :**
```typescript
async getBookGenres(c: Context) {
    const bookId = c.req.param('id');
    const result = await bookGenreService.getBookGenres(bookId);
    return c.json(result);
}
```

**Exemple d'utilisation :**
```http
GET /books/550e8400-e29b-41d4-a716-446655440000/genres
```

**Réponse type :**
```json
{
  "book": {
    "id_book": "550e8400...",
    "title": "Dune",
    "isbn": "9780441172719",
    ...
  },
  "genres": [
    {
      "id_book_genre": "assoc_123",
      "created_at": "2024-01-15T10:30:00Z",
      "genre": {
        "id_genre": "genre_456",
        "genre_name": "Science Fiction",
        "description": "Literature that deals with futuristic concepts",
        "created_at": "2024-01-01T12:00:00Z"
      }
    },
    {
      "id_book_genre": "assoc_124",
      "created_at": "2024-01-15T10:30:00Z",
      "genre": {
        "id_genre": "genre_789",
        "genre_name": "Space Opera",
        "description": "Subgenre of science fiction",
        "created_at": "2024-01-01T12:05:00Z"
      }
    }
  ],
  "total_genres": 2
}
```

**Données enrichies retournées :**
- **Informations complètes du livre** : Métadonnées du livre catégorisé
- **Genres triés alphabétiquement** : Classement par nom pour lisibilité
- **Métadonnées d'association** : Date d'assignation, ID de liaison
- **Descriptions de genres** : Contexte pour compréhension des catégories

=== GET /genres/:id/books - getGenreBooks()
**Objectif:** Récupérer tous les livres d'un genre avec pagination
**Méthode HTTP:** GET
**Paramètres:**
- `id` (URL parameter) : Identifiant du genre
- `page` (query parameter, optionnel) : Numéro de page (défaut: 1)
- `limit` (query parameter, optionnel) : Nombre de livres par page (défaut: 20)

**Flux de traitement avec pagination :**
1. Extraction de `genreId` via `c.req.param('id')`
2. Parsing des paramètres de pagination avec valeurs par défaut
3. Appel à `bookGenreService.getGenreBooks(genreId, page, limit)`
4. Retour JSON avec métadonnées de pagination

**Code avec gestion de pagination :**
```typescript
async getGenreBooks(c: Context) {
    const genreId: string = c.req.param('id');
    const page: number = parseInt(c.req.query('page') || '1');
    const limit: number = parseInt(c.req.query('limit') || '20');

    const result = await bookGenreService.getGenreBooks(genreId, page, limit);
    return c.json(result);
}
```

**Exemples d'utilisation :**
```http
GET /genres/550e8400-e29b-41d4-a716-446655440001/books
GET /genres/550e8400-e29b-41d4-a716-446655440001/books?page=2
GET /genres/550e8400-e29b-41d4-a716-446655440001/books?page=1&limit=50
```

**Réponse type avec pagination :**
```json
{
  "genre": {
    "id_genre": "550e8400...",
    "genre_name": "Science Fiction",
    "description": "Literature that deals with futuristic concepts",
    "created_at": "2024-01-01T12:00:00Z"
  },
  "books": [
    {
      "id_book_genre": "assoc_201",
      "created_at": "2024-01-15T14:20:00Z",
      "book": {
        "id_book": "book_301",
        "title": "Foundation",
        "isbn": "9780553293357",
        "summary": "...",
        "nb_pages": 244,
        "publication_year": 1951,
        "language": "en",
        "image": "https://...",
        "metadata": {...},
        "created_at": "2024-01-10T16:45:00Z"
      }
    }
  ],
  "pagination": {
    "current_page": 1,
    "total_pages": 8,
    "total_books": 156,
    "books_per_page": 20
  }
}
```

**Avantages de la pagination :**
- **Performance** : Évite le chargement de milliers de livres d'un genre populaire
- **UX optimisée** : Navigation par pages pour grandes collections
- **Flexibilité** : Paramètres configurables selon le contexte d'affichage
- **Métadonnées complètes** : Informations pour construire interface de navigation

=== POST /books/genres/assign - assign()
**Objectif:** Assigner un genre à un livre avec validation
**Méthode HTTP:** POST
**Body JSON requis:**
```json
{
  "id_book": "uuid-du-livre",
  "id_genre": "uuid-du-genre",
  "user_id": "uuid-de-l-utilisateur"
}
```

**Flux de traitement avec validation :**
1. Parsing du body JSON via `c.req.json()`
2. **Validation des champs obligatoires** : Vérification des 3 champs requis
3. Appel à `bookGenreService.assign(data)`
4. Retour JSON enrichi avec message de succès et code 201

**Code avec validation d'entrée :**
```typescript
async assign(c: Context) {
    const data = await c.req.json();

    if (!data.id_book || !data.id_genre || !data.user_id) {
        throw new Error('id_book, id_genre, and user_id are required.');
    }

    const result = await bookGenreService.assign(data);
    return c.json({
        message: 'Genre assigned to book successfully.',
        ...result
    }, 201);
}
```

**Validations appliquées :**
- **id_book obligatoire** : Livre à catégoriser
- **id_genre obligatoire** : Genre à assigner
- **user_id obligatoire** : Utilisateur effectuant l'assignation (audit)

**Exemple d'utilisation :**
```http
POST /books/genres/assign
Content-Type: application/json

{
  "id_book": "550e8400-e29b-41d4-a716-446655440000",
  "id_genre": "550e8400-e29b-41d4-a716-446655440001",
  "user_id": "550e8400-e29b-41d4-a716-446655440002"
}
```

**Réponse de succès :**
```json
{
  "message": "Genre assigned to book successfully.",
  "book_genre": {
    "id_book_genre": "assoc_new_123",
    "id_book": "550e8400...",
    "id_genre": "550e8400...",
    "created_at": "2024-01-20T15:30:00Z"
  },
  "book": {
    "id_book": "550e8400...",
    "title": "Neuromancer",
    ...
  },
  "genre": {
    "id_genre": "550e8400...",
    "genre_name": "Cyberpunk",
    "description": "Subgenre of science fiction",
    ...
  }
}
```

**Codes de réponse :**
- `201` : Assignation créée avec succès
- `400` : Champs obligatoires manquants
- `404` : Livre ou genre non trouvé
- `409` : Association déjà existante (doublon)

== Patterns de conception

=== Architecture hybride : simple + contrôles
Le controller combine deux approches selon la criticité :

**Endpoints de consultation (simple) :**
```typescript
// Pattern de délégation pure
const id = c.req.param('id');
const result = await service.method(id);
return c.json(result);
```

**Endpoint d'assignation (contrôlé) :**
```typescript
// Pattern avec validation + enrichissement
const data = await c.req.json();
validateRequiredFields(data);
const result = await service.assign(data);
return enrichedResponse(result, 201);
```

**Avantages de l'approche hybride :**
- **Performance optimale** : Consultation sans overhead
- **Sécurité appropriée** : Validation sur opérations critiques
- **UX enrichie** : Messages de succès explicites
- **Cohérence** : Même format de réponse enrichi

=== Gestion de pagination intelligente
```typescript
// Parsing sécurisé avec valeurs par défaut
const page: number = parseInt(c.req.query('page') || '1');
const limit: number = parseInt(c.req.query('limit') || '20');
```

**Avantages du parsing :**
- **Type safety** : Conversion explicite en number
- **Valeurs par défaut** : Gestion gracieuse des paramètres omis
- **Limites raisonnables** : 20 livres par défaut pour équilibrer UX/performance
- **Flexibilité** : Client peut ajuster selon ses besoins

== Gestion des erreurs stratifiée

=== Validation côté controller
```typescript
// Validation explicite des champs critiques
if (!data.id_book || !data.id_genre || !data.user_id) {
    throw new Error('id_book, id_genre, and user_id are required.');
}
```

**Justification de la validation controller :**
- **Sécurité** : Échec rapide avant appel service coûteux
- **Clarté** : Message d'erreur explicite sur les champs manquants
- **Performance** : Évite round-trip service + base de données
- **Audit** : user_id requis pour traçabilité des assignations

=== Délégation pour logique métier
- **Existence des entités** : Validation livre/genre par le service
- **Prévention des doublons** : Contrôle des associations existantes
- **Permissions d'accès** : Vérification des droits utilisateur
- **Contraintes d'intégrité** : Gestion des règles métier complexes

=== Codes de réponse appropriés
- **200** : Consultation réussie (même si liste vide)
- **201** : Création d'association réussie
- **400** : Erreur de validation des champs obligatoires
- **404** : Entité non trouvée (livre, genre)
- **409** : Conflit (association déjà existante)

== Performance et optimisation

=== Pagination native
```typescript
// Délégation de la pagination au service
const result = await bookGenreService.getGenreBooks(genreId, page, limit);
```

**Optimisations automatiques :**
- **LIMIT/OFFSET** : Pagination au niveau base de données
- **Comptage efficace** : Requête séparée pour total_books
- **Tri côté base** : ORDER BY title pour cohérence
- **Métadonnées calculées** : total_pages = ceil(total_books/limit)

=== Gestion mémoire optimisée
- **Pas de transformation** : Données service → JSON directement
- **Pagination obligatoire** : Évite le chargement de grandes collections
- **Parsing minimal** : Seulement les paramètres utilisés
- **Réponses streamées** : JSON généré à la volée

== Interaction avec bookGenreService

=== Mapping fonctionnel cohérent
```typescript
// Controller → Service (fonctions spécialisées)
getBookGenres(bookId) → bookGenreService.getBookGenres(bookId)
getGenreBooks(genreId, page, limit) → bookGenreService.getGenreBooks(genreId, page, limit)
assign(data) → bookGenreService.assign(data)
```

=== Enrichissement des réponses
```typescript
// Endpoint d'assignation - Message de succès ajouté
return c.json({
    message: 'Genre assigned to book successfully.',
    ...result
}, 201);
```

**Justification de l'enrichissement :**
- **UX améliorée** : Feedback explicite de l'action réussie
- **Cohérence** : Même pattern que d'autres controllers de modification
- **API documentation** : Messages standardisés pour développeurs
- **Debug facilité** : Confirmation claire de l'opération

== Sécurité et validation

=== Validation d'entrée ciblée
```typescript
// Validation explicite des champs business-critical
if (!data.id_book || !data.id_genre || !data.user_id) {
    throw new Error('id_book, id_genre, and user_id are required.');
}
```

=== Sécurité déléguée
- **Validation UUID** : Format d'ID validé par le service
- **Existence des entités** : Contrôlée par EntityValidator
- **Permissions d'assignation** : Vérifiées côté service
- **Prévention doublons** : Gérée par contraintes base + service

=== Audit trail
- **user_id obligatoire** : Traçabilité de qui assigne quoi
- **Dates automatiques** : created_at pour historique d'assignation
- **IDs d'association** : Identifiants uniques pour audit
- **Logs applicatifs** : Enregistrement des assignations réussies

== Exemple de flux complet

=== Scénario : Catégorisation d'un nouveau livre de cyberpunk

**1. Consultation des genres actuels du livre :**
```http
GET /books/neuromancer-uuid/genres
```

**Réponse initiale (livre non catégorisé) :**
```json
{
  "book": {"title": "Neuromancer", ...},
  "genres": [],
  "total_genres": 0
}
```

**2. Assignation du genre Cyberpunk :**
```http
POST /books/genres/assign
Content-Type: application/json

{
  "id_book": "neuromancer-uuid",
  "id_genre": "cyberpunk-uuid",
  "user_id": "librarian-uuid"
}
```

**Réponse d'assignation :**
```json
{
  "message": "Genre assigned to book successfully.",
  "book_genre": {"id_book_genre": "new-assoc-uuid", ...},
  "book": {"title": "Neuromancer", ...},
  "genre": {"genre_name": "Cyberpunk", ...}
}
```

**3. Vérification de l'assignation :**
```http
GET /books/neuromancer-uuid/genres
```

**Réponse mise à jour :**
```json
{
  "book": {"title": "Neuromancer", ...},
  "genres": [
    {
      "id_book_genre": "new-assoc-uuid",
      "genre": {"genre_name": "Cyberpunk", ...}
    }
  ],
  "total_genres": 1
}
```

**4. Exploration des autres livres cyberpunk :**
```http
GET /genres/cyberpunk-uuid/books?limit=10
```

**Navigation thématique complète avec Neuromancer maintenant inclus.**

== Diagramme de séquence - Assignation de genre

[mermaid]
----
sequenceDiagram
    participant Client
    participant BookGenreController
    participant BookGenreService
    participant EntityValidator
    participant Database

    Note over Client, Database: POST /books/genres/assign

    Client->>BookGenreController: POST /books/genres/assign {id_book, id_genre, user_id}
    BookGenreController->>BookGenreController: Parse JSON body

    alt Si champs obligatoires manquants
        BookGenreController-->>Client: 400 "id_book, id_genre, and user_id are required"
    else Validation réussie
        BookGenreController->>BookGenreService: assign({id_book, id_genre, user_id})

        par Validation livre
            BookGenreService->>EntityValidator: validateBook(id_book)
            EntityValidator->>Database: SELECT book WHERE id = id_book
            EntityValidator-->>BookGenreService: bookData
        and Validation genre
            BookGenreService->>EntityValidator: validateGenre(id_genre)
            EntityValidator->>Database: SELECT genre WHERE id = id_genre
            EntityValidator-->>BookGenreService: genreData
        end

        BookGenreService->>Database: SELECT FROM book_genre WHERE id_book = ? AND id_genre = ?
        Database-->>BookGenreService: existingAssociation

        alt Si association existe
            BookGenreService-->>BookGenreController: throw Error("A book with this genre already exists")
            BookGenreController-->>Client: 409 Conflict
        else Association unique
            BookGenreService->>Database: INSERT INTO book_genre VALUES({id_book, id_genre}) RETURNING
            Database-->>BookGenreService: newBookGenre
            BookGenreService-->>BookGenreController: {book_genre: newBookGenre, book, genre}
            BookGenreController->>BookGenreController: Add success message
            BookGenreController-->>Client: 201 {message: "Genre assigned...", book_genre, book, genre}
        end
    end

    Note over Client, Database: GET /genres/:id/books (avec pagination)

    Client->>BookGenreController: GET /genres/cyberpunk-uuid/books?page=2&limit=15
    BookGenreController->>BookGenreController: Extract genreId + parse pagination
    BookGenreController->>BookGenreService: getGenreBooks("cyberpunk-uuid", 2, 15)
    BookGenreService->>EntityValidator: validateGenre("cyberpunk-uuid")
    EntityValidator-->>BookGenreService: genreData

    par Récupération des livres
        BookGenreService->>Database: JOIN book_genre + book WHERE id_genre = ? ORDER BY title LIMIT 15 OFFSET 15
        Database-->>BookGenreService: bookAssociations[]
    and Comptage total
        BookGenreService->>Database: SELECT COUNT(*) FROM book_genre WHERE id_genre = ?
        Database-->>BookGenreService: {count: 47}
    end

    BookGenreService->>BookGenreService: Calculate pagination: current_page=2, total_pages=4
    BookGenreService-->>BookGenreController: {genre, books[], pagination{...}}
    BookGenreController-->>Client: 200 JSON response with pagination
----

== Tests et validation

=== Points de test par endpoint

**getBookGenres() :**
- Livre avec genres multiples (tri alphabétique)
- Livre sans genres (liste vide)
- Livre inexistant (404)

**getGenreBooks() :**
- Genre populaire avec pagination
- Paramètres de pagination invalides
- Genre vide (liste vide mais pagination cohérente)

**assign() :**
- Assignation réussie avec validation complète
- Champs obligatoires manquants (400)
- Association déjà existante (409)
- Entités inexistantes (404)

=== Tests d'intégration
- Workflow complet : assignation → consultation → navigation
- Performance avec grandes collections paginées
- Cohérence des données après assignations multiples

== Résumé

Le controller bookGenreController est l'**interface HTTP pour la catégorisation livre-genre** de l'API BlaBlaBook V2. Il expose **3 endpoints spécialisés** avec :

- **Navigation bidirectionnelle** : Consultation livre→genres et genre→livres
- **Pagination intelligente** : Gestion optimisée des grandes collections thématiques
- **Validation ciblée** : Contrôles des champs obligatoires pour assignations
- **Enrichissement UX** : Messages de succès et métadonnées de pagination
- **Architecture hybride** : Délégation simple + validation nécessaire
- **Type safety** : Parsing explicite des paramètres avec valeurs par défaut
- **Audit trail** : Traçabilité des assignations avec user_id obligatoire

**Il combine efficacité de consultation et sécurité d'assignation pour la classification thématique.**