= Controller UserRoleController - Analyse Complète
:toc:
:toclevels: 3

== Vue d'ensemble

Le controller userRoleController constitue la couche de présentation pour la gestion des associations utilisateur-rôle dans l'API BlaBlaBook V2. Il expose des endpoints HTTP RESTful pour consulter, assigner et retirer des rôles avec flexibilité d'assignation et audit trail complet.

== Architecture du controller

=== Design pattern d'assignation sophistiqué
- **Flexibilité d'assignation** : Support id_role ET role_name pour assignation
- **Audit trail complet** : Enregistrement de qui assigne quoi via `currentUser.id`
- **Assignation en lot** : Opération bulk pour efficacité administrative
- **Navigation bidirectionnelle** : Consultation rôles par utilisateur ET utilisateurs par rôle
- **Permissions effectives** : Calcul des droits effectifs d'un utilisateur

=== Rôle dans l'architecture RBAC
Le controller userRoleController orchestre les assignations de droits :

1. **Administration des assignations** : Gestion complète des associations utilisateur-rôle
2. **Flexibilité opérationnelle** : Multiples formats de paramètres supportés
3. **Audit et traçabilité** : Enregistrement des modifications de permissions
4. **Navigation RBAC** : Consultation des structures de permissions
5. **Opérations en lot** : Efficacité pour assignations multiples

== Endpoints disponibles

=== GET /users/:id/roles - getUserRoles()
**Objectif:** Récupérer tous les rôles d'un utilisateur
**Méthode HTTP:** GET
**Paramètres:** `id` (UUID de l'utilisateur)

**Code avec validation :**
```typescript
async getUserRoles(c: Context) {
    const userId = c.req.param('id');
    const result = await userRoleService.getUserRoles(userId);

    if (!result) {
        const error = new Error('User not found.');
        throw error;
    }

    return c.json(result);
}
```

**Fonctionnalité :**
- **Navigation utilisateur** : Consultation des rôles assignés à un utilisateur
- **Validation existence** : Vérification que l'utilisateur existe
- **Données enrichies** : Rôles avec détails complets
- **Vue administrative** : Panorama des droits d'un utilisateur

=== GET /roles/:id/users - getRoleUsers()
**Objectif:** Récupérer tous les utilisateurs ayant un rôle spécifique
**Méthode HTTP:** GET
**Paramètres:** `id` (UUID du rôle)

**Code avec validation :**
```typescript
async getRoleUsers(c: Context) {
    const roleId = c.req.param('id');
    const result = await userRoleService.getRoleUsers(roleId);

    if (!result) {
        const error = new Error('Role not found.');
        throw error;
    }

    return c.json(result);
}
```

**Fonctionnalité :**
- **Navigation rôle** : Consultation des utilisateurs ayant un rôle donné
- **Validation existence** : Vérification que le rôle existe
- **Gestion communauté** : Vue des membres par niveau de droits
- **Administration** : Suivi des assignations par rôle

=== POST /users/roles - assignRole()
**Objectif:** Assigner un rôle à un utilisateur
**Méthode HTTP:** POST
**Authentification:** Middleware requis
**Body JSON flexible:**
```json
{
  "id_user": "uuid-utilisateur", // OU "user_id"
  "id_role": "uuid-role",        // OU "role_name": "ADMIN"
}
```

**Code avec flexibilité d'assignation :**
```typescript
async assignRole(c: Context) {
    const body = await c.req.json();
    const currentUser = c.get('user');

    // Support both id_role and role_name
    let { id_user, id_role, user_id, role_name } = body;

    // Normalize parameter names
    const userId = id_user || user_id;
    let roleId = id_role;

    if (!userId) {
        const error = new Error('id_user or user_id is required.');
        throw error;
    }

    if (!roleId && !role_name) {
        const error = new Error('id_role or role_name is required.');
        throw error;
    }

    // If role_name is provided, find the role_id
    if (role_name && !roleId) {
        const roleResult = await userRoleService.getRoleByName(role_name);
        if (!roleResult) {
            const error = new Error(`Role '${role_name}' not found.`);
            throw error;
        }
        roleId = roleResult.id_role;
    }

    const result = await userRoleService.assignRole(userId, roleId, currentUser.id);
    return c.json({
        message: 'Role assigned successfully.',
        ...result
    }, 201);
}
```

**Flexibilité d'assignation :**
- **Paramètres alternatifs** : `id_user` OU `user_id` acceptés
- **Identification rôle flexible** : `id_role` OU `role_name` supportés
- **Résolution automatique** : Conversion role_name vers id_role
- **Audit intégré** : currentUser.id pour traçabilité des assignations

=== DELETE /users/roles - removeRole()
**Objectif:** Retirer un rôle d'un utilisateur
**Méthode HTTP:** DELETE
**Body JSON requis:**
```json
{
  "id_user": "uuid-utilisateur",
  "id_role": "uuid-role"
}
```

**Code avec validation d'association :**
```typescript
async removeRole(c: Context) {
    const { id_user, id_role } = await c.req.json();

    if (!id_user || !id_role) {
        const error = new Error('id_user and id_role are required.');
        throw error;
    }

    const result = await userRoleService.removeRole(id_user, id_role);

    if (!result) {
        const error = new Error('User does not have this role.');
        throw error;
    }

    return c.json({
        message: 'Role removed successfully.',
        user_role: result
    });
}
```

**Sécurité de retrait :**
- **Validation association** : Vérification que l'utilisateur possède le rôle
- **Message spécialisé** : Erreur explicite si association inexistante
- **Suppression sécurisée** : Retrait de l'association uniquement
- **Confirmation** : Association supprimée retournée pour vérification

=== GET /users/:id/permissions - getUserPermissions()
**Objectif:** Récupérer toutes les permissions effectives d'un utilisateur
**Méthode HTTP:** GET
**Paramètres:** `id` (UUID de l'utilisateur)

**Code avec calcul des permissions :**
```typescript
async getUserPermissions(c: Context) {
    const userId = c.req.param('id');
    const result = await userRoleService.getUserPermissions(userId);

    if (!result) {
        const error = new Error('User not found.');
        throw error;
    }

    return c.json(result);
}
```

**Calcul des permissions effectives :**
- **Agrégation des rôles** : Compilation des permissions de tous les rôles
- **Déduplication** : Élimination des permissions dupliquées
- **Vue globale** : Panorama complet des droits effectifs
- **Contrôle d'accès** : Base pour vérification des autorisations

=== POST /users/roles/bulk - bulkAssignRoles()
**Objectif:** Assigner plusieurs rôles à un utilisateur en une opération
**Méthode HTTP:** POST
**Authentification:** Middleware requis
**Body JSON requis:**
```json
{
  "id_user": "uuid-utilisateur",
  "role_ids": ["uuid-role-1", "uuid-role-2", "uuid-role-3"]
}
```

**Code avec assignation en lot :**
```typescript
async bulkAssignRoles(c: Context) {
    const { id_user, role_ids } = await c.req.json();
    const currentUser = c.get('user');

    if (!id_user || !role_ids || !Array.isArray(role_ids) || role_ids.length === 0) {
        const error = new Error('id_user and role_ids (array) are required.');
        throw error;
    }

    const result = await userRoleService.bulkAssignRoles(id_user, role_ids, currentUser.id);
    return c.json({
        message: `${result.assigned_roles.length} roles assigned successfully.`,
        ...result
    }, 201);
}
```

**Efficacité administrative :**
- **Validation array** : Vérification que role_ids est un tableau non vide
- **Opération atomique** : Assignation de tous les rôles en une transaction
- **Message dynamique** : Nombre de rôles assignés dans la réponse
- **Audit complet** : currentUser.id pour traçabilité des assignations en lot

== Patterns de conception

=== Flexibilité d'assignation avancée
```typescript
// Support de multiples formats de paramètres
let { id_user, id_role, user_id, role_name } = body;

// Normalisation des noms de paramètres
const userId = id_user || user_id;
let roleId = id_role;

// Résolution automatique role_name vers id_role
if (role_name && !roleId) {
    const roleResult = await userRoleService.getRoleByName(role_name);
    roleId = roleResult.id_role;
}
```

**Avantages flexibilité :**
- **Compatibilité API** : Support de multiples conventions de nommage
- **UX développeur** : Facilité d'intégration avec différents clients
- **Migration progressive** : Transition entre versions d'API facilitée
- **Adaptabilité** : Réponse aux besoins variés d'assignation

=== Audit trail sophistiqué
```typescript
// Enregistrement systématique de qui fait les assignations
const result = await userRoleService.assignRole(userId, roleId, currentUser.id);
const result = await userRoleService.bulkAssignRoles(id_user, role_ids, currentUser.id);
```

**Traçabilité complète :**
- **Qui** : currentUser.id pour identification de l'assignateur
- **Quoi** : user_id et role_ids pour détails de l'assignation
- **Quand** : Horodatage automatique des opérations
- **Historique** : Conservation des logs d'assignation pour audit

=== Assignation en lot optimisée
```typescript
// Validation et opération batch
if (!id_user || !role_ids || !Array.isArray(role_ids) || role_ids.length === 0) {
    const error = new Error('id_user and role_ids (array) are required.');
    throw error;
}

const result = await userRoleService.bulkAssignRoles(id_user, role_ids, currentUser.id);
```

**Performance et atomicité :**
- **Validation array** : Contrôles de type et de contenu
- **Transaction unique** : Toutes assignations ou aucune
- **Performance** : Réduction du nombre de requêtes database
- **Cohérence** : État RBAC cohérent après opération

=== Messages enrichis avec compteurs
```typescript
return c.json({
    message: `${result.assigned_roles.length} roles assigned successfully.`,
    ...result
}, 201);
```

**Feedback quantitatif :**
- **Compteurs dynamiques** : Nombre d'opérations réalisées
- **Données détaillées** : Résultats complets des opérations
- **Status appropriés** : 201 pour créations, 200 pour consultations
- **UX administrative** : Feedback précis pour gestion RBAC

== Sécurité et contrôle d'accès

=== Audit trail complet
**Enregistrement systématique :**
- **currentUser.id** : Qui effectue les assignations
- **Opérations horodatées** : created_at automatique
- **Données complètes** : Associations créées/supprimées retournées
- **Historique** : Conservation pour investigations sécurité

=== Validation bidirectionnelle
- **Existence utilisateur** : Vérification que l'utilisateur cible existe
- **Existence rôle** : Validation que le rôle à assigner existe
- **Association unique** : Prévention des doublons d'assignation
- **Intégrité référentielle** : Maintien de la cohérence RBAC

=== Protection des opérations sensibles
- **Authentification requise** : currentUser obligatoire pour assignations
- **Validation des droits** : Contrôle que l'assignateur a les permissions
- **Transactions atomiques** : Cohérence garantie pour opérations complexes
- **Logs d'audit** : Traçabilité pour investigations

== Gestion d'erreurs

=== Stratégie d'erreurs par endpoint
**Consultation :** 404 si utilisateur/rôle inexistant
**Assignation :** 400 si paramètres manquants, 404 si entités inexistantes, 409 si déjà assigné
**Suppression :** 400 si paramètres manquants, 404 si association inexistante

=== Codes de réponse
- **200** : Consultation réussie
- **201** : Assignation/assignation en lot réussie
- **400** : Paramètres manquants ou invalides
- **401** : Authentification requise
- **403** : Permissions insuffisantes pour assignation
- **404** : Utilisateur, rôle ou association non trouvé
- **409** : Conflit métier (rôle déjà assigné)

=== Messages d'erreur spécialisés
```typescript
// Messages adaptés au contexte RBAC
'id_user or user_id is required.'
'id_role or role_name is required.'
'Role \'ADMIN\' not found.'
'User does not have this role.'
'id_user and role_ids (array) are required.'
```

== Performance et optimisation

=== Optimisations de consultation
- **Requêtes enrichies** : Données complètes en une seule requête
- **Cache des permissions** : Mise en cache des calculs de permissions effectives
- **Index optimisés** : Performance sur user_id et role_id
- **Pagination** : Limitation pour grandes listes d'assignations

=== Optimisations des assignations
- **Opérations en lot** : Réduction du nombre de transactions
- **Validation batch** : Contrôles groupés pour efficacité
- **Transactions optimisées** : Atomicité avec performance
- **Cache invalidation** : Nettoyage intelligent du cache permissions

== Résumé

Le controller userRoleController est l'**interface HTTP pour les assignations utilisateur-rôle** de l'API BlaBlaBook V2. Il expose **6 endpoints** avec :

- **Flexibilité d'assignation sophistiquée** : Support id_role ET role_name, multiples conventions de nommage
- **Audit trail complet** : Enregistrement de qui assigne quoi via currentUser.id
- **Assignation en lot optimisée** : Opération bulk pour efficacité administrative
- **Navigation bidirectionnelle** : Consultation rôles par utilisateur ET utilisateurs par rôle
- **Permissions effectives** : Calcul et consultation des droits consolidés
- **Validation bidirectionnelle** : Contrôles d'existence utilisateur ET rôle
- **Messages enrichis quantitatifs** : Feedback avec compteurs d'opérations

**Il constitue l'interface centrale pour l'administration des assignations RBAC avec flexibilité et traçabilité maximales.**