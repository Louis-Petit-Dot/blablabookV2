= Controller BookController - Analyse Complète
:toc:
:toclevels: 3

== Vue d'ensemble

Le controller bookController constitue la couche de présentation pour la gestion et la recherche de livres dans l'API BlaBlaBook V2. Il expose les endpoints HTTP RESTful pour la consultation, recherche et listage des livres avec une interface simple et efficace.

== Architecture du controller

=== Rôle dans l'architecture MVC
Le controller bookController agit comme l'interface HTTP minimaliste entre le client et la logique métier :

1. **Réception des requêtes** : Parsing des paramètres de recherche et d'URL
2. **Validation basique** : Contrôles simples des paramètres obligatoires
3. **Délégation métier** : Appel direct des méthodes de bookService
4. **Formatage de réponse** : Retour JSON immédiat sans transformation
5. **Gestion d'erreurs** : Propagation transparente vers les middlewares globaux

=== Design pattern simplifié
Contrairement à d'autres controllers, bookController adopte une approche épurée :
- **Délégation directe** : Pas de logique métier dans le controller
- **Validation minimale** : Seuls les paramètres critiques sont vérifiés
- **Gestion d'erreurs transparente** : Pas de try/catch spécifique
- **Code concis** : Focus sur la lisibilité et la maintenabilité

== Endpoints disponibles

=== GET /books/search - search()
**Objectif:** Effectuer une recherche de livres par requête textuelle
**Méthode HTTP:** GET
**Paramètres de query:**
- `q` (obligatoire) : Terme de recherche

**Flux de traitement :**
1. Extraction de la query `q` via `c.req.query('q')`
2. Validation présence du paramètre obligatoire
3. Appel direct à `bookService.search(query)`
4. Retour JSON immédiat sans transformation

**Validation d'entrée :**
```typescript
const query = c.req.query('q');

if (!query) {
    throw new Error('Search query is required.');
}
```

**Exemple d'utilisation :**
```http
GET /books/search?q=dune
GET /books/search?q=science%20fiction
GET /books/search?q=frank%20herbert
```

**Réponse type :**
```json
{
  "books": [...],
  "total_books": 25,
  "search_query": "dune"
}
```

**Codes de réponse :**
- `200` : Recherche réussie (même si 0 résultat)
- `400` : Paramètre de recherche manquant
- `500` : Erreur serveur

=== GET /books/:id - getById()
**Objectif:** Récupérer un livre spécifique par son identifiant
**Méthode HTTP:** GET
**Paramètres:**
- `id` (URL parameter) : Identifiant unique du livre

**Flux de traitement :**
1. Extraction de l'ID depuis `c.req.param('id')`
2. Appel direct à `bookService.getById(bookId)`
3. Retour JSON des détails complets du livre

**Exemple d'utilisation :**
```http
GET /books/550e8400-e29b-41d4-a716-446655440000
```

**Réponse type :**
```json
{
  "book": {
    "id_book": "...",
    "title": "Dune",
    "isbn": "9780441172719",
    "summary": "...",
    "publication_year": 1965,
    "nb_pages": 688,
    "language": "en",
    "image": "https://...",
    "created_at": "2024-01-15T10:30:00Z"
  }
}
```

**Codes de réponse :**
- `200` : Livre trouvé et retourné
- `404` : Livre non trouvé
- `500` : Erreur serveur

=== GET /books - getAll()
**Objectif:** Récupérer la liste paginée des livres
**Méthode HTTP:** GET
**Paramètres de query:**
- `limit` (optionnel) : Nombre de livres à retourner (défaut: 50)

**Flux de traitement :**
1. Extraction et parsing du paramètre `limit`
2. Application de la valeur par défaut si non fourni
3. Appel à `bookService.getAll(limit)`
4. Retour JSON de la liste paginée

**Parsing et validation :**
```typescript
const limit = parseInt(c.req.query('limit') || '50');
```

**Exemple d'utilisation :**
```http
GET /books
GET /books?limit=20
GET /books?limit=100
```

**Réponse type :**
```json
{
  "books": [...],
  "total_books": 1250,
  "limit": 50,
  "displayed_count": 50
}
```

**Codes de réponse :**
- `200` : Liste retournée avec succès
- `500` : Erreur serveur

=== GET /books/:userId/books - getUserBooks()
**Objectif:** Récupérer tous les livres uniques d'un utilisateur (toutes bibliothèques confondues)
**Méthode HTTP:** GET
**Paramètres:**
- `userId` (URL parameter) : Identifiant de l'utilisateur

**Flux de traitement :**
1. Extraction du userId depuis `c.req.param('userId')`
2. Requête vers la vue `BookLibraryView` avec filtrage par propriétaire
3. Déduplication des livres présents dans plusieurs bibliothèques
4. Retour JSON de la liste unique des livres

**Code de déduplication :**
```typescript
const uniqueBooksMap = new Map();
allBookLibraries.forEach(bookLibrary => {
    if (!uniqueBooksMap.has(bookLibrary.id_book)) {
        uniqueBooksMap.set(bookLibrary.id_book, bookLibrary);
    }
});

const books = Array.from(uniqueBooksMap.values());
```

**Réponse type :**
```json
{
  "books": [
    {
      "id_book": "uuid",
      "title": "Dune",
      "library_name": "Ma bibliothèque",
      "library_owner_id": "user-uuid"
    }
  ]
}
```

**Codes de réponse :**
- `200` : Livres récupérés avec succès
- `500` : Erreur serveur (base de données)

=== GET /books/trending - getTrending()
**Objectif:** Récupérer les livres tendances ou populaires
**Méthode HTTP:** GET
**Paramètres de query:**
- `limit` (optionnel) : Nombre de livres à retourner (défaut: 20)

**Flux de traitement :**
1. Extraction et parsing du paramètre `limit`
2. Application de la valeur par défaut si non fourni
3. Appel à `bookService.getTrending(limit)`
4. Retour JSON des livres populaires

**Exemple d'utilisation :**
```http
GET /books/trending
GET /books/trending?limit=10
```

**Codes de réponse :**
- `200` : Livres tendances retournés
- `500` : Erreur serveur

=== POST /books - create()
**Objectif:** Créer un livre dans la base de données depuis les données Open Library
**Méthode HTTP:** POST
**Body JSON requis:**
```json
{
  "key": "/works/OL123456W",
  "title": "Dune",
  "author_name": ["Frank Herbert"],
  "first_publish_year": 1965,
  "cover_i": 123456
}
```

**Validation d'entrée :**
```typescript
if (!body.key || !body.title) {
    return c.json({
        error: "Les champs 'key' et 'title' sont requis"
    }, 400);
}
```

**Flux de traitement :**
1. Validation des champs obligatoires (key, title)
2. Appel à `bookService.createFromOpenLibrary(body)`
3. Détection automatique des doublons par le service
4. Retour 201 si nouveau livre, 200 si livre existant

**Réponse de création (201) :**
```json
{
  "book": {
    "id_book": "uuid",
    "title": "Dune",
    "key": "/works/OL123456W"
  },
  "isNew": true
}
```

**Réponse de doublon (200) :**
```json
{
  "book": {
    "id_book": "existing-uuid",
    "title": "Dune"
  },
  "isNew": false
}
```

**Codes de réponse :**
- `200` : Livre déjà existant retourné
- `201` : Nouveau livre créé avec succès
- `400` : Champs obligatoires manquants
- `500` : Erreur serveur

=== DELETE /books/:id - delete()
**Objectif:** Supprimer un livre de la base de données avec cascade
**Méthode HTTP:** DELETE
**Paramètres:**
- `id` (URL parameter) : Identifiant du livre

**Flux de traitement avec gestion d'erreurs :**
1. Vérification de l'existence du livre via SELECT
2. Si non trouvé : retour 404
3. Si trouvé : suppression avec cascade automatique
4. Retour message de confirmation avec données du livre supprimé

**Code avec contrôle d'existence :**
```typescript
const book = await db()
    .select()
    .from(Book)
    .where(eq(Book.id_book, bookId))
    .limit(1);

if (book.length === 0) {
    return c.json({ error: 'Book not found' }, 404);
}

await db()
    .delete(Book)
    .where(eq(Book.id_book, bookId));
```

**Suppressions en cascade :**
- Relations avec bibliothèques (book_library)
- Relations avec listes de lecture (book_reading_list)
- Relations avec auteurs (author_book)
- Relations avec genres (book_genre)
- Reviews associés
- Notations associées

**Réponse de succès :**
```json
{
  "message": "Book deleted successfully",
  "book": {
    "id_book": "uuid",
    "title": "Dune",
    "key": "/works/OL123456W"
  }
}
```

**Codes de réponse :**
- `200` : Livre supprimé avec succès
- `404` : Livre non trouvé
- `500` : Erreur serveur (contraintes SQL)

== Patterns de conception

=== Simplicité par design
Le controller bookController illustre le principe KISS (Keep It Simple, Stupid) :

**Avantages :**
- **Lisibilité maximale** : Code facile à comprendre et maintenir
- **Faible couplage** : Dépendance minimale avec la logique métier
- **Performance optimisée** : Aucune transformation de données inutile
- **Testabilité** : Surface d'API réduite facilitant les tests

**Comparaison avec d'autres controllers :**
- **authorController** : Validation Wikipedia côté controller
- **userController** : Gestion d'erreurs sophistiquée avec try/catch
- **bookController** : Délégation pure, validation minimale

=== Validation stratifiée
```mermaid
graph TD
    A[Client Request] --> B[BookController]
    B --> C{Validation Basic}
    C -->|Valid| D[BookService]
    C -->|Invalid| E[Error Response]
    D --> F{Validation Business}
    F -->|Valid| G[Database Operations]
    F -->|Invalid| H[Service Error]
    G --> I[Success Response]
    H --> I
    E --> I
```

**Niveaux de validation :**
1. **Controller** : Paramètres obligatoires uniquement
2. **Service** : Logique métier, existence des entités
3. **Database** : Contraintes d'intégrité

== Gestion des paramètres

=== Query parameters
```typescript
// search() - Paramètre obligatoire
const query = c.req.query('q');
if (!query) throw new Error('Search query is required.');

// getAll() - Paramètre optionnel avec défaut
const limit = parseInt(c.req.query('limit') || '50');
```

=== URL parameters
```typescript
// getById() - Extraction directe
const bookId = c.req.param('id');
const result = await bookService.getById(bookId);
```

=== Avantages de l'approche
- **Type safety** : Utilisation de l'API Hono typée
- **Parsing automatique** : Conversion string → number transparente
- **Valeurs par défaut** : Gestion gracieuse des paramètres optionnels
- **Validation ciblée** : Seulement les contrôles essentiels

== Performance et optimisation

=== Délégation efficace
```typescript
// Pattern typique - Délégation directe
async getById(c: Context) {
    const bookId = c.req.param('id');
    const result = await bookService.getById(bookId);
    return c.json(result);
}
```

**Avantages performance :**
- **Pas de transformation** : Données service → JSON directement
- **Pas de logique lourde** : Controller léger, service optimisé
- **Appels asynchrones** : Exploitation complète de Node.js
- **Réponses streamées** : JSON généré à la volée par Hono

=== Gestion de la pagination
```typescript
// getAll() - Pagination simple côté service
const limit = parseInt(c.req.query('limit') || '50');
const result = await bookService.getAll(limit);
```

**Optimisations appliquées :**
- **Limite par défaut** : 50 livres pour équilibrer performance/utilité
- **Parsing sécurisé** : parseInt avec valeur de fallback
- **Délégation logique** : Pagination complexe gérée par le service

== Interaction avec bookService

=== Mapping direct des endpoints
```typescript
// Controller → Service (mapping 1:1)
search(query) → bookService.search(query)
getById(id) → bookService.getById(id)
getAll(limit) → bookService.getAll(limit)
```

=== Cohérence des interfaces
- **Paramètres** : Transmission directe sans transformation
- **Réponses** : Format JSON du service conservé
- **Erreurs** : Propagation transparente pour handling global

=== Extensibilité
L'approche simple facilite l'évolution :
```typescript
// Évolution future possible
async getAll(c: Context) {
    const limit = parseInt(c.req.query('limit') || '50');
    const offset = parseInt(c.req.query('offset') || '0');
    const sort = c.req.query('sort') || 'title';

    const result = await bookService.getAll({ limit, offset, sort });
    return c.json(result);
}
```

== Gestion des erreurs

=== Stratégie de propagation
```typescript
// Pas de try/catch - Délégation au middleware global
async search(c: Context) {
    const query = c.req.query('q');
    if (!query) {
        throw new Error('Search query is required.'); // Propagé
    }
    const result = await bookService.search(query); // Erreurs propagées
    return c.json(result);
}
```

**Avantages :**
- **Cohérence** : Gestion d'erreurs centralisée
- **Simplicité** : Moins de code répétitif
- **Maintenabilité** : Format d'erreur uniforme
- **Performance** : Pas de try/catch inutiles

=== Types d'erreurs gérées
1. **Validation d'entrée** : Paramètres manquants → 400
2. **Erreurs service** : Livre non trouvé → 404
3. **Erreurs système** : Database down → 500

== Sécurité

=== Validation d'entrée minimale
```typescript
// Validation essentielle seulement
if (!query) {
    throw new Error('Search query is required.');
}
```

=== Sécurité par délégation
- **Sanitisation** : Gérée par Hono et le service
- **Injection SQL** : Prévenue par l'ORM Drizzle
- **Validation métier** : Déléguée au service
- **Rate limiting** : Géré par middleware (si configuré)

== Exemple de flux complet

=== Scénario : Recherche et consultation d'un livre

**1. Recherche initiale :**
```http
GET /books/search?q=foundation%20isaac%20asimov
```

**Traitement :**
1. Controller extrait `q = "foundation isaac asimov"`
2. Validation présence de la query
3. Appel `bookService.search("foundation isaac asimov")`
4. Service effectue recherche full-text
5. Retour JSON des résultats

**2. Consultation détaillée :**
```http
GET /books/550e8400-e29b-41d4-a716-446655440000
```

**Traitement :**
1. Controller extrait `id = "550e8400..."`
2. Appel `bookService.getById("550e8400...")`
3. Service valide existence + récupère détails
4. Retour JSON complet du livre

== Diagramme de séquence - Recherche de livres

[mermaid]
----
sequenceDiagram
    participant Client
    participant BookController
    participant BookService
    participant Database

    Note over Client, Database: GET /books/search?q=dune

    Client->>BookController: GET /books/search?q=dune
    BookController->>BookController: Extract query parameter

    alt Si query manquante
        BookController-->>Client: 400 "Search query is required"
    else Query présente
        BookController->>BookService: search("dune")
        BookService->>Database: Full-text search
        Database-->>BookService: matching books[]
        BookService->>BookService: Calculate total_books
        BookService-->>BookController: {books[], total_books, search_query}
        BookController-->>Client: 200 JSON response
    end

    Note over Client, Database: GET /books/:id

    Client->>BookController: GET /books/550e8400-e29b-41d4-a716-446655440000
    BookController->>BookController: Extract id parameter
    BookController->>BookService: getById("550e8400...")
    BookService->>Database: SELECT book details

    alt Si livre non trouvé
        Database-->>BookService: empty result
        BookService-->>BookController: throw "Book not found"
        BookController-->>Client: 404 error
    else Livre trouvé
        Database-->>BookService: book data
        BookService-->>BookController: {book}
        BookController-->>Client: 200 {book}
    end

    Note over Client, Database: GET /books?limit=20

    Client->>BookController: GET /books?limit=20
    BookController->>BookController: Parse limit parameter (default 50)
    BookController->>BookService: getAll(20)
    BookService->>Database: SELECT books LIMIT 20
    Database-->>BookService: books[] + total count
    BookService-->>BookController: {books[], total_books, limit, displayed_count}
    BookController-->>Client: 200 JSON response
----

== Tests et validation

=== Points de test recommandés

**Tests unitaires :**
- Extraction correcte des paramètres query et URL
- Validation des paramètres obligatoires
- Parsing des paramètres numériques avec défauts
- Appels corrects aux méthodes du service

**Tests d'intégration :**
- Recherche avec différents termes et résultats
- Consultation de livres existants et inexistants
- Pagination avec différentes limites
- Performance avec grandes collections

**Tests de charge :**
- Recherches simultanées multiples
- Consultation massive d'IDs
- Comportement avec grandes listes (getAll)

== Résumé

Le controller bookController est l'**interface HTTP simplifiée pour la gestion des livres** de l'API BlaBlaBook V2. Il expose **3 endpoints RESTful** avec :

- **Design minimaliste** : Délégation directe sans logique métier
- **Validation ciblée** : Seuls les paramètres critiques sont vérifiés
- **Gestion d'erreurs transparente** : Propagation vers middlewares globaux
- **Performance optimisée** : Aucune transformation de données inutile
- **Pagination simple** : Limite configurable avec valeur par défaut
- **Type safety complet** : Utilisation exhaustive des types Hono
- **Extensibilité facilitée** : Architecture prête pour évolutions futures

**Il illustre le principe KISS pour une interface HTTP efficace et maintenable.**