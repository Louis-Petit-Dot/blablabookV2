= Hooks Personnalis√©s - Guide Complet
:toc: left
:toclevels: 3
:sectanchors:
:icons: font
:source-highlighter: highlight.js

== üìö C'est Quoi un Hook ?

=== D√©finition Simple

Un **hook** est une **fonction r√©utilisable** qui contient de la **logique m√©tier** (appels API, gestion d'√©tats, calculs...) pour √©viter de dupliquer du code dans vos composants.

**Analogie :**

Imaginez que vous devez faire du caf√© plusieurs fois par jour :

* *Sans hook* : Chaque fois, vous sortez le caf√©, le filtre, l'eau, vous pr√©parez... (code dupliqu√© partout)
* *Avec hook* : Vous avez une machine √† caf√© ‚Üí vous appuyez sur un bouton (fonction simple) ‚Üí le caf√© se fait tout seul

Le hook = la machine qui fait tout le travail complexe pour vous.

---

=== R√®gles des Hooks React

[IMPORTANT]
====
1. Les hooks doivent **commencer par `use`** (convention React)
2. Ils ne peuvent √™tre appel√©s **qu'au niveau racine** d'un composant (pas dans des boucles, conditions, ou fonctions imbriqu√©es)
3. Ils ne peuvent √™tre utilis√©s **que dans des composants React** ou d'autres hooks
====

**Exemple :**

[source,tsx]
----
// ‚úÖ BON
function BookPage() {
    const { ratings, submitRating } = useRating(bookId)  // OK : niveau racine

    return <div>...</div>
}

// ‚ùå MAUVAIS
function BookPage() {
    if (someCondition) {
        const { ratings } = useRating(bookId)  // ERREUR : dans une condition
    }
}
----

---

=== Quand Utiliser un Hook ?

Cr√©ez un hook personnalis√© quand :

* ‚úÖ Vous **r√©p√©tez la m√™me logique** dans plusieurs composants
* ‚úÖ Vous avez une **logique complexe** (appels API, gestion d'√©tat, calculs)
* ‚úÖ Vous voulez **s√©parer la logique m√©tier** de l'affichage (UI)
* ‚úÖ Vous voulez **rendre votre code testable** facilement

**Exemple concret :**

Sans hook ‚Üí Dupliquer ce code dans chaque page :

[source,tsx]
----
function BookPage() {
    const [ratings, setRatings] = useState([])
    const [isLoading, setIsLoading] = useState(false)

    useEffect(() => {
        const fetchRatings = async () => {
            setIsLoading(true)
            try {
                const { data } = await api.get(`/api/rates/book/${bookId}/rates`)
                setRatings(data.rates)
            } catch (error) {
                console.error(error)
            } finally {
                setIsLoading(false)
            }
        }
        fetchRatings()
    }, [bookId])

    // ... 50 lignes de code m√©tier
}
----

Avec hook ‚Üí Code simple et r√©utilisable :

[source,tsx]
----
function BookPage() {
    const { ratings, isLoading, submitRating } = useRating(bookId)  // 1 ligne !

    return <RatingDisplay ratings={ratings} />
}
----

---

== üéØ Avantages des Hooks Personnalis√©s

[cols="1,3"]
|===
|Avantage |Exemple

|**R√©utilisabilit√©**
|`useRating` peut √™tre utilis√© dans BookPage, UserPage, AdminPage...

|**S√©paration des responsabilit√©s**
|Composant = affichage, Hook = logique m√©tier

|**Testabilit√©**
|Tester un hook isol√©ment est plus facile qu'un gros composant

|**Lisibilit√©**
|Code plus clair et organis√©

|**Maintenance**
|Corriger un bug dans le hook = correction partout automatiquement
|===

---

== üìÇ Organisation de nos Hooks

[source]
----
frontend/src/hooks/
‚îú‚îÄ‚îÄ README.adoc           ‚Üê Ce fichier (documentation)
‚îú‚îÄ‚îÄ useRating.ts          ‚Üê Gestion des notes (ratings)
‚îú‚îÄ‚îÄ useReview.ts          ‚Üê Gestion des avis (reviews)
‚îú‚îÄ‚îÄ useLibrary.ts         ‚Üê Gestion des biblioth√®ques
‚îú‚îÄ‚îÄ useReadingLists.ts    ‚Üê Gestion des listes de lecture
‚îî‚îÄ‚îÄ useAddToLibrary.ts    ‚Üê Ajout livre √† biblioth√®que (optionnel)
----

---

== üåü Hook 1 : useRating

=== Objectif

G√©rer **toutes les interactions** avec les notes (ratings) d'un livre :

* R√©cup√©rer les notes (moyenne + liste)
* Cr√©er ou modifier la note de l'utilisateur
* Supprimer la note de l'utilisateur
* G√©rer les √©tats de chargement et erreurs

=== Quand l'Utiliser ?

Dans **tout composant** qui affiche ou permet de noter un livre :

* `BookPage.tsx` - Afficher moyenne + permettre de noter
* `SearchBookCard.tsx` - Afficher la note moyenne sur les cartes
* `UserPage.tsx` - Afficher les livres que l'utilisateur a not√©s
* `AdminDashboard.tsx` - Statistiques des notes

=== API Backend Utilis√©e

[source,typescript]
----
// R√©cup√©rer les notes d'un livre
GET /api/rates/book/:id/rates

Response: {
  book: { id_book: string, title: string },
  rates: Rate[],
  average_rating: number | null  // Ex: 3.24
}

// Cr√©er ou mettre √† jour la note (upsert automatique)
POST /api/rates
Body: { id_book: string, rating: number }

// Supprimer sa note
DELETE /api/rates/:id
----

=== Types TypeScript

[source,typescript]
----
interface Rate {
    id_rate: string
    rating: number  // 1-5 (entier)
    created_at: string
    updated_at: string
    user_id: string
    user_username: string
    user_firstname: string
    user_lastname: string
}

interface UseRatingReturn {
    // üìä Donn√©es
    ratings: Rate[]              // Liste de toutes les notes
    averageRating: number | null // Moyenne calcul√©e (ex: 3.24)
    totalRatings: number         // Nombre total de notes
    userRating: Rate | null      // Note de l'utilisateur connect√© (si existe)

    // ‚è≥ √âtats
    isLoading: boolean           // Chargement en cours ?
    error: string | null         // Message d'erreur (si √©chec)

    // üé¨ Actions
    fetchRatings: () => Promise<void>     // Recharger les notes
    submitRating: (rating: number) => Promise<void>  // Noter (cr√©e ou modifie)
    deleteRating: () => Promise<void>     // Supprimer sa note
}
----

=== Utilisation dans un Composant

[source,tsx]
----
import { useRating } from '../hooks/useRating'
import { RatingStars } from '../components/Rate/RatingStars'

function BookPage({ bookId }: { bookId: string }) {
    const {
        averageRating,      // Moyenne des notes
        totalRatings,       // Nombre de votes
        userRating,         // Note de l'utilisateur (si existe)
        isLoading,          // √âtat de chargement
        error,              // Erreur √©ventuelle
        submitRating,       // Fonction pour noter
        deleteRating        // Fonction pour supprimer
    } = useRating(bookId)

    // Affichage pendant le chargement
    if (isLoading) {
        return <Loader />
    }

    // Affichage en cas d'erreur
    if (error) {
        return <ErrorMessage message={error} />
    }

    return (
        <div>
            {/* Afficher la moyenne */}
            <div>
                <RatingStars value={averageRating || 0} readOnly size="L" />
                <p>({averageRating?.toFixed(1)}/5 ‚Ä¢ {totalRatings} avis)</p>
            </div>

            {/* Permettre √† l'utilisateur de noter */}
            <div>
                <h3>Votre note :</h3>
                <RatingStars
                    value={userRating?.rating || 0}
                    onChange={(rating) => submitRating(rating)}
                    size="M"
                />

                {/* Bouton supprimer si l'utilisateur a d√©j√† not√© */}
                {userRating && (
                    <button onClick={deleteRating}>
                        Supprimer ma note
                    </button>
                )}
            </div>
        </div>
    )
}
----

=== Fonctionnement Interne

==== 1. **Chargement Automatique**

Le hook charge automatiquement les notes d√®s que le composant est mont√© :

[source,typescript]
----
useEffect(() => {
    fetchRatings()  // Appel API au montage
}, [fetchRatings])
----

==== 2. **D√©tection Note Utilisateur**

Le hook cherche automatiquement la note de l'utilisateur connect√© :

[source,typescript]
----
const userRating = ratings.find(rate => rate.user_id === user?.id_user) || null
----

Cela permet d'afficher la note existante dans les √©toiles.

==== 3. **Upsert Automatique (Create or Update)**

Le backend g√®re automatiquement :

* Si l'utilisateur n'a **jamais not√©** ‚Üí **Cr√©ation** d'une nouvelle note
* Si l'utilisateur a **d√©j√† not√©** ‚Üí **Mise √† jour** de sa note existante

Vous n'avez qu'√† appeler `submitRating(4)` et le backend fait le reste !

==== 4. **Refresh Apr√®s Modification**

Apr√®s avoir not√© ou supprim√©, le hook recharge automatiquement les donn√©es :

[source,typescript]
----
const submitRating = async (rating: number) => {
    await api.post('/api/rates', { id_book: bookId, rating })
    await fetchRatings()  // ‚Üê Recharge pour avoir la nouvelle moyenne
}
----

---

=== Cas d'Usage Complets

==== Cas 1 : Afficher la Note Moyenne (Readonly)

[source,tsx]
----
function BookCard({ bookId }: { bookId: string }) {
    const { averageRating, totalRatings, isLoading } = useRating(bookId)

    if (isLoading) return <Skeleton />

    return (
        <div>
            <RatingStars value={averageRating || 0} readOnly size="S" />
            <span>{totalRatings} avis</span>
        </div>
    )
}
----

==== Cas 2 : Permettre de Noter (Interactive)

[source,tsx]
----
function RateBookSection({ bookId }: { bookId: string }) {
    const { userRating, submitRating, isLoading } = useRating(bookId)

    return (
        <div>
            <h3>Notez ce livre :</h3>
            <RatingStars
                value={userRating?.rating || 0}
                onChange={submitRating}
                size="L"
            />
            {isLoading && <Spinner />}
        </div>
    )
}
----

==== Cas 3 : Liste des Notes avec Actions (Admin)

[source,tsx]
----
function RatingsListAdmin({ bookId }: { bookId: string }) {
    const { ratings, isLoading } = useRating(bookId)

    if (isLoading) return <Loader />

    return (
        <table>
            <thead>
                <tr>
                    <th>Utilisateur</th>
                    <th>Note</th>
                    <th>Date</th>
                </tr>
            </thead>
            <tbody>
                {ratings.map(rate => (
                    <tr key={rate.id_rate}>
                        <td>{rate.user_username}</td>
                        <td>
                            <RatingStars value={rate.rating} readOnly size="S" />
                        </td>
                        <td>{new Date(rate.created_at).toLocaleDateString()}</td>
                    </tr>
                ))}
            </tbody>
        </table>
    )
}
----

---

=== Gestion des Erreurs

Le hook g√®re automatiquement les erreurs :

[cols="1,2,2"]
|===
|Erreur |Quand ? |Message

|Non authentifi√©
|Tentative de noter sans √™tre connect√©
|"Vous devez √™tre connect√© pour noter"

|Note invalide
|`rating < 1` ou `rating > 5`
|"La note doit √™tre entre 1 et 5"

|Erreur API
|Probl√®me r√©seau, backend down
|Message d'erreur du backend

|Aucune note √† supprimer
|`deleteRating()` sans note existante
|"Aucune note √† supprimer"
|===

**Exemple d'affichage :**

[source,tsx]
----
function BookPage({ bookId }: { bookId: string }) {
    const { error } = useRating(bookId)

    return (
        <div>
            {error && (
                <div className="error-banner">
                    ‚ö†Ô∏è {error}
                </div>
            )}
            {/* ... reste du composant */}
        </div>
    )
}
----

---

=== Performance et Optimisation

==== useCallback

Les fonctions sont wrapp√©es avec `useCallback` pour √©viter des re-renders inutiles :

[source,typescript]
----
const fetchRatings = useCallback(async () => {
    // ...
}, [bookId])  // Ne se recr√©√© que si bookId change
----

==== Auto-refresh

Le hook se recharge automatiquement si `bookId` change :

[source,tsx]
----
// Passer de livre A √† livre B ‚Üí fetchRatings() est rappel√©
<BookPage bookId="uuid-livre-A" />  // Charge les notes du livre A
<BookPage bookId="uuid-livre-B" />  // Charge les notes du livre B
----

---

=== Tests (Futur)

Le hook peut √™tre test√© isol√©ment avec `@testing-library/react-hooks` :

[source,typescript]
----
import { renderHook, waitFor } from '@testing-library/react'
import { useRating } from './useRating'

test('should load ratings on mount', async () => {
    const { result } = renderHook(() => useRating('book-123'))

    expect(result.current.isLoading).toBe(true)

    await waitFor(() => {
        expect(result.current.isLoading).toBe(false)
        expect(result.current.ratings.length).toBeGreaterThan(0)
    })
})
----

---

== üìù Bonnes Pratiques Hooks

=== 1. Nommage

* ‚úÖ `useRating`, `useReview`, `useLibrary` (pr√©fixe `use`)
* ‚ùå `getRating`, `ratingHook`, `handleRating`

=== 2. Responsabilit√© Unique

Chaque hook doit avoir **une seule responsabilit√©** :

* ‚úÖ `useRating` ‚Üí G√®re UNIQUEMENT les notes
* ‚úÖ `useReview` ‚Üí G√®re UNIQUEMENT les avis
* ‚ùå `useBookData` ‚Üí Trop large (notes + avis + infos livre)

=== 3. Return Explicite

Retournez toujours un **objet** avec des noms clairs :

[source,typescript]
----
// ‚úÖ BON - Noms explicites
return {
    ratings,
    averageRating,
    isLoading,
    submitRating
}

// ‚ùå MAUVAIS - Tableau sans noms
return [ratings, averageRating, submitRating]
----

=== 4. Gestion des Erreurs

Toujours capturer et exposer les erreurs :

[source,typescript]
----
try {
    // Appel API
} catch (err: any) {
    const errorMessage = err.response?.data?.error || 'Erreur inconnue'
    setError(errorMessage)  // ‚Üê Expos√© au composant
}
----

=== 5. Loading States

Toujours g√©rer l'√©tat de chargement :

[source,typescript]
----
const [isLoading, setIsLoading] = useState(false)

setIsLoading(true)
try {
    await api.get(...)
} finally {
    setIsLoading(false)  // ‚Üê M√™me en cas d'erreur
}
----

---

== üîó Ressources

* https://react.dev/learn/reusing-logic-with-custom-hooks[Documentation officielle React - Custom Hooks]
* https://usehooks.com/[useHooks.com - Exemples de hooks]
* https://github.com/streamich/react-use[react-use - Biblioth√®que de hooks utilitaires]

---

== üöÄ Prochains Hooks √† Documenter

* `useReview.ts` - Gestion des avis (reviews)
* `useLibrary.ts` - Gestion des biblioth√®ques
* `useReadingLists.ts` - Gestion des listes de lecture

---

== üì± Hook Responsive - useMediaQuery

=== Description

Hook personnalis√© pour d√©tecter les breakpoints responsive et adapter l'interface selon la taille d'√©cran.

=== Utilisation de Base

[source,typescript]
----
import { useMediaQuery, useBreakpoints } from '../hooks/useMediaQuery'

function MyComponent() {
    // Approche 1 : Media query personnalis√©e
    const isDesktop = useMediaQuery('(min-width: 768px)')
    
    // Approche 2 : Breakpoints pr√©d√©finis
    const { isMobile, isTablet, isDesktop, isDesktopOrLarger } = useBreakpoints()
    
    return (
        <div>
            {isMobile && <MobileMenu />}
            {isDesktop && <DesktopTabs />}
        </div>
    )
}
----

=== Breakpoints BlaBlaBook

[cols="1,2,2"]
|===
|Nom |Taille |Media Query

|Mobile
|320px - 767px
|`(max-width: 767px)`

|Tablet
|768px - 1023px
|`(min-width: 768px) and (max-width: 1023px)`

|Desktop
|1024px - 1279px
|`(min-width: 1024px)`

|Wide
|1280px+
|`(min-width: 1280px)`
|===

=== Exemple Avanc√© : Navigation Responsive

[source,typescript]
----
import { useBreakpoints } from '../hooks/useMediaQuery'

function Navigation() {
    const { isMobile, isDesktopOrLarger } = useBreakpoints()
    
    return (
        <nav>
            {isMobile && <BurgerMenu />}
            {isDesktopOrLarger && <Tabs items={navItems} />}
        </nav>
    )
}
----

**Document g√©n√©r√© le 2025-10-11**

**Status:** ‚úÖ useRating document√© | ‚úÖ useMediaQuery document√© | ‚è≥ Autres hooks √† venir
